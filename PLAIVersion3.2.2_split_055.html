<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.uxu8lpxakrfe"><span class="c4">Desugaring</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">This introduces a distinction between a </span><span class="c7">core</span><span class="calibre3"> language and a </span><span class="c7">surface</span><span class="calibre3"> language. The surface language may have various conveniences, but these get translated into the core language, whose constructs are all handled directly. The extra constructs—those that make it “sweeter” to program—are called </span><span class="c7">syntactic sugar</span><span class="calibre3">. The program that translates surface programs down to the core is called a </span><span class="c7">desugarer</span><span class="calibre3">, because it removes sugar. (In principle, a desugarer is actually a </span><span class="c7">compiler</span><span class="calibre3"> from the surface language to the core language. However, since the core language is a </span><span class="c7">sub</span><span class="calibre3">-language of the surface, this is a very special case of compilation, and we find it useful to have a special term to distinguish it from general compilation. Just like we find it useful to have a special term to distinguish </span><span class="c28">for</span><span class="calibre3"> from the general </span><span class="c28">while</span><span class="c4">…)</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Aside:</span><span class="calibre3"> In a real implementation, this compilation requires a little more care. Suppose you make an error using </span><span class="c28">for</span><span class="calibre3">, but the error was reported in terms of </span><span class="c28">while</span><span class="calibre3">: you’d be pretty confused, because you never did type the </span><span class="c28">while</span><span class="calibre3">. As a special case, you may be a student who doesn’t even know what </span><span class="c28">while</span><span class="calibre3"> </span><span class="c7">is</span><span class="c4">! Modern desguaring systems, such as that in Racket, have special support to take care of this in most of the common cases.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">There are actually many more desugarings in real languages. For instance, </span><span class="c28">and</span><span class="calibre3"> and </span><span class="c28">or</span><span class="calibre3"> can desugar into nested </span><span class="c28">if</span><span class="calibre3">s. In JavaScript, </span><span class="c28">o.x</span><span class="calibre3"> desugars into </span><span class="c28">o["x"]</span><span class="calibre3"> (which will be relevant in a while). In many languages, </span><span class="c28">x += y</span><span class="calibre3"> is sugar for </span><span class="c28">x = x + y</span><span class="calibre3">. In Python, </span><span class="c28">+</span><span class="calibre3"> desugars into the method </span><span class="c28">__add__</span><span class="calibre3">. In fact, Python has a whole bunch of these desugarings; these methods are called “dunder” methods (short for double-underscore), and a whole programming style of “</span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://twitter.com/gvanrossum/status/1307712322320785409&amp;sa=D&amp;source=editors&amp;ust=1695232021233535&amp;usg=AOvVaw2ERm9Pb0kR6LijXtV_K83D">protocols</a></span><span class="c4">” has evolved around it. Many languages (like Haskell and Python) have list comprehensions, which desugar into function and method calls. And so on. In short, desugaring is everywhere in programming. If you don’t notice it, that’s part of the point: it feels like you’re working with a larger surface syntax than the implementor has to manage.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">There are many ways in which desugaring can be implemented. One way is to parse the program normally, then rewrite the AST into a subset of the same AST. But in some languages, especially those with parenthetical syntax, there are two levels of parsing: the coarser parenthetical level and the finer level of ASTs. This means we can perform rewriting on the parenthetical terms, and the internal AST never needs to know about the sugars (i.e., it need cover only the core language). These are typically called </span><span class="c7">macro</span><span class="calibre3"> systems: systems in which program source (slightly abstracted) is rewritten into program source, before parsing takes place. It’s important to understand that </span><span class="c7">most</span><span class="calibre3"> languages have syntactic sugar, but </span><span class="c7">very few</span><span class="c4"> languages have macro systems, which provide program rewriting capabilities directly to the programmer (as opposed to hiding them inside the compiler).</span></p></body></html>
