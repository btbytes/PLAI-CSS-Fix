<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.r3nhok3x9moc"><span class="c4">Extending Classes</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Now we have to port all this code over to our world of desugaring. Is this the constructor pattern?</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define (node/size parent-object v l r)</span></p><p class="c5"><span class="c41">  ...)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">That suggests that the parent is at the “same level” as the object’s constructor fields. That seems reasonable, in that once all these parameters are given, the object is “fully defined”. However, we also still have</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define (node v l r)</span></p><p class="c5"><span class="c41">  ...)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">The crucial issue here is that we need to make </span><span class="c7">two</span><span class="calibre3"> objects: one of </span><span class="c28">node/size</span><span class="calibre3"> and one more of </span><span class="c28">node</span><span class="calibre3">. We could imagine a protocol where the user of </span><span class="c28">node/size</span><span class="calibre3"> constructs a </span><span class="c28">node</span><span class="calibre3"> object and passes it to </span><span class="c28">node/size</span><span class="calibre3">, but in doing so, they could make any number of mistakes. Alternatively, we can leave it to </span><span class="c28">node/size</span><span class="calibre3"> to invoke node, and keep track of the object constructed through this process. That is, </span><span class="c28">node/size</span><span class="calibre3">’s parent parameter should not be the parent </span><span class="c7">object</span><span class="calibre3"> but rather the parent object’s </span><span class="c7">maker</span><span class="c4">.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define (node/size parent-maker v l r)</span></p><p class="c5"><span class="c41">  (let ([parent-object (parent-maker v l r)]</span></p><p class="c5"><span class="c41">        [self 'dummy])</span></p><p class="c5"><span class="c41">    (begin</span></p><p class="c5"><span class="c41">      (set! self</span></p><p class="c5"><span class="c41">            (lambda (m)</span></p><p class="c5"><span class="c41">              (case m</span></p><p class="c5"><span class="c41">                [(size) (lambda () (+ 1</span></p><p class="c5"><span class="c41">                                     (msg l 'size)</span></p><p class="c5"><span class="c41">                                     (msg r 'size)))]</span></p><p class="c5"><span class="c41">                [else (parent-object m)])))</span></p><p class="c5"><span class="c41">      self)))</span></p><p class="c5"><span class="c41"> </span></p><p class="c5"><span class="c41">(define (mt/size parent-maker)</span></p><p class="c5"><span class="c41">  (let ([parent-object (parent-maker)]</span></p><p class="c5"><span class="c41">        [self 'dummy])</span></p><p class="c5"><span class="c41">    (begin</span></p><p class="c5"><span class="c41">      (set! self</span></p><p class="c5"><span class="c41">            (lambda (m)</span></p><p class="c5"><span class="c41">              (case m</span></p><p class="c5"><span class="c41">                [(size) (lambda () 0)]</span></p><p class="c5"><span class="c41">                [else (parent-object m)])))</span></p><p class="c5"><span class="c41">      self)))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Then the object constructor must remember to pass the parent-object maker on every invocation:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define a-tree/size</span></p><p class="c5"><span class="c41">  (node/size node</span></p><p class="c5"><span class="c41">             10</span></p><p class="c5"><span class="c41">             (node/size node 5 (mt/size mt) (mt/size mt))</span></p><p class="c5"><span class="c41">             (node/size node 15</span></p><p class="c5"><span class="c41">                        (node/size node 6 (mt/size mt) (mt/size mt))</span></p><p class="c5"><span class="c41">                        (mt/size mt))))</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Aside:</span><span class="calibre3"> Note the repeated pattern of invoking the “super” class: e.g., </span><span class="c28">(mt/size mt)</span><span class="calibre3">. We would instead want to do this just once. Essentially, this binding of </span><span class="c28">mt/size</span><span class="calibre3"> to </span><span class="c28">mt</span><span class="calibre3"> is precisely what the </span><span class="c28">extends</span><span class="c4"> clause of Java does. We could simulate that here, but later in this chapter we’ll see a much more elegant way of achieving this end while also making programming with classes much more flexible.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">We can confirm that both the old and new tests still work:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(test (msg a-tree/size 'sum) (+ 10 5 15 6))</span></p><p class="c5"><span class="c41">(test (msg a-tree/size 'size) 4)</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Exercise:</span><span class="c4"> Rewrite this block of code using self-application instead of mutation.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">What we have done is capture the essence of a class. Each function parameterized over a parent is...well, it’s a bit tricky, really. Let’s call it a </span><span class="c7">class extension</span><span class="c4">—we’ll soon see why. A class extension corresponds to what a Java programmer defines when they write:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">class NodeSize extends Node { ... }</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Exercise:</span><span class="c4"> So why are we going out of the way to not call it a “class”?</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">When a developer invokes a Java class’s constructor, it in effect constructs objects all the way up the inheritance chain (in practice, a compiler might optimize this to require only one constructor invocation and one object allocation). These are effectively “personal” copies of the objects corresponding to the parent classes (personal, that is, up to the presence of static members). There is, however, a question of how much of these objects is visible. Java chooses that—unlike in our implementation above—only one method of a given name (and signature) remains, no matter how many there might have been on the inheritance chain, whereas every field remains in the result, and can be accessed by casting. The latter makes some sense because each field presumably has invariants governing it, so keeping them separate (and hence all present) is wise. In contrast, it is easy to imagine an implementation that also makes all the methods available, not only the ones lowest (i.e., most refined) in the inheritance hierarchy. Many scripting languages take the latter approach.</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Exercise:</span><span class="calibre3"> The code above is not what we would </span><span class="c7">really</span><span class="calibre3"> want as programmers. The self-reference is to the same syntactic object, whereas it needs to refer to the most-refined object: this is known as open recursion. Modify the object representations so that self always refers to the most refined version of the object. </span><span class="c40">Hint:</span><span class="c4"> You will find the self-application method (Self-Reference Without Mutation) of recursion handy.</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Aside:</span><span class="calibre3"> This demonstrates the other form of extensibility we get from traditional objects: </span><span class="c7">extensible recursion</span><span class="c4">.</span></p></body></html>
