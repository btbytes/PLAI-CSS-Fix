<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.vd0ufwwlpdb0"><span class="c4">Structural Types</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">In contrast, we can imagine a different type system: one where the type of each of the above classes is not its name but rather a description of what fields and methods it has: i.e., it’s structure, or its “services”. For instance, we might have:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">mt : {size : ( -&gt; int)}</span></p><p class="c5"><span class="c41">node : {size : ( -&gt; int)}</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">That is, each of these is a collection of names (one name, to be precise), which is a method that takes no parameters and returns an </span><span class="c28">int</span><span class="c4">. Whenever two types are the same, objects of one can be used where objects of the other kind are expected. Indeed, it is unsurprising that both kinds of trees have the same type, because programs that process one will invariably also need to process the other because trees are a union of these two types. Similarly, we also have</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c28">empty : {size : ( -&gt; int)}</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">The above m method might be written as:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c28">static int m(o </span><span class="c64">: {size : (-&gt; int)}</span><span class="c41">) {</span></p><p class="c5"><span class="c41">  return o.size();</span></p><p class="c5"><span class="c41">}</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">That is, it only indicates what shape of object it expects, and doesn’t indicate which constructor should have made it. This is called </span><span class="c7">structural</span><span class="calibre3"> typing, though the Internet appears to have decided to call this “duck” typing (though it’s hard to be clear: there is no actual theory of duck typing to compare against well-defined theories of structural typing: </span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://www.springer.com/gp/book/9780387947754&amp;sa=D&amp;source=editors&amp;ust=1695232021498288&amp;usg=AOvVaw3AweVzQ_7nSMI7klfzt2li">Abadi and Cardelli</a></span><span class="calibre3"> represent a classical viewpoint, and here’s an </span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/pgk-sem-type-fc-member-name/&amp;sa=D&amp;source=editors&amp;ust=1695232021498703&amp;usg=AOvVaw2EFVs5AkPquJx2jsIUl9pQ">extension</a></span><span class="c4"> for modern “scripting” languages).</span></p></body></html>
