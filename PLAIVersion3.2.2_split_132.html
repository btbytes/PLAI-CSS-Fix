<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.go4qznyl2cip"><span class="c4">If-Splitting with Control Flow</span></h2><p class="c5"><span class="c4">This pattern, of dispatching based on type-tests and values, is quite common in dynamic (or “scripting”) languages. These languages do not have a static type system, but they do have safe run-times, which attach type tags to values and provide predicates that can check them. Programmers then adopt programming patterns that take advantage of this.</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Aside:</span><span class="calibre3"> The term </span><span class="c7">dynamic</span><span class="calibre3"> language seems to have no clear fixed definition. It means, at least, that the language doesn't have static types. Sometimes it's implicit that the language is nevertheless safe. But some people use it to mean that the language has features that let you do things like inspect or even modify the program as it's running (features like </span><span class="c28">eval</span><span class="c4">). In this book I use it in the second sense: not-statically typed, but still safe.</span></p><p class="c51"><span class="c4"></span></p><p class="c31"><span class="c40">Aside:</span><span class="c4"> What, then, is a “scripting” language? I use the term to mean a dynamic language that is also very liberal with its types: e.g., many operations are either overloaded and/or very forgiving of what a statically-typed language would consider an error. Scripting languages tend to be dynamic in all three senses: they do not have a static type-system, they are safe, and they tend to have rich features for introspection and even modification. They are designed to maximize expressiveness and thus minimize just about any useful static analysis.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">For instance, here’s an example from JavaScript, of a serialization function. A serializer takes a value of (almost) </span><span class="c7">any</span><span class="c4"> type and converts it into a string to be stored or transmitted. (This version is adapted from version 1.6.1 of Prototype.js.)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3"></span><span class="c41">function serialize(val) {</span></p><p class="c5"><span class="c41">  switch (typeof val) {</span></p><p class="c5"><span class="c41">    case "undefined":</span></p><p class="c5"><span class="c41">    case "function": </span></p><p class="c5"><span class="c41">      return false;</span></p><p class="c5"><span class="c41">    case "boolean":</span></p><p class="c5"><span class="c41">      return val ? "true" :</span></p><p class="c5"><span class="c41">                   "false";</span></p><p class="c5"><span class="c41">    case "number":</span></p><p class="c5"><span class="c41">      return "" + val;</span></p><p class="c5"><span class="c41">    case "string":</span></p><p class="c5"><span class="c41">      return val;</span></p><p class="c5"><span class="c41">  }</span></p><p class="c5"><span class="c41">  if (val === null)</span></p><p class="c5"><span class="c41">    { return "null"; } </span></p><p class="c5"><span class="c41">  </span></p><p class="c5"><span class="c41">  var fields = [ ];</span></p><p class="c5"><span class="c41">  for (var p in val) {</span></p><p class="c5"><span class="c41">    var v = serialize(val[p]);</span></p><p class="c5"><span class="c41">    if (typeof v === "string") {</span></p><p class="c5"><span class="c41">      fields.push(p + ": " + v);</span></p><p class="c5"><span class="c41">    }</span></p><p class="c5"><span class="c41">  }</span></p><p class="c5"><span class="c41">  return "{ " + </span></p><p class="c5"><span class="c41">         fields.join(", ") + </span></p><p class="c5"><span class="c41">         " }";</span></p><p class="c5"><span class="c41">}</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Now suppose we’re trying to retrofit a type system onto JavaScript. We would need to type-check such programs. But before we even ask </span><span class="c7">how</span><span class="c4"> to do it, we should know what answer to expect: i.e., is this program even type-safe?</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">The answer is quite subtle. It uses JavaScript’s </span><span class="c28">typeof</span><span class="calibre3"> operator to check the tags. For two kinds of values, it returns </span><span class="c28">false</span><span class="calibre3"> (that is, the type of this function is not </span><span class="c28">Any -&gt; String</span><span class="calibre3">, it’s actually </span><span class="c28">Any -&gt; (String U Boolean)</span><span class="calibre3">, where the </span><span class="c28">false</span><span class="calibre3"> value is used to signal that the value can’t be serialized—observe that an actual </span><span class="c28">false</span><span class="calibre3"> value is serialized to </span><span class="c28">"false"</span><span class="calibre3">). For Booleans, numbers, and strings, it translates them appropriately into strings. In all these cases, execution returns. (Note, however, that the code also exploits JavaScript’s “fall-through” behavior in </span><span class="c28">switch</span><span class="calibre3">, so that </span><span class="c28">"undefined"</span><span class="calibre3"> and </span><span class="c28">"function"</span><span class="c4"> are treated the same without having to repeat code. The type-checker needs to understand this part of JavaScript semantics.)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">If none of these cases apply, then execution falls through; we need to know enough JavaScript to know that this corresponds to the one other return from </span><span class="c28">typeof</span><span class="calibre3">, namely objects. Now the code splits between objects that are and aren’t </span><span class="c28">null</span><span class="calibre3">. In the non-</span><span class="c28">null</span><span class="c4"> case, it iterates through each field, serializing it in turn. Therefore, this program is actually type-safe…but for very complicated reasons!</span></p></body></html>
