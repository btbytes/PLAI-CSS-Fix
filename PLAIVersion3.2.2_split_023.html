<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.onkmgsjzun3m"><span class="c4">Some Subtler Tests</span></h2><p class="c5"><span class="c4">Try the following test:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(test (calc (plus (num 0.1) (num 0.2))) 0.3)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">It succeeds! Are we happy? Suppose we instead write it as:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(test (calc (plus (num 0.1) (num 0.2))) 1/3)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">As expected, it fails: but the error message reveals that the left-hand side evaluated to 0.30000000000000004. This should be a cue that we have actually gotten </span><span class="c26"><a class="c11" href="https://www.google.com/url?q=https://0.30000000000000004.com/&amp;sa=D&amp;source=editors&amp;ust=1695232021117958&amp;usg=AOvVaw3K_UT0jvSMRzJJKE3HmGaN">floating point</a></span><span class="calibre3"> addition. This is because plait treats numbers written with a decimal point, like </span><span class="c28">0.1</span><span class="calibre3">, as </span><span class="c7">floating point</span><span class="calibre3"> bitstrings. However, floating point bitstrings cannot precisely represent the number 0.3. In fact, plait’s </span><span class="c28">test</span><span class="calibre3"> allows a little bit of numeric slack so that the passing test above works. (This is because in plait, </span><span class="c28">0.3</span><span class="c4"> really does precisely represent the number 0.3, because it was written literally and not the result of a floating-point computation.)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">This reinforces a point we made in passing above and was therefore easy to miss: by adopting plait’s primitives, we have also inherited its semantics. This may or may not be what we wanted! Therefore, when writing an evaluator using a host language, we have to make sure that its semantics are the one we want, otherwise we could be in for an unpleasant surprise. If we want different behavior, we have to implement it explicitly.</span></p></body></html>
