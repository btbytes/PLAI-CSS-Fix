<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h1 class="c22" id="h.bheym24u3ntv"><span class="c4">Type Inference</span></h1><h2 class="c23" id="h.bq0i6plsiwy6"><span class="c4">Unannotated Programs and Types</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Consider the following plait program:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(lambda (x y)</span></p><p class="c5"><span class="c41">Â  (if x</span></p><p class="c5"><span class="c41">Â  Â  Â  (+ y 1)</span></p><p class="c5"><span class="c41">Â  Â  Â  (+ y 2)))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">If we enter this program into plait, e.g., as follows, something remarkable happens:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">&gt; (lambda (x y)</span></p><p class="c5"><span class="c41">Â  Â  (if x</span></p><p class="c5"><span class="c41">Â  Â  Â  Â  (+ y 1)</span></p><p class="c5"><span class="c41">Â  Â  Â  Â  (+ y 2)))</span></p><p class="c5"><span class="c41">- (Boolean Number -&gt; Number)</span></p><p class="c5"><span class="c41">#&lt;procedure&gt;</span></p><p class="c5"><span class="c4">Â </span></p><p class="c5"><span class="calibre3">In response, plait </span><span class="c7">figures out</span><span class="calibre3">Â the type of this function </span><span class="c7">without</span><span class="calibre3">Â our having to provide any annotations. This is in contrast to the type-checker we just wrote [</span><span class="c16"><a class="c11" href="PLAIVersion3.2.2_split_098.html#h.1hrl1xnfptjg">ğŸ‘‰</a></span><span class="calibre3">], </span><span class="c4">which required us to extend the syntax just to provide (required) type annotations. That tells us that something differentâ€”and moreâ€”must be happening under plait. In contrast, consider another example:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(lambda (x)</span></p><p class="c5"><span class="c41">Â  Â  (if x</span></p><p class="c5"><span class="c41">Â  Â  Â  Â  (+ x 1)</span></p><p class="c5"><span class="c41">Â  Â  Â  Â  (+ x 2)))</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="calibre3">This produces an error, observing that we are using </span><span class="c28">x</span><span class="calibre3">Â both in a position that requires it to be a Boolean (in </span><span class="c28">if</span><span class="c4">) and a number (in the two additions). Again, plait has figured this out without our having to write any annotations at all!</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">The algorithm that sits underneath plait is essentially the same algorithm under OCaml, Haskell, and several other programming languages. These languages provide </span><span class="c7">type inference</span><span class="c4">: figuring out (inferring) types automatically from the program source. Now weâ€™re going to see how this works.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">The key idea is to break this seemingly very complex problem into two rather simple parts. In the first, we recursively visit each sub-expression of the program (following SImPl) and generate a set of </span><span class="c7">constraints</span><span class="calibre3">Â that formally do what weâ€™ve been doing informally above. The second phase </span><span class="c7">solves</span><span class="calibre3">Â this set of constraints, using a process that is a generalization of the process you used for solving â€œsystems of simultaneous equationsâ€ in school. The solution is a </span><span class="c7">type</span><span class="c4">Â for each variable. That lets us fill in the annotations that the programmer left blank. </span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">The process of generation will also have applied the type constraints, so there will be no further need to type-check the program; but we can use the annotations, for instance, in an IDE for tool-tips, in a compiler for optimization, etc. That is, with inference, we can program as if weâ€™re in a â€œscriptyâ€ language without annotations, yet achieve most of the benefits of types. (I say â€œmostâ€ because one of the benefits is documentation; leaving off all annotations makes programs harder to read and understand. For that reason, inference should be used sparingly.)</span></p></body></html>
