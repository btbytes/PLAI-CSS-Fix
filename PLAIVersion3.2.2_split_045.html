<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.n6eymaq2d8zz"><span class="c4">Extending the Representation</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Therefore, let’s think about what it takes to evaluate functions-as-values to SMoL. We don’t need functions to inherently have a name, because naming can be done by </span><span class="c28">let1</span><span class="c4">.  We’ll assume, for simplicity, that all functions take only one argument; extending this to multiple arguments is left as an exercise.</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Exercise:</span><span class="c4"> What issues might we have to deal with when we extend functions from having one argument only to having multiple arguments?</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">First, we need to extend our abstract syntax.</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Do Now:</span><span class="c4"> How many new constructs do we need to add to the abstract syntax?</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">When we added </span><span class="c28">let1</span><span class="calibre3">, you may recall that it didn’t suffice to add one construct; we needed two: one for variable </span><span class="c7">binding</span><span class="calibre3"> and one for variable </span><span class="c7">use</span><span class="calibre3">. You’ll often see this pattern when adding values to the language. For any new kind of value,  you can expect to see one or more ways to </span><span class="c7">make</span><span class="calibre3"> it and one or more ways to </span><span class="c7">use</span><span class="c4"> it. (Even arithmetic: numeric constants were a way to make them, arithmetic operations consumed them—but also made them.)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Likewise with functions, we need a way to represent both</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">lam(x): x * x</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">for defining new functions, and</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">sq(3)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">to use them.</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Terminology:</span><span class="calibre3"> In more advanced texts, you will sometimes see the (formally correct, but perhaps slightly confusing) terms </span><span class="c7">introduction</span><span class="calibre3"> and </span><span class="c7">elimination</span><span class="calibre3">: introduction brings the new concept in, elimination uses them. Thus, the </span><span class="c28">lam</span><span class="c4"> introduces new functions, and an application eliminates them.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">We therefore add</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">  [lamE (var : Symbol) (body : Exp)]</span></p><p class="c5"><span class="c28">  [appE (fun : Exp) (arg : Exp)]</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">to our AST.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Let’s assume we’ve already extended our parser, so that programs like the following are legal:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">{let1 {f {lam x {+ x x}}}</span></p><p class="c5"><span class="c41">      {f 3}}</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">{let1 {x 3}</span></p><p class="c5"><span class="c41">      {let1 {f {lam y {+ x y}}}</span></p><p class="c5"><span class="c41">            {f 3}}}</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">These parse, respectively, into</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(let1E 'f (lamE 'x (plusE (varE 'x) (varE 'x))) </span></p><p class="c5"><span class="c41">       (appE (varE 'f) (numE 3)))</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">(let1E 'x (numE 3) </span></p><p class="c5"><span class="c41">       (let1E 'f (lamE 'y (plusE (varE 'x) (varE 'y))) </span></p><p class="c5"><span class="c41">              (appE (varE 'f) (numE 3))))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">and should both evaluate to </span><span class="c28">6</span><span class="c4">.</span></p></body></html>
