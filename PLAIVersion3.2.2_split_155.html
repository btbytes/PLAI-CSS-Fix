<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.87bogdfxe1hf"><span class="c4">Laziness Via Closures: Beyond Numbers</span></h2><p class="c5"><span class="calibre3">Laziness becomes more interesting when we consider data structures. Conventionally, data constructors are </span><span class="c7">not</span><span class="calibre3"> strict, so their arguments are not evaluated eagerly. We can illustrate this using lists, though technically we will be constructing </span><span class="c7">streams</span><span class="c4"> (which are infinite, as opposed to lists, which are finite).</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">First, read about streams represented using closures:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://dcic-world.org/2022-08-28/func-as-data.html%23%2528part._streams-from-funs%2529&amp;sa=D&amp;source=editors&amp;ust=1695232021577933&amp;usg=AOvVaw3xFcgFEVIzH5OuDVgtWddP">https://dcic-world.org/2022-08-28/func-as-data.html#%28part._streams-from-funs%29</a></span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">What would the same code look like in a language that was already lazy?</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">To experiment with that, we’ll now use the Racket language</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c28">#lang lazy</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define ones (cons 1 ones))</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">(define (nats-from n)</span></p><p class="c5"><span class="c41">  (cons n (nats-from (add1 n))))</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">(define nats (nats-from 0))</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">(define (take n s)</span></p><p class="c5"><span class="c41">  (if (zero? n)</span></p><p class="c5"><span class="c41">      empty</span></p><p class="c5"><span class="c41">      (cons (first s) (take (sub1 n) (rest s)))))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Observe how some of these values print:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">&gt; ones</span></p><p class="c5"><span class="c41">#&lt;promise:ones&gt;</span></p><p class="c5"><span class="c41">&gt; nats</span></p><p class="c5"><span class="c41">#&lt;promise:nats&gt;</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">The word “promise” means these are </span><span class="c7">thunks</span><span class="calibre3"> that represent the stream. To view the thunk’s content, we need to “force” the “promise”, which we do using the </span><span class="c28">!</span><span class="c4"> operator:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">&gt; (! ones)</span></p><p class="c5"><span class="c41">#0='(1 . #&lt;promise!#0#&gt;)</span></p><p class="c5"><span class="c41">&gt; (! nats)</span></p><p class="c5"><span class="c41">'(0 . #&lt;promise:...e/pkgs/lazy/base.rkt:299:29&gt;)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">In the case of </span><span class="c28">ones</span><span class="calibre3">, Racket is telling us that the rest of the stream is the </span><span class="c7">same</span><span class="calibre3"> stream as the one we are viewing: i.e., it’s a cyclic stream. For </span><span class="c28">nats</span><span class="calibre3">, it tells us that the first element is </span><span class="c28">0</span><span class="c4">, followed by another promise. We can explore these streams a bit further:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">&gt; (! (rest ones))</span></p><p class="c5"><span class="c41">#0='(1 . #&lt;promise!#0#&gt;)</span></p><p class="c5"><span class="c41">&gt; (! (rest (rest (rest ones))))</span></p><p class="c5"><span class="c41">#0='(1 . #&lt;promise!#0#&gt;)</span></p><p class="c5"><span class="c41">&gt; (! (rest nats))</span></p><p class="c5"><span class="c41">'(#&lt;promise:...e/pkgs/lazy/base.rkt:299:29&gt; . #&lt;promise:...e/pkgs/lazy/base.rkt:299:29&gt;)</span></p><p class="c5"><span class="c41">&gt; (! (rest (rest (rest nats))))</span></p><p class="c5"><span class="c41">'(#&lt;promise:...e/pkgs/lazy/base.rkt:299:29&gt; . #&lt;promise:...e/pkgs/lazy/base.rkt:299:29&gt;)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Unsurprisingly, </span><span class="c28">ones</span><span class="calibre3"> does not change. But with </span><span class="c28">nats</span><span class="calibre3">, as we explore more of the stream, we run into more thunks. This is where </span><span class="c28">take</span><span class="calibre3"> is useful: it gives us a finite prefix of the potentially infinite stream. Unfortunately, that also seems to just produce more thunks, and it seems like we would need to laboriously apply </span><span class="c28">!</span><span class="c4"> to each part:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">&gt; (take 10 ones)</span></p><p class="c5"><span class="c41">'(#&lt;promise:...e/pkgs/lazy/base.rkt:299:29&gt; . #&lt;promise:...e/pkgs/lazy/base.rkt:299:29&gt;)</span></p><p class="c5"><span class="c41">&gt; (take 10 nats)</span></p><p class="c5"><span class="c41">'(#&lt;promise:...e/pkgs/lazy/base.rkt:299:29&gt; . #&lt;promise:...e/pkgs/lazy/base.rkt:299:29&gt;)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">For situations like this, where we </span><span class="c7">know</span><span class="calibre3"> the output is going to be finite, we might want to resolve all the thunks. For this, Lazy Racket provides </span><span class="c28">!!</span><span class="c4">, which recursively applies strictness to all contained thunks:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">&gt; (!! (take 10 ones))</span></p><p class="c5"><span class="c41">'(1 1 1 1 1 1 1 1 1 1)</span></p><p class="c5"><span class="c41">&gt; (!! (take 10 nats))</span></p><p class="c5"><span class="c41">'(0 1 2 3 4 5 6 7 8 9)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Sure enough, we get the expected answer.</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Exercise:</span><span class="calibre3"> What happens if we apply </span><span class="c28">!!</span><span class="calibre3"> to </span><span class="c28">ones</span><span class="calibre3"> and to </span><span class="c28">nats</span><span class="c4">? Try it out, and explain what you see.</span></p></body></html>
