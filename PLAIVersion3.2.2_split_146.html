<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h1 class="c22" id="h.19zaqlbd627k"><span class="c4">Relations</span></h1><h2 class="c23" id="h.q48qr189ipzq"><span class="c4">A Language Genealogy</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Suppose we want to record a genealogy of programming languages and determine which languages obtained ideas from which ones. We start by recording which languages directly borrowed ideas from which ones: e.g., Java directly borrowed from C++, and C++ directly borrowed from C. From that, we can also trace the descendants down a chain of borrowing.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">We will write some of these in the following, maybe peculiar, syntax:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">borrows(A, B)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">means that the language </span><span class="c28">A</span><span class="calibre3"> borrows from the language </span><span class="c28">B</span><span class="calibre3"> (i.e., </span><span class="c28">A</span><span class="calibre3"> is newer, </span><span class="c28">B</span><span class="calibre3"> is older). For another peculiar reason, we will write constants not as quotes but as alphanumeric strings with a </span><span class="c7">lower-case initial</span><span class="calibre3">. Given that, here are some facts (with </span><span class="c28">cpp</span><span class="c4"> standing for C++):</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">borrows(java, cpp).</span></p><p class="c5"><span class="c41">borrows(cpp, c).</span></p><p class="c5"><span class="c41">borrows(c, bcpl).</span></p><p class="c5"><span class="c41">borrows(pascal, algol).</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Now we can express the notion of being a descendant: there are two ways that </span><span class="c28">A</span><span class="calibre3"> can be a descendant of </span><span class="c28">B</span><span class="calibre3">. One is if </span><span class="c28">A</span><span class="calibre3"> borrows directly from </span><span class="c28">B</span><span class="calibre3">. The other is if it borrows from some language </span><span class="c28">Z</span><span class="calibre3"> that is itself a descendant of </span><span class="c28">B</span><span class="c4">. We express these two rules using this syntax:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">descends(A, B) :- borrows(A, B).</span></p><p class="c5"><span class="c41">descends(A, B) :- borrows(A, Z), descends(Z, B).</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Congratulations, you’ve just written your first </span><span class="c40">Prolog</span><span class="calibre3"> program. To see this run, you can use </span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://swish.swi-prolog.org/&amp;sa=D&amp;source=editors&amp;ust=1695232021521364&amp;usg=AOvVaw3htfQEX93FhT5bpRmnE6re">SWI Prolog online</a></span><span class="c4">. But what does it mean to “run” this? Prolog answers questions: we can ask several questions like:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c7">Does </span><span class="c28">cpp</span><span class="c7"> borrow from </span><span class="c28">c</span><span class="c7">?</span></p><p class="c5"><span class="c41">borrows(cpp, c).</span></p><p class="c5"><span class="c4">→ true</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c7">Does </span><span class="c28">cpp</span><span class="c7"> borrow from </span><span class="c28">bcpl</span><span class="c32">?</span></p><p class="c5"><span class="c41">borrows(cpp, bcpl).</span></p><p class="c5"><span class="c4">→ false</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">That is, we can see that Prolog is acting like a basic database. But we can do more:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c7">Does </span><span class="c28">cpp</span><span class="c7"> descend from </span><span class="c28">bcpl</span><span class="c32">?</span></p><p class="c5"><span class="c41">descends(cpp, bcpl).</span></p><p class="c5"><span class="c4">→ true</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c7">Does </span><span class="c28">bcpl</span><span class="c7"> descend from </span><span class="c28">cpp</span><span class="c32">?</span></p><p class="c5"><span class="c41">descends(bcpl, cpp).</span></p><p class="c5"><span class="c4">→ false</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Aha: so Prolog will not only query basic facts, it will also process queries through rules.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">But we can actually ask Prolog more sophisticated questions that look more like function applications. Consider:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c7">What does </span><span class="c28">cpp</span><span class="c7"> borrow from?</span></p><p class="c5"><span class="c4">borrows(cpp, X).</span></p><p class="c5"><span class="c4">→ </span></p><p class="c5"><span class="c117">X</span><span class="c118"> = </span><span class="c119">c</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">This seems to treat borrows like a rather funny function, calling it with a </span><span class="c7">variable</span><span class="c4"> (a name that begins with a capital letter) and letting Prolog fill in the variable. Does that work only for basic definitions, or also for rules?</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c7">What does </span><span class="c28">cpp</span><span class="c7"> descend from?</span></p><p class="c5"><span class="c4">descends(cpp, X).</span></p><p class="c5"><span class="c4">→ </span></p><p class="c120"><span class="c117">X</span><span class="c121"> = </span><span class="c122">c</span></p><p class="c123"><span class="c117">X</span><span class="c121"> = </span><span class="c122">bcpl</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Oh, this is interesting! Prolog didn’t return just one answer; it returned </span><span class="c7">all</span><span class="calibre3"> the answers. And this was done by using a </span><span class="c7">variable</span><span class="calibre3"> (a name that begins with a </span><span class="c7">capital letter</span><span class="c4">). This naturally suggests the question, what if we did it the other way around?</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c7">What descends from </span><span class="c28">cpp</span><span class="c4">?</span></p><p class="c5"><span class="c4">descends(X, cpp).</span></p><p class="c5"><span class="c4">→ </span></p><p class="c5"><span class="c117">X</span><span class="c118"> = </span><span class="c119">java</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">This is even stranger: it’s like passing a variable as an argument and asking what inputs will produce a particular result from the function!</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">In fact, a function is just the wrong way to think about any of this. What is happening in Prolog is that we’re defining </span><span class="c7">relations</span><span class="c4">. So borrows and descends are actually relations, where one (borrows) is defined by concrete examples and the other (descends) by abstract rules.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Once we understand these are relations, we no longer need to limit ourselves to just one source of borrowing, to better reflect reality. That is, let’s say this is our set of facts:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">borrows(java, cpp).</span></p><p class="c5"><span class="c41">borrows(cpp, c).</span></p><p class="c5"><span class="c41">borrows(cpp, simula).</span></p><p class="c5"><span class="c41">borrows(smalltalk, simula).</span></p><p class="c5"><span class="c41">borrows(self, smalltalk).</span></p><p class="c5"><span class="c41">borrows(c, bcpl).</span></p><p class="c5"><span class="c41">borrows(pascal, algol).</span></p><p class="c5"><span class="c41">borrows(scheme, algol).</span></p><p class="c5"><span class="c41">borrows(scheme, lisp).</span></p><p class="c5"><span class="c41">borrows(javascript, self).</span></p><p class="c5"><span class="c41">borrows(javascript, scheme).</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Now we can ask what all languages contributed to JavaScript:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">descends(javascript, X).</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">From this set of facts, we learn:</span></p><p class="c3"><span class="c4"></span></p><p class="c120"><span class="c117">X</span><span class="c121"> = </span><span class="c122">self</span></p><p class="c123"><span class="c117">X</span><span class="c121"> = </span><span class="c122">scheme</span></p><p class="c120"><span class="c117">X</span><span class="c121"> = </span><span class="c122">smalltalk</span></p><p class="c123"><span class="c117">X</span><span class="c121"> = </span><span class="c122">simula</span></p><p class="c120"><span class="c117">X</span><span class="c121"> = </span><span class="c122">algol</span></p><p class="c123"><span class="c117">X</span><span class="c121"> = </span><span class="c122">lisp</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Similarly, we can ask how widely Lisp’s influence spread:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">descends(X, lisp).</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">And we learn that for this very limited set of languages:</span></p><p class="c3"><span class="c4"></span></p><p class="c120"><span class="c117">X</span><span class="c121"> = </span><span class="c122">scheme</span></p><p class="c123"><span class="c117">X</span><span class="c121"> = </span><span class="c122">javascript</span></p><p class="c3"><span class="c4"></span></p></body></html>
