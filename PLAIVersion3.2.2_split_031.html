<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.ssjni4nvzyaf"><span class="c4">The Design Space of Conditionals</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Even the simplest conditional exposes us to many variations in language design. The intent is that test-expression is evaluated first; if it results in a true value then (only) the then-expression is evaluated, else (only) the else-expression is evaluated. (We usually refer to these two parts as </span><span class="c7">branches</span><span class="c4">, since the program‚Äôs control must take one or the other.) However, even this simple construct results in at least three different, mostly independent design decisions:</span></p><p class="c3"><span class="c4"></span></p><ol class="c55" start="1"><li class="c56 pcalibre6"><span class="calibre3">What kind of values can the test-expression be? In some languages they must be Boolean values (two values, one representing truth and the other falsehood). In other languages this expression can evaluate to just about any value, with some set‚Äîcolloquially called </span><span class="c7">truthy</span><span class="calibre3">‚Äîrepresenting truth (i.e., they result in execution of the then-expression) while the remaining ones are </span><span class="c7">falsy</span><span class="c4">, meaning they cause the else-expression to run.<br class="calibre"/><br class="calibre"/>Initially, it may seem attractive to design a language with several truthy and falsy values: after all, this appears to give the programmer more convenience, permitting non-Boolean-valued functions and expressions to be used in conditionals. However, this can lead to bewildering inconsistencies across languages:<br class="calibre"/><br class="calibre"/></span></li></ol><a id="t.d486c636a3399b3f302d98342efd8befb9269a4b"></a><a id="t.1"></a><table class="c57"><tbody class="calibre14"><tr class="c46"><td class="c58" colspan="1" rowspan="1"><p class="c48"><span class="c49">Value</span></p></td><td class="c58" colspan="1" rowspan="1"><p class="c48"><span class="c49">JavaScript</span></p></td><td class="c58" colspan="1" rowspan="1"><p class="c48"><span class="c49">Perl</span></p></td><td class="c58" colspan="1" rowspan="1"><p class="c48"><span class="c49">PHP</span></p></td><td class="c58" colspan="1" rowspan="1"><p class="c48"><span class="c49">Python</span></p></td><td class="c58" colspan="1" rowspan="1"><p class="c48"><span class="c49">Ruby</span></p></td></tr><tr class="c46"><td class="c58" colspan="1" rowspan="1"><p class="c50"><span class="c41">-1</span></p></td><td class="c58" colspan="1" rowspan="1"><p class="c48"><span class="c4">truthy</span></p></td><td class="c58" colspan="1" rowspan="1"><p class="c48"><span class="c4">truthy</span></p></td><td class="c58" colspan="1" rowspan="1"><p class="c48"><span class="c4">truthy</span></p></td><td class="c58" colspan="1" rowspan="1"><p class="c48"><span class="c4">truthy</span></p></td><td class="c58" colspan="1" rowspan="1"><p class="c48"><span class="c4">truthy</span></p></td></tr><tr class="c46"><td class="c58" colspan="1" rowspan="1"><p class="c50"><span class="c41">0</span></p></td><td class="c58" colspan="1" rowspan="1"><p class="c48"><span class="c4">falsy</span></p></td><td class="c58" colspan="1" rowspan="1"><p class="c48"><span class="c4">falsy</span></p></td><td class="c58" colspan="1" rowspan="1"><p class="c48"><span class="c4">falsy</span></p></td><td class="c58" colspan="1" rowspan="1"><p class="c48"><span class="c4">falsy</span></p></td><td class="c58" colspan="1" rowspan="1"><p class="c48"><span class="c4">truthy</span></p></td></tr><tr class="c46"><td class="c58" colspan="1" rowspan="1"><p class="c50"><span class="c41">""</span></p></td><td class="c58" colspan="1" rowspan="1"><p class="c48"><span class="c4">falsy</span></p></td><td class="c58" colspan="1" rowspan="1"><p class="c48"><span class="c4">falsy</span></p></td><td class="c58" colspan="1" rowspan="1"><p class="c48"><span class="c4">falsy</span></p></td><td class="c58" colspan="1" rowspan="1"><p class="c48"><span class="c4">falsy</span></p></td><td class="c58" colspan="1" rowspan="1"><p class="c48"><span class="c4">truthy</span></p></td></tr><tr class="c46"><td class="c58" colspan="1" rowspan="1"><p class="c50"><span class="c41">"0"</span></p></td><td class="c58" colspan="1" rowspan="1"><p class="c48"><span class="c4">truthy</span></p></td><td class="c58" colspan="1" rowspan="1"><p class="c48"><span class="c4">falsy</span></p></td><td class="c58" colspan="1" rowspan="1"><p class="c48"><span class="c4">falsy</span></p></td><td class="c58" colspan="1" rowspan="1"><p class="c48"><span class="c4">truthy</span></p></td><td class="c58" colspan="1" rowspan="1"><p class="c48"><span class="c4">truthy</span></p></td></tr><tr class="c46"><td class="c58" colspan="1" rowspan="1"><p class="c50"><span class="c41">NaN</span></p></td><td class="c58" colspan="1" rowspan="1"><p class="c48"><span class="c4">falsy</span></p></td><td class="c58" colspan="1" rowspan="1"><p class="c48"><span class="c4">truthy</span></p></td><td class="c58" colspan="1" rowspan="1"><p class="c48"><span class="c4">truthy</span></p></td><td class="c58" colspan="1" rowspan="1"><p class="c48"><span class="c4">truthy</span></p></td><td class="c58" colspan="1" rowspan="1"><p class="c48"><span class="c4">truthy</span></p></td></tr><tr class="c46"><td class="c58" colspan="1" rowspan="1"><p class="c50"><span class="c28">nil</span><span class="calibre3">, </span><span class="c28">null</span><span class="calibre3">, </span><span class="c28">None</span><span class="c4">, undefined</span></p></td><td class="c58" colspan="1" rowspan="1"><p class="c48"><span class="c4">falsy</span></p></td><td class="c58" colspan="1" rowspan="1"><p class="c48"><span class="c4">falsy</span></p></td><td class="c58" colspan="1" rowspan="1"><p class="c48"><span class="c4">falsy</span></p></td><td class="c58" colspan="1" rowspan="1"><p class="c48"><span class="c4">falsy</span></p></td><td class="c58" colspan="1" rowspan="1"><p class="c48"><span class="c4">falsy</span></p></td></tr><tr class="c46"><td class="c58" colspan="1" rowspan="1"><p class="c50"><span class="c41">[]</span></p></td><td class="c58" colspan="1" rowspan="1"><p class="c48"><span class="c4">truthy</span></p></td><td class="c58" colspan="1" rowspan="1"><p class="c48"><span class="c4">truthy</span></p></td><td class="c58" colspan="1" rowspan="1"><p class="c48"><span class="c4">falsy</span></p></td><td class="c58" colspan="1" rowspan="1"><p class="c48"><span class="c4">falsy</span></p></td><td class="c58" colspan="1" rowspan="1"><p class="c48"><span class="c4">truthy</span></p></td></tr><tr class="c46"><td class="c58" colspan="1" rowspan="1"><p class="c50"><span class="c4">empty map or object</span></p></td><td class="c58" colspan="1" rowspan="1"><p class="c48"><span class="c4">truthy</span></p></td><td class="c58" colspan="1" rowspan="1"><p class="c48"><span class="c4">falsy</span></p></td><td class="c58" colspan="1" rowspan="1"><p class="c48"><span class="c4">falsy</span></p></td><td class="c58" colspan="1" rowspan="1"><p class="c48"><span class="c4">falsy</span></p></td><td class="c58" colspan="1" rowspan="1"><p class="c48"><span class="c4">truthy</span></p></td></tr></tbody></table><p class="c31"><span class="calibre3"><br class="calibre"/>Of course, it need not be so complex. Scheme, for instance, has only one value that is falsy: false itself (written as </span><span class="c28">#false</span><span class="calibre3">). </span><span class="c7">Every</span><span class="c4">¬†other value is truthy. For those who value allowing non-Boolean values in conditionals, this represents an elegant trade-off: it means a function need not worry that a type-consistent value resulting from a computation might cause a conditional to reverse itself. (For instance, if a function returns strings, it need not worry that the empty string might be treated differently from every other string.) Note that Ruby, which is inspired in part by Scheme, adopted this simple model. Lua, another Scheme-inspired language, is also spartan in its falsy values.<br class="calibre"/></span></p><ol class="c24" start="2"><li class="c56 pcalibre6"><span class="calibre3">What kind of terms are the branches? Some languages make a distinction between </span><span class="c7">statements</span><span class="calibre3">¬†and </span><span class="c7">expressions</span><span class="calibre3">; in such languages, designers need to decide which of these are permitted. In some languages, there are even two syntactic forms of conditional to reflect these two choices: e.g., in C, </span><span class="c28">if</span><span class="calibre3">¬†uses statements (and does not return any value) while the ‚Äúternary operator‚Äù (</span><span class="c28">(...?...:...)</span><span class="c4">) permits expressions and returns a value.<br class="calibre"/></span></li><li class="c56 pcalibre6"><span class="calibre3">If the branches are expressions and hence allowed to evaluate to values, how do the values relate? Many (but not all) languages with static type systems expect the two branches to have the same type [</span><span class="c16"><a class="c11" href="PLAIVersion3.2.2_split_096.html#h.d70s6cjh8dnk">üëâ</a></span><span class="c4">]. Languages without static type systems usually place no restrictions.</span></li></ol><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Aside: </span><span class="calibre3">While writing an earlier version of this very chapter, I stumbled on a strange bug in the Pyret programming language: all numeric s-expressions parsed as </span><span class="c28">s-num</span><span class="calibre3">¬†values except </span><span class="c28">0</span><span class="calibre3">, which parsed as a </span><span class="c28">s-sym</span><span class="calibre3">. Eventually Justin Pombrio reported: ‚ÄúIt‚Äôs a silly bug with an </span><span class="c28">if</span><span class="calibre3">¬†in JavaScript that‚Äôs getting </span><span class="c28">0</span><span class="c4">¬†and thinking it‚Äôs false.‚Äù Seems fitting.</span></p></body></html>
