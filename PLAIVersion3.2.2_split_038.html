<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.8rn12mh2ovcl"><span class="c4">A Syntax for Local Binding</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Part of the problem is actually syntactic. When we write a program like the above, there’s no clear beginning or ending of the scope of </span><span class="c28">y</span><span class="calibre3"> (i.e., the region where </span><span class="c28">y</span><span class="calibre3"> is bound). This is actually a great virtue of parenthetical syntax: it </span><span class="c7">suggests</span><span class="calibre3"> a clear region (between the parentheses). Of course, we have a responsibility to make sure that that’s where the variable </span><span class="c7">is</span><span class="c4"> actually bound (though this is something that we’ll find, in a little while, is not so trivial).</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Following the syntax of Racket, we’ll add a new construct to our language. At this point it’s getting a bit tricky to keep track of the full syntax, so we’ll use a notation called BNF (short for Backus-Naur Form). Let’s start with our arithmetic language:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">&lt;expr&gt; ::= &lt;num&gt;</span></p><p class="c5"><span class="c41">         | {+ &lt;expr&gt; &lt;expr&gt;}</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="calibre3">which reads as “define (</span><span class="c28">::=</span><span class="calibre3">) </span><span class="c28">expr</span><span class="calibre3"> (short for expression) to be either a number or (</span><span class="c28">|</span><span class="calibre3">) the surface syntax consisting of an opening brace (</span><span class="c28">{</span><span class="calibre3">), a plus sign (</span><span class="c28">+</span><span class="calibre3">), an </span><span class="c28">expr</span><span class="calibre3">, another </span><span class="c28">expr</span><span class="calibre3">, and a closing brace”. BNF gives us a convenient notation for the </span><span class="c7">grammar</span><span class="calibre3"> of a language through its concrete syntax, and our abstract syntax will usually correspond very directly to the BNF in a very natural manner. (Observe, however, that in the BNF, we simply say that each sub-expression is an </span><span class="c28">expr</span><span class="c4">, because that’s all we need to know to properly form programs. However, in the AST, we give the parts different names to tell them apart.)</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Notation:</span><span class="calibre3"> BNF is divided into </span><span class="c7">terminals</span><span class="calibre3"> and </span><span class="c7">non-terminals</span><span class="calibre3">. Non-terminals are placeholders like </span><span class="c28">expr</span><span class="calibre3"> and </span><span class="c28">num</span><span class="calibre3"> above: they stand for many more possibilities (an </span><span class="c28">expr</span><span class="calibre3"> above can be replaced with one of two possibilities (for now), while there are many possible ways to write </span><span class="c28">num</span><span class="c4">s). They are given this name because the grammar doesn’t “terminate” here: the name is a place-holder that can (and must) be further expanded. </span></p><p class="c51"><span class="c4"></span></p><p class="c31"><span class="calibre3">The convention is to write non-terminals inside </span><span class="c28">&lt;</span><span class="calibre3">pointy brackets</span><span class="c28">&gt;</span><span class="calibre3">. Terminals, in contrast, are concrete syntax, like </span><span class="c28">{</span><span class="calibre3">, </span><span class="c28">}</span><span class="calibre3">, and </span><span class="c28">+</span><span class="calibre3"> above. They are so-called because they stand for themselves and can’t be expanded further. They are sometimes also called </span><span class="c7">literals</span><span class="c4">, because they must be written literally as shown. For this reason, they are not surrounded by any decorative symbols. Everything is written literally unless it’s a non-terminal, in which case it’s replaced by something according to the definition of the non-terminal.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Now we can define an extended language:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">&lt;expr&gt; ::= &lt;num&gt;</span></p><p class="c5"><span class="c41">         | {+ &lt;expr&gt; &lt;expr&gt;}</span></p><p class="c5"><span class="c41">         | {let1 {&lt;var&gt; &lt;expr&gt;} &lt;expr&gt;}</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="calibre3">That is, we’re adding a new language construct, </span><span class="c28">let1</span><span class="calibre3">, which has three parts: a variable (</span><span class="c28">var</span><span class="calibre3">) and two expressions (the two </span><span class="c28">expr</span><span class="c4">’s). </span></p></body></html>
