<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.ymhwsz33pki9"><span class="c4">Caching Results</span></h2><p class="c5"><span class="calibre3">If we use lazy programming without side effects, we get a nice benefit: each expression always produces the same result. In that case, we don’t ever have to recompute an expression; we can just store its result and reuse it on subsequent accesses. That is, we can </span><span class="c7">cache</span><span class="c4"> the result, enabling us to trade space for time.</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Aside: </span><span class="calibre3">If you are not familiar with trading space for time in computation—as found in techniques such as memoization and dynamic programming—see DCIC:<br class="calibre"/></span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://dcic-world.org/2022-08-28/part_advtopics.html%23%2528part._avoid-recomp%2529&amp;sa=D&amp;source=editors&amp;ust=1695232021588822&amp;usg=AOvVaw1pcTCRspVLqsEkkFNFbtyj">https://dcic-world.org/2022-08-28/part_advtopics.html#%28part._avoid-recomp%29</a></span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">There are, however, two kinds of result caching one can perform.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">One is what happens in Lazy Racket, where each expression’s result is cached locally. This means that if the same source </span><span class="c7">location</span><span class="c4"> is evaluated multiple times, the cached value can be reused. Other implementation strategies can look for the same expression even in a dynamic setting (as happens, for instance, in a Fibonacci function, which dynamically generates sub-problems). This requires a rather different implementation approach, but can yield even bigger time-space trade-offs.</span></p></body></html>
