<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.om6g3zw9o2c"><span class="c4">A Standard Model of Types</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Types can be thought of as abstractions of run-time values. That is, whereas at run-time we can have a very large number of numbers and strings and images (and two Booleans), we will collapse the distinctions </span><span class="c7">within</span><span class="calibre3"> these and preserve only the distinctions </span><span class="c7">between</span><span class="c4"> them. Therefore, it is instructive to start with a basic interpreter and try to build a type checker from there:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define-type BinOp</span></p><p class="c5"><span class="c41">  [plus])</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">(define-type Expr</span></p><p class="c5"><span class="c41">  [binE (operator : BinOp)</span></p><p class="c5"><span class="c41">        (left  : Exp)</span></p><p class="c5"><span class="c41">        (right : Exp)]</span></p><p class="c5"><span class="c41">  [numE (value : Number)])</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">(calc : (Exp -&gt; Number))</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">(define (calc e)</span></p><p class="c5"><span class="c41">  (type-case Exp e</span></p><p class="c5"><span class="c41">    [(binE o l r)</span></p><p class="c5"><span class="c41">     (type-case BinOp o</span></p><p class="c5"><span class="c41">       [(plus) (+ (calc l) (calc r))])]</span></p><p class="c5"><span class="c41">    [(numE v) v]))</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c28">(test (calc (binE (plus) (numE 5) (numE 6))) 11)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Now let’s see what needs to happen with a type-checker. The label on the tin says “checker”: that is, the job of a type-checker is to </span><span class="c7">pass judgment</span><span class="c4"> on programs, i.e., to determine whether or not they are type-correct. Thus, a natural type (for the type checker) would be</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c28">(tc : (Exp -&gt; </span><span class="c64">Boolean</span><span class="c41">))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">(In practice, of course, we would want more information in case the program is not type-correct, i.e., we’d like an error diagnostic. But we’re ignoring human factors considerations here.) With this type, we can now rewrite the relevant parts of the interpreter above:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c28">(define (</span><span class="c64">tc</span><span class="c41"> e)</span></p><p class="c5"><span class="c41">  (type-case Exp e</span></p><p class="c5"><span class="c41">    [(binE o l r)</span></p><p class="c5"><span class="c41">     (type-case BinOp o</span></p><p class="c5"><span class="c28">       [(plus) (</span><span class="c64">and</span><span class="c28"> (</span><span class="c64">tc</span><span class="c28"> l) (</span><span class="c64">tc</span><span class="c41"> r))])]</span></p><p class="c5"><span class="c28">    [(numE v) </span><span class="c64">#true</span><span class="c41">]))</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c28">(test (</span><span class="c64">tc</span><span class="c28"> (binE (plus) (numE 5) (numE 6))) </span><span class="c64">#true</span><span class="c41">)</span></p><p class="c3"><span class="c72"></span></p><p class="c5"><span class="calibre3">Actually, let’s peer at this for a moment. Given a number, the type-checker returns </span><span class="c28">#true</span><span class="calibre3">. In the recursive cases, it computes the </span><span class="c28">and</span><span class="calibre3"> of type-checking the pieces. And that’s it. Since there is no way to return </span><span class="c28">#false</span><span class="calibre3">, the entire type-checker must always only return </span><span class="c28">#true</span><span class="c4">. That is, every program is type-correct.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">The problem is because we have only one type, numbers, and only one operation, also on numbers, so what could possibly go wrong? We need to extend the types and operations so that there are meaningful possibilities for errors. Therefore, suppose we add a </span><span class="c28">++</span><span class="c4"> operation that concatenates strings.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define-type BinOp</span></p><p class="c5"><span class="c28">  [plus] </span><span class="c64">[++]</span><span class="c41">)</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">(define-type Expr</span></p><p class="c5"><span class="c41">  [binE (operator : BinOp)</span></p><p class="c5"><span class="c41">        (left  : Exp)</span></p><p class="c5"><span class="c41">        (right : Exp)]</span></p><p class="c5"><span class="c41">  [numE (value : Number)]</span></p><p class="c5"><span class="c28">  </span><span class="c64">[strE (value : String)]</span><span class="c41">)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Various things break, and need to be fixed. How about this?</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define (tc e)</span></p><p class="c5"><span class="c41">  (type-case Exp e</span></p><p class="c5"><span class="c41">    [(binE o l r)</span></p><p class="c5"><span class="c41">     (type-case BinOp o</span></p><p class="c5"><span class="c41">       [(plus) (and (tc l) (tc r))]</span></p><p class="c5"><span class="c28">       </span><span class="c64">[(++)   (and (tc l) (tc r))]</span><span class="c41">)]</span></p><p class="c5"><span class="c41">    [(numE v) #true]</span></p><p class="c5"><span class="c28">    </span><span class="c64">[(strE v) #true]</span><span class="c41">))</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c65">(test (tc (binE (++) (strE "hello") (strE "world"))) #true)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">So this looks pretty good, right?</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Do Now:</span><span class="c4"> This is not at all what we want! Write a test case that demonstrates that.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Here are two tests that demonstrate </span><span class="c7">desirable</span><span class="c4"> behavior:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(test (tc (binE (++) (numE 5) (numE 6))) #false)</span></p><p class="c5"><span class="c41">(test (tc (binE (plus) (strE "hello") (strE "world"))) #false)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">The first string-concatenates two numbers, the second adds two strings. Therefore, both should be rejected by the type-checker. Yet both of them pass (i.e., the tests above fail).</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">What is the core problem here? It’s that, given an expression, we only know </span><span class="c7">whether</span><span class="calibre3"> its sub-expressions typed correctly, but not </span><span class="c7">what</span><span class="calibre3"> their types are.  That is insufficient to determine whether the current expression is type-correct. For instance, the </span><span class="c28">++</span><span class="c4"> operator needs to check not only whether its two sub-expressions are well-typed, but also whether they produced strings; if they did not, then the concatenation is erroneous.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">What this shows is that we need the type-checker to have a richer type: it must instead be</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c28">(tc : (Exp -&gt; </span><span class="c64">Type</span><span class="c28">))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">That is, the type “checker” must actually be a type </span><span class="c7">calculator</span><span class="calibre3">, i.e., it even more closely parallels the evaluator, just over the universe of abstracted values (types) rather than concrete ones. Following convention, however, we’ll continue to call it a checker, because it </span><span class="c7">also</span><span class="c4"> checks in the process of calculating types.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">In the type declaration above, </span><span class="c28">Type</span><span class="calibre3"> is a new (</span><span class="c28">plait</span><span class="c4"> type) definition that records the possible types:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c28">(define-type Type [numT] [strT])</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">With this, we can rewrite our type-“checker”:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define (tc e)</span></p><p class="c5"><span class="c41">  (type-case Exp e</span></p><p class="c5"><span class="c41">    [(binE o l r)</span></p><p class="c5"><span class="c41">     (type-case BinOp o</span></p><p class="c5"><span class="c41">       [(plus) (if (and (numT? (tc l)) (numT? (tc r)))</span></p><p class="c5"><span class="c41">                   (numT)</span></p><p class="c5"><span class="c41">                   (error 'tc "not both numbers"))]</span></p><p class="c5"><span class="c41">       [(++)   (if (and (strT? (tc l)) (strT? (tc r)))</span></p><p class="c5"><span class="c41">                   (strT)</span></p><p class="c5"><span class="c41">                   (error 'tc "not both strings"))])]</span></p><p class="c5"><span class="c41">    [(numE v) (numT)]</span></p><p class="c5"><span class="c41">    [(strE v) (strT)]))</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">(test (tc (binE (plus) (numE 5) (numE 6))) (numT))</span></p><p class="c5"><span class="c41">(test (tc (binE (++) (strE "hello") (strE "world"))) (strT))</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">(test/exn (tc (binE (++) (numE 5) (numE 6))) "strings")</span></p><p class="c5"><span class="c41">(test/exn (tc (binE (plus) (strE "hello") (strE "world"))) "numbers")</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">There are three take-aways from this:</span></p><p class="c3"><span class="c4"></span></p><ol class="c86" start="1"><li class="pcalibre12 c87"><span class="c4">The type-checker follows the same implementation schema as the interpreter: an algebraic datatype to represent the AST, and structural recursion to process it. This is the schema we’re calling SImPl.</span></li><li class="pcalibre12 c87"><span class="calibre3">A type-checker, unlike an interpreter, operates with “weak” values: note, for instance, how the </span><span class="c28">numE</span><span class="c4"> case ignores the actual numeric values. Both the strengths and weaknesses of traditional type-checking arise from this ignorance.</span></li><li class="pcalibre12 c87"><span class="calibre3">In mathematical terms, the upgrade we performed in going from a type-checker to a type-calculator was a process of strengthening the inductive hypothesis: instead of returning only a </span><span class="c28">Boolean</span><span class="calibre3">, we had to return the actual type of each expression. This may not seem like a literal strengthening; but it is inasmuch as the former </span><span class="c28">#true</span><span class="calibre3"> has been replaced by a </span><span class="c28">Type</span><span class="calibre3"> and the </span><span class="c28">#false</span><span class="c4"> by an error.</span></li></ol><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Exercise:</span><span class="c4"> Add division to the language and type-check it.</span></p></body></html>
