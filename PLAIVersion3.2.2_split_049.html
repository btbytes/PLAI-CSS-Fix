<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.rh0h0wb4rhhu"><span class="c4">Extending Tests</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Well, actually, we shouldn’t be too happy. Consider the following examples:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(let1E 'x (numE 1)</span></p><p class="c5"><span class="c41">       (let1E 'f (lamE 'y (varE 'x))</span></p><p class="c5"><span class="c41">              (let1E 'x (numE 2)</span></p><p class="c5"><span class="c41">                     (appE (varE 'f) (numE 10)))))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">What do we expect it to produce? If in doubt, we can write the same thing as a Racket program:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(let ([x 1])</span></p><p class="c5"><span class="c41">  (let ([f (lambda (y) x)])</span></p><p class="c5"><span class="c41">    (let ([x 2])</span></p><p class="c5"><span class="c41">      (f 10))))</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="calibre3">What we see is that </span><span class="c7">in Racket</span><span class="calibre3">, the inner binding of </span><span class="c28">x</span><span class="calibre3"> does </span><span class="c7">not</span><span class="calibre3"> override the outer one, the one that was present at the time the function bound to </span><span class="c28">f</span><span class="calibre3"> was defined. Therefore, this produces </span><span class="c28">1</span><span class="c4"> in Racket.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">We should want this! Otherwise, consider this program:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(let1E 'f (lamE 'y (varE 'x))</span></p><p class="c5"><span class="c41">       (let1E 'x (numE 1)</span></p><p class="c5"><span class="c41">              (appE (varE 'f) (numE 10))))</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c4">This corresponds to</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(let ([f (lambda (y) x)])</span></p><p class="c5"><span class="c41">  (let ([x 5])</span></p><p class="c5"><span class="c41">    (f 3)))</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="calibre3">which has an unbound identifier (</span><span class="c28">x</span><span class="calibre3">) error. But our interpreter produces </span><span class="c28">1</span><span class="calibre3"> instead of halting with an error, which leads us right back to </span><span class="c70">☠️</span><span class="c40">dynamic scope </span><span class="c4">☠️!</span></p></body></html>
