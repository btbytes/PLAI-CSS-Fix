<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.r9b5rx2ualtj"><span class="c4">Making Memory Explicit (Unsafely)</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Now weâ€™re going to do something fun: weâ€™re going to make the memory allocation of values explicit. As we go through this, remember what weâ€™ve said before: a value in SMoL is just a memory address.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Letâ€™s do this in stages. First, weâ€™ll use a vector to represent memory:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define MEMORY (make-vector 100 -1))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">The value </span><span class="c28">-1</span><span class="calibre3">Â is useful for identifying parts of memory that have not yet been touched (assuming, of course, we donâ€™t write a program that produces </span><span class="c28">-1</span><span class="c4">â€”which we can avoid doing easily enough in this illustration).</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Aside:</span><span class="c4">Â To run the code below, you will need to import some Racket primitives into plait:</span></p><p class="c51"><span class="c4"></span></p><p class="c31"><span class="c41">(require (typed-in racket/base</span></p><p class="c31"><span class="c41">Â  Â  Â  Â  Â  Â  Â  Â  Â  Â [char-&gt;integer : (Char -&gt; Number)]</span></p><p class="c31"><span class="c41">Â  Â  Â  Â  Â  Â  Â  Â  Â  Â [integer-&gt;char : (Number -&gt; Char)]</span></p><p class="c31"><span class="c41">Â  Â  Â  Â  Â  Â  Â  Â  Â  Â [number-&gt;string : (Number -&gt; String)]))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">It will be useful to have a helper to use the next available bit of memory:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define next-addr 0)</span></p><p class="c5"><span class="c41">(define (write-and-bump v)</span></p><p class="c5"><span class="c41">Â  (let ([n next-addr])</span></p><p class="c5"><span class="c41">Â  Â  (begin</span></p><p class="c5"><span class="c41">Â  Â  Â  (vector-set! MEMORY n v)</span></p><p class="c5"><span class="c41">Â  Â  Â  (set! next-addr (add1 next-addr))</span></p><p class="c5"><span class="c41">Â  Â  Â  n)))</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="calibre3">Now letâ€™s say we want to store a number in memory. We put it in the next available memory place, and return the </span><span class="c7">address</span><span class="calibre3">Â of the place where the number was stored. Be careful here: the number we return is a memory address (which, here, is represented as an array index), which is not at all necessarily the same as the </span><span class="c7">numeric value</span><span class="c4">Â being stored.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define (store-num n)</span></p><p class="c5"><span class="c41">Â  (write-and-bump n))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Correspondingly, when we want to read a number, we simply return what is at the address corresponding to the number.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define (read-num a)</span></p><p class="c5"><span class="c41">Â  (vector-ref MEMORY a))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">We want the property that when we </span><span class="c28">read-num</span><span class="calibre3">Â from the address where we </span><span class="c28">store-num</span><span class="calibre3">Â a number, we get back that same number: for all </span><span class="c28">N</span><span class="c4">,</span></p><p class="c3"><span class="c4"></span></p><p class="c8"><span class="c28">(read-num (store-num N))</span><span class="calibre3">Â is </span><span class="c41">N</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Aside:</span><span class="calibre3">Â This is not quite exactly how numbers are stored in most languages. As we will see when we update the calculator below, this means every time we produce a particular numberâ€”</span><span class="c28">1730</span><span class="calibre3">, sayâ€”we store it afresh in memory. That would be extremely wasteful. Rather, language implementations use representation tricks to make sure there is only one copy of numbers and that they donâ€™t need to take up space on the heap at all, as we describe below [</span><span class="c16"><a class="c11" href="PLAIVersion3.2.2_split_114.html#h.dirpjggvkz7z">ğŸ‘‰</a></span><span class="calibre3">]. However, we will continue to work with this simple model because this optimization is not the focus of this chapter. In addition, </span><span class="c7">some</span><span class="calibre3">Â numbersâ€”that donâ€™t fit in a small amount of spaceâ€”</span><span class="c7">do</span><span class="c4">Â need to be stored on the heap.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Now letâ€™s look at strings. We are going to convert the string into a sequence of character codes, and store those codes explicitly:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define (store-str s)</span></p><p class="c5"><span class="c41">Â  (let ([a0 (write-and-bump (string-length s))])</span></p><p class="c5"><span class="c41">Â  Â  (begin</span></p><p class="c5"><span class="c41">Â  Â  Â  (map write-and-bump</span></p><p class="c5"><span class="c41">Â  Â  Â  Â  Â  Â (map char-&gt;integer (string-&gt;list s)))</span></p><p class="c5"><span class="c41">Â  Â  Â  a0)))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">In particular, the value stored at the address representing the string is the </span><span class="c7">length</span><span class="c4">Â of the string, followed by the individual characters. (Endless blood has been spent over whether strings should store their lengths at the front, or whether they should only be delimited by a special value, or both. The question is uninteresting here.) Thus, suppose with a fresh memory we run</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(store-str "hello")</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">this would return the address </span><span class="c28">0</span><span class="c4">. The resulting value of MEMORY would be</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">'#(5</span></p><p class="c5"><span class="c41">Â  Â 104</span></p><p class="c5"><span class="c41">Â  Â 101</span></p><p class="c5"><span class="c41">Â  Â 108</span></p><p class="c5"><span class="c41">Â  Â 108</span></p><p class="c5"><span class="c41">Â  Â 111</span></p><p class="c5"><span class="c41">Â  Â -1</span></p><p class="c5"><span class="c41">Â  Â -1</span></p><p class="c5"><span class="c41">Â  Â -1</span></p><p class="c5"><span class="c41">Â  Â â€¦)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">That is, at address </span><span class="c28">0</span><span class="calibre3">Â we have the length of the string, followed by five character codes; these six memory entries together constitute the five-character string </span><span class="c28">"hello"</span><span class="c4">. The rest of the memory remains untouched. To read a string we have to reassemble it:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define (read-str a)</span></p><p class="c5"><span class="c41">Â  (letrec ([loop</span></p><p class="c5"><span class="c41">Â  Â  Â  Â  Â  Â  (lambda (count a)</span></p><p class="c5"><span class="c41">Â  Â  Â  Â  Â  Â  Â  (if (zero? count)</span></p><p class="c5"><span class="c41">Â  Â  Â  Â  Â  Â  Â  Â  Â  empty</span></p><p class="c5"><span class="c41">Â  Â  Â  Â  Â  Â  Â  Â  Â  (cons (vector-ref MEMORY a)</span></p><p class="c5"><span class="c41">Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  (loop (sub1 count) (add1 a)))))])</span></p><p class="c5"><span class="c41">Â  Â  (list-&gt;string</span></p><p class="c5"><span class="c41">Â  Â  Â (map integer-&gt;char</span></p><p class="c5"><span class="c41">Â  Â  Â  Â  Â  (loop (vector-ref MEMORY a) (add1 a))))))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Once again, we want the result of reading a written string to give us the same string.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Now letâ€™s update the calculator. First, weâ€™re in for a surprise: we no longer need (or </span><span class="c7">want</span><span class="c4">) a fancy Racket datatype to track values, because values are just addresses (i.e., array indices)! So:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define-type-alias Value Number)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">The </span><span class="c7">type</span><span class="calibre3">Â of the calculator doesnâ€™t change; it still produces values. Itâ€™s just that the representation of values has changedâ€¦dramatically. (Recall, again, that these </span><span class="c28">Number</span><span class="calibre3">s are addresses, not numeric values </span><span class="c7">in</span><span class="c4">Â the interpreted language.)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">The calculator remains the same. What has changed is in the helper functions. In the primitive value cases, we have to explicitly allocate themâ€”which is what we were doing when we called the previous definitions of </span><span class="c28">numV</span><span class="calibre3">Â and </span><span class="c28">strV</span><span class="c4">Â (which store data on the heap), except it may not have been so evident. We will make it explicit as follows:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define numV store-num)</span></p><p class="c5"><span class="c41">(define strV store-str)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Okay, now to update the helper functions. Letâ€™s focus on </span><span class="c28">num+</span><span class="c4">. The core logic is currently</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">Â  Â  Â  Â [(numV rn) (numV (+ ln rn))]</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Observe that now weâ€™re calling it on the result of calling </span><span class="c28">calc</span><span class="calibre3">, i.e., on </span><span class="c28">Value</span><span class="calibre3">s. That means </span><span class="c28">num+</span><span class="c4">Â is going to get two addresses as arguments, and it needs to look up the corresponding numbers in memory, and then produce the resulting number:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define (num+ la ra)</span></p><p class="c5"><span class="c41">Â  (numV (+ (read-num la) (read-num ra))))</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Aside: </span><span class="c4">In case youâ€™re wondering: yes, weâ€™re cheating a tiny bit. Weâ€™re using Racket numbers rather than dealing with even lower-level representations. Weâ€™ll give ourselves this little bit of leeway since this is not the point weâ€™re trying to illustrate.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Analogously, we can define concatenation as well:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define (str++ la ra)</span></p><p class="c5"><span class="c41">Â  (strV (string-append (read-str la) (read-str ra))))</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Aside: </span><span class="calibre3">Yes, weâ€™re cheating again, and quite a bit. If we were less lazy, weâ€™d write a big loop over </span><span class="c28">MEMORY</span><span class="c4">Â that copies all the values from the first and second strings into a new, third string, explicitly. But weâ€™re lazy.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Finally, we have to update our tests as well. Because </span><span class="c28">calc</span><span class="calibre3">Â now returns </span><span class="c7">addresses</span><span class="calibre3">, all our answers appear to be incorrect. Instead, we have to obtain the corresponding numbers or strings at those addresses. Once we do so, </span><span class="c28">calc</span><span class="c4">Â passes the tests:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(test (read-num (calc (plus (num 1) (num 2)))) 3)</span></p><p class="c5"><span class="c41">(test (read-num (calc (plus (num 1) (plus (num 2) (num 3))))) 6)</span></p><p class="c5"><span class="c41">(test (read-str (calc (cat (str "hel") (str "lo")))) "hello")</span></p><p class="c5"><span class="c41">(test (read-str (calc (cat (cat (str "hel") (str "l")) (str "o")))) "hello")</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Exceptâ€¦does it? These two tests do not pass:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(test/exn (calc (cat (num 1) (str "hello"))) "left")</span></p><p class="c5"><span class="c41">(test/exn (calc (plus (num 1) (str "hello"))) "right")</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">In fact, how </span><span class="c7">can</span><span class="c4">Â they? In all the above code, there are no errors left! Rather, when we run</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(calc (cat (num 1) (str "hello")))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">we get an address back (maybe </span><span class="c28">69</span><span class="calibre3">; it depends on what you ran earlier and hence what is in </span><span class="c28">MEMORY</span><span class="c4">). In fact, we can decide how we want to treat this: as a number?</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">&gt; (read-num 69)</span></p><p class="c5"><span class="c41">- Number</span></p><p class="c5"><span class="c41">6</span></p><p class="c5"><span class="c41">&gt; (read-str 69)</span></p><p class="c5"><span class="c41">- String</span></p><p class="c5"><span class="c41">"\u0005hello"</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">How can something be both a number and a string? Well, actually, the situation is a bit more confusing than that: </span><span class="c28">69</span><span class="calibre3">Â above is just an address in memory from which we can read off whatever we want </span><span class="c7">however we want it</span><span class="calibre3">Â (i.e., the content of that address is </span><span class="c7">interpreted</span><span class="c4">Â by the function that reads from it), which can result in garbage. It can get even worse:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">&gt; (read-num (calc (plus (num 1) (str "hello"))))</span></p><p class="c5"><span class="c41">- Number</span></p><p class="c5"><span class="c41">6</span></p><p class="c5"><span class="c41">&gt; (read-str (calc (plus (num 1) (str "hello"))))</span></p><p class="c5"><span class="c41">- String</span></p><p class="c5"><span class="c73">. . integer-&gt;char: contract violation</span></p><p class="c5"><span class="c73">Â  expected: valid-unicode-scalar-value?</span></p><p class="c5"><span class="c73">Â  given: -1</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">That is, weâ€™ve tried to read â€œoff the end of memoryâ€. It was dumb luck that we had a </span><span class="c28">-1</span><span class="calibre3">Â as the initial value; the </span><span class="c28">-1</span><span class="calibre3">Â triggered an error when we tried to convert it to a character </span><span class="c7">because Racketâ€™s primitives are safe</span><span class="calibre3">, which halted the program. If </span><span class="c28">integer-&gt;char</span><span class="c4">Â did not have a safety check, we would have gotten some garbled string instead.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">In short, what we have created is an </span><span class="c7">unsafe</span><span class="c4">Â language. Data have no integrity. Any value can be treated as any kind of datum. This, in short, is the memory model of C, and itâ€™s largely proven to be a disaster for modern programming, which is why SMoL languages evolved.</span></p></body></html>
