<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.r9b5rx2ualtj"><span class="c4">Making Memory Explicit (Unsafely)</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Now we’re going to do something fun: we’re going to make the memory allocation of values explicit. As we go through this, remember what we’ve said before: a value in SMoL is just a memory address.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Let’s do this in stages. First, we’ll use a vector to represent memory:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define MEMORY (make-vector 100 -1))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">The value </span><span class="c28">-1</span><span class="calibre3"> is useful for identifying parts of memory that have not yet been touched (assuming, of course, we don’t write a program that produces </span><span class="c28">-1</span><span class="c4">—which we can avoid doing easily enough in this illustration).</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Aside:</span><span class="c4"> To run the code below, you will need to import some Racket primitives into plait:</span></p><p class="c51"><span class="c4"></span></p><p class="c31"><span class="c41">(require (typed-in racket/base</span></p><p class="c31"><span class="c41">                   [char-&gt;integer : (Char -&gt; Number)]</span></p><p class="c31"><span class="c41">                   [integer-&gt;char : (Number -&gt; Char)]</span></p><p class="c31"><span class="c41">                   [number-&gt;string : (Number -&gt; String)]))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">It will be useful to have a helper to use the next available bit of memory:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define next-addr 0)</span></p><p class="c5"><span class="c41">(define (write-and-bump v)</span></p><p class="c5"><span class="c41">  (let ([n next-addr])</span></p><p class="c5"><span class="c41">    (begin</span></p><p class="c5"><span class="c41">      (vector-set! MEMORY n v)</span></p><p class="c5"><span class="c41">      (set! next-addr (add1 next-addr))</span></p><p class="c5"><span class="c41">      n)))</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="calibre3">Now let’s say we want to store a number in memory. We put it in the next available memory place, and return the </span><span class="c7">address</span><span class="calibre3"> of the place where the number was stored. Be careful here: the number we return is a memory address (which, here, is represented as an array index), which is not at all necessarily the same as the </span><span class="c7">numeric value</span><span class="c4"> being stored.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define (store-num n)</span></p><p class="c5"><span class="c41">  (write-and-bump n))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Correspondingly, when we want to read a number, we simply return what is at the address corresponding to the number.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define (read-num a)</span></p><p class="c5"><span class="c41">  (vector-ref MEMORY a))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">We want the property that when we </span><span class="c28">read-num</span><span class="calibre3"> from the address where we </span><span class="c28">store-num</span><span class="calibre3"> a number, we get back that same number: for all </span><span class="c28">N</span><span class="c4">,</span></p><p class="c3"><span class="c4"></span></p><p class="c8"><span class="c28">(read-num (store-num N))</span><span class="calibre3"> is </span><span class="c41">N</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Aside:</span><span class="calibre3"> This is not quite exactly how numbers are stored in most languages. As we will see when we update the calculator below, this means every time we produce a particular number—</span><span class="c28">1730</span><span class="calibre3">, say—we store it afresh in memory. That would be extremely wasteful. Rather, language implementations use representation tricks to make sure there is only one copy of numbers and that they don’t need to take up space on the heap at all, as we describe below [</span><span class="c16"><a class="c11" href="PLAIVersion3.2.2_split_114.html#h.dirpjggvkz7z">👉</a></span><span class="calibre3">]. However, we will continue to work with this simple model because this optimization is not the focus of this chapter. In addition, </span><span class="c7">some</span><span class="calibre3"> numbers—that don’t fit in a small amount of space—</span><span class="c7">do</span><span class="c4"> need to be stored on the heap.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Now let’s look at strings. We are going to convert the string into a sequence of character codes, and store those codes explicitly:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define (store-str s)</span></p><p class="c5"><span class="c41">  (let ([a0 (write-and-bump (string-length s))])</span></p><p class="c5"><span class="c41">    (begin</span></p><p class="c5"><span class="c41">      (map write-and-bump</span></p><p class="c5"><span class="c41">           (map char-&gt;integer (string-&gt;list s)))</span></p><p class="c5"><span class="c41">      a0)))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">In particular, the value stored at the address representing the string is the </span><span class="c7">length</span><span class="c4"> of the string, followed by the individual characters. (Endless blood has been spent over whether strings should store their lengths at the front, or whether they should only be delimited by a special value, or both. The question is uninteresting here.) Thus, suppose with a fresh memory we run</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(store-str "hello")</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">this would return the address </span><span class="c28">0</span><span class="c4">. The resulting value of MEMORY would be</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">'#(5</span></p><p class="c5"><span class="c41">   104</span></p><p class="c5"><span class="c41">   101</span></p><p class="c5"><span class="c41">   108</span></p><p class="c5"><span class="c41">   108</span></p><p class="c5"><span class="c41">   111</span></p><p class="c5"><span class="c41">   -1</span></p><p class="c5"><span class="c41">   -1</span></p><p class="c5"><span class="c41">   -1</span></p><p class="c5"><span class="c41">   …)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">That is, at address </span><span class="c28">0</span><span class="calibre3"> we have the length of the string, followed by five character codes; these six memory entries together constitute the five-character string </span><span class="c28">"hello"</span><span class="c4">. The rest of the memory remains untouched. To read a string we have to reassemble it:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define (read-str a)</span></p><p class="c5"><span class="c41">  (letrec ([loop</span></p><p class="c5"><span class="c41">            (lambda (count a)</span></p><p class="c5"><span class="c41">              (if (zero? count)</span></p><p class="c5"><span class="c41">                  empty</span></p><p class="c5"><span class="c41">                  (cons (vector-ref MEMORY a)</span></p><p class="c5"><span class="c41">                        (loop (sub1 count) (add1 a)))))])</span></p><p class="c5"><span class="c41">    (list-&gt;string</span></p><p class="c5"><span class="c41">     (map integer-&gt;char</span></p><p class="c5"><span class="c41">          (loop (vector-ref MEMORY a) (add1 a))))))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Once again, we want the result of reading a written string to give us the same string.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Now let’s update the calculator. First, we’re in for a surprise: we no longer need (or </span><span class="c7">want</span><span class="c4">) a fancy Racket datatype to track values, because values are just addresses (i.e., array indices)! So:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define-type-alias Value Number)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">The </span><span class="c7">type</span><span class="calibre3"> of the calculator doesn’t change; it still produces values. It’s just that the representation of values has changed…dramatically. (Recall, again, that these </span><span class="c28">Number</span><span class="calibre3">s are addresses, not numeric values </span><span class="c7">in</span><span class="c4"> the interpreted language.)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">The calculator remains the same. What has changed is in the helper functions. In the primitive value cases, we have to explicitly allocate them—which is what we were doing when we called the previous definitions of </span><span class="c28">numV</span><span class="calibre3"> and </span><span class="c28">strV</span><span class="c4"> (which store data on the heap), except it may not have been so evident. We will make it explicit as follows:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define numV store-num)</span></p><p class="c5"><span class="c41">(define strV store-str)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Okay, now to update the helper functions. Let’s focus on </span><span class="c28">num+</span><span class="c4">. The core logic is currently</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">       [(numV rn) (numV (+ ln rn))]</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Observe that now we’re calling it on the result of calling </span><span class="c28">calc</span><span class="calibre3">, i.e., on </span><span class="c28">Value</span><span class="calibre3">s. That means </span><span class="c28">num+</span><span class="c4"> is going to get two addresses as arguments, and it needs to look up the corresponding numbers in memory, and then produce the resulting number:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define (num+ la ra)</span></p><p class="c5"><span class="c41">  (numV (+ (read-num la) (read-num ra))))</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Aside: </span><span class="c4">In case you’re wondering: yes, we’re cheating a tiny bit. We’re using Racket numbers rather than dealing with even lower-level representations. We’ll give ourselves this little bit of leeway since this is not the point we’re trying to illustrate.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Analogously, we can define concatenation as well:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define (str++ la ra)</span></p><p class="c5"><span class="c41">  (strV (string-append (read-str la) (read-str ra))))</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Aside: </span><span class="calibre3">Yes, we’re cheating again, and quite a bit. If we were less lazy, we’d write a big loop over </span><span class="c28">MEMORY</span><span class="c4"> that copies all the values from the first and second strings into a new, third string, explicitly. But we’re lazy.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Finally, we have to update our tests as well. Because </span><span class="c28">calc</span><span class="calibre3"> now returns </span><span class="c7">addresses</span><span class="calibre3">, all our answers appear to be incorrect. Instead, we have to obtain the corresponding numbers or strings at those addresses. Once we do so, </span><span class="c28">calc</span><span class="c4"> passes the tests:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(test (read-num (calc (plus (num 1) (num 2)))) 3)</span></p><p class="c5"><span class="c41">(test (read-num (calc (plus (num 1) (plus (num 2) (num 3))))) 6)</span></p><p class="c5"><span class="c41">(test (read-str (calc (cat (str "hel") (str "lo")))) "hello")</span></p><p class="c5"><span class="c41">(test (read-str (calc (cat (cat (str "hel") (str "l")) (str "o")))) "hello")</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Except…does it? These two tests do not pass:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(test/exn (calc (cat (num 1) (str "hello"))) "left")</span></p><p class="c5"><span class="c41">(test/exn (calc (plus (num 1) (str "hello"))) "right")</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">In fact, how </span><span class="c7">can</span><span class="c4"> they? In all the above code, there are no errors left! Rather, when we run</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(calc (cat (num 1) (str "hello")))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">we get an address back (maybe </span><span class="c28">69</span><span class="calibre3">; it depends on what you ran earlier and hence what is in </span><span class="c28">MEMORY</span><span class="c4">). In fact, we can decide how we want to treat this: as a number?</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">&gt; (read-num 69)</span></p><p class="c5"><span class="c41">- Number</span></p><p class="c5"><span class="c41">6</span></p><p class="c5"><span class="c41">&gt; (read-str 69)</span></p><p class="c5"><span class="c41">- String</span></p><p class="c5"><span class="c41">"\u0005hello"</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">How can something be both a number and a string? Well, actually, the situation is a bit more confusing than that: </span><span class="c28">69</span><span class="calibre3"> above is just an address in memory from which we can read off whatever we want </span><span class="c7">however we want it</span><span class="calibre3"> (i.e., the content of that address is </span><span class="c7">interpreted</span><span class="c4"> by the function that reads from it), which can result in garbage. It can get even worse:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">&gt; (read-num (calc (plus (num 1) (str "hello"))))</span></p><p class="c5"><span class="c41">- Number</span></p><p class="c5"><span class="c41">6</span></p><p class="c5"><span class="c41">&gt; (read-str (calc (plus (num 1) (str "hello"))))</span></p><p class="c5"><span class="c41">- String</span></p><p class="c5"><span class="c73">. . integer-&gt;char: contract violation</span></p><p class="c5"><span class="c73">  expected: valid-unicode-scalar-value?</span></p><p class="c5"><span class="c73">  given: -1</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">That is, we’ve tried to read “off the end of memory”. It was dumb luck that we had a </span><span class="c28">-1</span><span class="calibre3"> as the initial value; the </span><span class="c28">-1</span><span class="calibre3"> triggered an error when we tried to convert it to a character </span><span class="c7">because Racket’s primitives are safe</span><span class="calibre3">, which halted the program. If </span><span class="c28">integer-&gt;char</span><span class="c4"> did not have a safety check, we would have gotten some garbled string instead.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">In short, what we have created is an </span><span class="c7">unsafe</span><span class="c4"> language. Data have no integrity. Any value can be treated as any kind of datum. This, in short, is the memory model of C, and it’s largely proven to be a disaster for modern programming, which is why SMoL languages evolved.</span></p></body></html>
