<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.rnh3ftykhtvd"><span class="c4">How Evaluation Works</span></h2><h3 class="c79" id="h.vh2f13ojlzfv"><span class="c80">Dataflow Graphs</span></h3><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">What happens when we write these expressions? FrTime rewrites the way function applications happen. If </span><span class="c7">no</span><span class="calibre3"> argument to a function is time-varying, then the function evaluates just as it would in regular Racket. If, however, any of its arguments is time-varying, then FrTime constructs a node in a </span><span class="c7">dataflow</span><span class="c4"> graph. This node is attached to the nodes corresponding to the time-varying arguments.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Consider this expression:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c28">(length (build-list (modulo seconds 10) (lambda (n) n)))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">The act of calling length evaluates its argument, which is a call to build-list, which evaluates its two arguments. The second argument is an ordinary closure. The first argument is a call to modulo, which evaluates </span><span class="c7">its</span><span class="c4"> two arguments. Again, the second argument is just a number, but the first argument is time-varying. Consequently, this turns into a dataflow graph node, where we use the context notation to indicate where time-varying values go:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3"> </span><span class="calibre43"><img alt="" src="image6.png" title="" class="calibre44"/></span></p><p class="c5"><span class="calibre3">Because </span><span class="c28">(modulo seconds 10)</span><span class="c4"> evaluates to a time-varying value, so does the next outer expression:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre45"><img alt="" src="image22.png" title="" class="calibre46"/></span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">and finally the outermost one:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre47"><img alt="" src="image8.png" title="" class="calibre48"/></span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">The program source therefore evaluates to this dataflow graph. Now, each time-varying value may evaluate at different rates and for different reasons. </span><span class="c28">seconds</span><span class="calibre3">, naturally, updates once every second. When it does, its updated value is </span><span class="c7">pushed</span><span class="c4"> to all the nodes that depend on it, which update their value and push their values, and so on all the way through the graph. Finally, values may arrive at the REPL, which in FrTime is designed to display them automatically updating.</span></p><h3 class="c79" id="h.328tryaip5b9"><span class="c80">Rewriting Application</span></h3><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Essentially, we can think of reactivity being implemented by rewriting how function application works. In the simplest case, imagine we have a function application, </span><span class="c28">(f a)</span><span class="calibre3">. Let us assume that </span><span class="c28">f</span><span class="calibre3"> is itself not a time-varying value. Then, this application rewrites </span><span class="c28">(f a)</span><span class="c4"> as</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(let ([a-value a])</span></p><p class="c5"><span class="c41">  (if (time-varying? a-value)</span></p><p class="c5"><span class="c41">    …</span></p><p class="c5"><span class="c41">    (f a-value)))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">We will return to the </span><span class="c28">…</span><span class="calibre3"> in a moment. Observe that this evaluates the argument expression and, if it is not currently a time-varying value, then computation proceeds exactly as it would have in regular Racket. This means that progams that don’t use time-varying values behave </span><span class="c7">exactly</span><span class="calibre3"> as they would in Racket, so this is a </span><span class="c7">conservative</span><span class="c4"> extension of Racket.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Now let’s consider what happens if the parameter </span><span class="c7">is</span><span class="calibre3"> time-varying. That means, instead of immediately computing an answer, we have to create a node in the dataflow graph. We can imagine a time-varying value is an object of the class </span><span class="c28">tvv%</span><span class="calibre3"> (</span><span class="c28">tvv</span><span class="calibre3"> for time-varying value, and </span><span class="c28">%</span><span class="calibre3"> using the Racket convention for classes). We will first illustrate how this might be used, then show its definition. This class has two methods: </span><span class="c28">add-consumer</span><span class="calibre3">, which provides another object of </span><span class="c28">tvv%</span><span class="calibre3"> that will receive updated values, and </span><span class="c28">update</span><span class="calibre3">, which receives updated values. We reproduce the bottom three parts of the above dataflow graph as follows and, to keep the output short, compute the remainder relative to </span><span class="c28">5</span><span class="calibre3"> rather than </span><span class="c28">10</span><span class="c4">:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define seconds</span></p><p class="c5"><span class="c41">  (new tvv% [updater (λ (v) v)]))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">In practice, </span><span class="c28">seconds</span><span class="calibre3"> would be attached to a system timer that pushes an update every second. For simplicity, we make it an inert object that only changes when we manually call its </span><span class="c28">updater</span><span class="c4">.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">The remainder node now looks like this:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define mod•5</span></p><p class="c5"><span class="c41">  (new tvv% [updater (λ (v) (modulo v 5))]))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">That is, every time it receives a value from </span><span class="c28">seconds</span><span class="calibre3">, it computes that value </span><span class="c28">modulo</span><span class="calibre3"> </span><span class="c28">5</span><span class="calibre3">. Of course, right now it has no way of knowing that it must listen to </span><span class="c28">seconds</span><span class="c4">; we have to register it as a consumer:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(send seconds add-consumer mod•5)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Similarly, the </span><span class="c28">build-list</span><span class="c4"> expression creates a time-varying value object:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define bl•id</span></p><p class="c5"><span class="c41">  (new tvv% [updater (λ (v) (build-list v (λ (n) n)))]))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">which too we must attach to its value producer:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(send mod•5 add-consumer bl•id)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Observe how the </span><span class="c28">v</span><span class="calibre3"> parameters in </span><span class="c28">mod•5</span><span class="calibre3"> and in </span><span class="c28">bl•id</span><span class="c4"> correspond to the • in the dataflow graph.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Finally, just as </span><span class="c28">seconds</span><span class="calibre3"> is a source in the graph, we will define a sink that prints results, and send values from </span><span class="c28">bl•id</span><span class="c4"> to it:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define show</span></p><p class="c5"><span class="c41">  (new tvv% [updater (λ (v) (println v))]))</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">(send bl•id add-consumer show)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Now we’re ready to test it all! If we simulate </span><span class="c28">seconds</span><span class="c4"> updating for the first ten seconds:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(for-each (λ (n) (send seconds update n)) (range 0 10))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">we see the following output printed, just as we would expect:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">'()</span></p><p class="c5"><span class="c41">'(0)</span></p><p class="c5"><span class="c41">'(0 1)</span></p><p class="c5"><span class="c41">'(0 1 2)</span></p><p class="c5"><span class="c41">'(0 1 2 3)</span></p><p class="c5"><span class="c41">'()</span></p><p class="c5"><span class="c41">'(0)</span></p><p class="c5"><span class="c41">'(0 1)</span></p><p class="c5"><span class="c41">'(0 1 2)</span></p><p class="c5"><span class="c41">'(0 1 2 3)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">So how did this work? The </span><span class="c28">tvv%</span><span class="calibre3"> class keeps track of a list of consumers, of which above we have had only one per object. </span><span class="c28">add-consumer</span><span class="calibre3"> merely augments this list. The </span><span class="c28">update</span><span class="calibre3"> method receives a value, uses its </span><span class="c28">updater</span><span class="c4"> function to compute a new current value, and broadcasts it to all of its consumers:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define tvv%</span></p><p class="c5"><span class="c41">  (class object%</span></p><p class="c5"><span class="c41">    (init updater)</span></p><p class="c5"><span class="c41">    (define updater-function updater)</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">    (super-new)</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">    (define consumers empty)</span></p><p class="c5"><span class="c41">    (define/public (add-consumer new-consumer)</span></p><p class="c5"><span class="c41">      (set! consumers (cons new-consumer consumers)))</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">    (define/public (update pushed-value)</span></p><p class="c5"><span class="c41">      (let ([new-current-value (updater-function pushed-value)])</span></p><p class="c5"><span class="c41">        (for-each (λ (c) (send c update new-current-value))</span></p><p class="c5"><span class="c41">                  consumers)))))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">That’s (most of) the core logic (but read on). This brings us back to the rewriting of applications: what goes in </span><span class="c28">…</span><span class="c4">? Well, we have to</span></p><ul class="c24"><li class="c25 pcalibre"><span class="calibre3">make a new </span><span class="c28">tvv%</span><span class="c4"> instance</span></li><li class="c25 pcalibre"><span class="calibre3">supply it an updater function that corresponds to </span><span class="c41">(f •)</span></li><li class="c25 pcalibre"><span class="calibre3">registers that node as a consumer to the </span><span class="c28">tvv%</span><span class="calibre3"> object that </span><span class="c28">a-value</span><span class="c4"> references</span></li><li class="c25 pcalibre"><span class="calibre3">return the new </span><span class="c28">tvv%</span><span class="c4"> instance as the result of this function “application”</span></li></ul><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Exercise: </span><span class="calibre3">Turn the above rewriting idea into a proper macro. If you can, turn it into the </span><span class="c28">#%app</span><span class="calibre3"> of a </span><span class="c28">#lang</span><span class="c4"> so that one can program a module in a FrTime-like style.</span></p><p class="c3"><span class="c4"></span></p><h3 class="c79" id="h.oua1qbfq1uof"><span class="c80">Non-Linear Graphs</span></h3><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">The above example may be a bit misleading in suggesting that an expression must always have at most one time-varying parameter. Consider this program:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(= (modulo seconds 3) (modulo seconds 5))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Its dataflow graph looks like</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre49"><img alt="" src="image13.png" title="" class="calibre50"/></span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">On every update of </span><span class="c28">seconds</span><span class="calibre3">, </span><span class="c7">both</span><span class="c4"> expressions that depend on it update, and their result flows to the equality comparison. Every 15 seconds, we would expect to see 12 consecutive false values followed by three consecutive true values, and that is what we see.</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Exercise: </span><span class="calibre3">Does the above definition of </span><span class="c28">tvv%</span><span class="c4"> permit non-linear graphs? Can you write the above example with it? If so, show how. If not, modify it to allow such a definition.</span></p><h3 class="c79" id="h.yd5zbx8tkgze"><span class="c80">Avoiding Glitches</span></h3><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">These forks in the graph, however, might be a cause for concern. Let us see an even simpler example:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(&lt; seconds (add1 seconds))</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="calibre3">Let us first be clear about what we expect this to produce: we want it to always be </span><span class="c28">#true</span><span class="c4">.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">However, let us view how a simplistic dataflow graph evaluator might work. Here is the graph:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre51"><img alt="" src="image7.png" title="" class="calibre52"/></span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Suppose the value of </span><span class="c28">seconds</span><span class="calibre3"> updates to become 10. This value is pushed, as we would expect, to </span><span class="c7">both</span><span class="calibre3"> its </span><span class="c7">listeners</span><span class="calibre3">. This causes the </span><span class="c28">(add1 seconds)</span><span class="calibre3"> node to update its value from </span><span class="c28">10</span><span class="calibre3"> to </span><span class="c28">11</span><span class="calibre3">. However, the update to </span><span class="c28">seconds</span><span class="calibre3"> might have caused the comparison to occur immediately. At that point FrTime would be evaluating </span><span class="c28">(&lt; 10 10)</span><span class="calibre3">, which is clearly false. So for one instant this expression would evaluate to </span><span class="c28">#true</span><span class="calibre3">, before the update from </span><span class="c28">(add1 seconds)</span><span class="calibre3"> arrives and it reverts to </span><span class="c28">#false</span><span class="calibre3">. This is called a </span><span class="c7">glitch</span><span class="calibre3">, a term borrowed from the same phenomenon in </span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://en.wikipedia.org/wiki/Glitch&amp;sa=D&amp;source=editors&amp;ust=1695232021650816&amp;usg=AOvVaw2D-DrKG6J0VAjm-pDxm4Ri">electrical circuits</a></span><span class="c4">.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Avoiding glitches is actually quite simple. Rather than updating a node in this eager manner, FrTime schedules the graph to be updated in </span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://en.wikipedia.org/wiki/Topological_sorting&amp;sa=D&amp;source=editors&amp;ust=1695232021651423&amp;usg=AOvVaw17recAG9rHgwYI9lEViEXR">topographical order</a></span><span class="calibre3">. That ensures that no node will ever see old, or “stale”, values, and the expression will evaluate correctly. Of course, we can only apply topological sorting to directed </span><span class="c7">acyclic</span><span class="c4"> graphs, so handling cycles requires some additional work, which we do not discuss here.</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Exercise: </span><span class="c4">Make the above definition of non-linear graphs behave glitch-free.</span></p></body></html>
