<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.52l6s2rjm6u3"><span class="c4">Recovering Safety</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Fortunately, it does not take too much work to make the language safe again. What we’ve just written holds the key: every value needs to record what kind of value it is. And any use of that value needs to check that it’s the right kind of value. This information is called a </span><span class="c7">tag</span><span class="calibre3">; it takes a fixed amount of space, and represents </span><span class="c7">metadata</span><span class="c4"> about the subsequent datum. All subsequent values are interpreted in accordance with the tag.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">We need two tags for the two kinds of values. Let’s use</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define NUMBER-TAG 1337)</span></p><p class="c5"><span class="c41">(define STRING-TAG 5712)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">It’s important that the two tags be different, so they are unambiguous. However, we don’t need to worry about the tags themselves being confused with other data (e.g., numbers), because the tags will never be processed directly as program data (unless, of course, there is a bug in our implementation that accidentally does so…which is why language implementations need to be tested extensively).</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Now, when we allocate a number, we write its </span><span class="c7">tag</span><span class="c4"> into the first address, followed by the actual numeric value:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define (store-num n)</span></p><p class="c5"><span class="c28">  </span><span class="c65">(let ([a0 (write-and-bump NUMBER-TAG)])</span></p><p class="c5"><span class="c65">    (begin</span></p><p class="c5"><span class="c41">      (write-and-bump n)</span></p><p class="c5"><span class="c28">      </span><span class="c64">a0))</span><span class="c41">)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">And when we try to read a number, we </span><span class="c7">first</span><span class="calibre3"> check that it really </span><span class="c7">is</span><span class="c4"> a number, and only then obtain the actual numeric value:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define (safe-read-num a)</span></p><p class="c5"><span class="c28">  </span><span class="c65">(if (= (vector-ref MEMORY a) NUMBER-TAG)</span></p><p class="c5"><span class="c28">      (vector-ref MEMORY </span><span class="c64">(add1 </span><span class="c28">a</span><span class="c64">)</span><span class="c41">)</span></p><p class="c5"><span class="c28">      </span><span class="c64">(error 'number (number-&gt;string a)))</span><span class="c41">)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Strings are analogous:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define (store-str s)</span></p><p class="c5"><span class="c28">  (let ([a0 (write-and-bump </span><span class="c64">STRING-TAG</span><span class="c41">)])</span></p><p class="c5"><span class="c41">    (begin</span></p><p class="c5"><span class="c28">      </span><span class="c65">(write-and-bump (string-length s))</span></p><p class="c5"><span class="c41">      (map write-and-bump</span></p><p class="c5"><span class="c41">           (map char-&gt;integer (string-&gt;list s)))</span></p><p class="c5"><span class="c41">      a0)))</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">(define (safe-read-str a)</span></p><p class="c5"><span class="c28">  </span><span class="c65">(if (= (vector-ref MEMORY a) STRING-TAG)</span></p><p class="c5"><span class="c41">      (letrec ([loop</span></p><p class="c5"><span class="c41">                (lambda (count a)</span></p><p class="c5"><span class="c41">                  (if (zero? count)</span></p><p class="c5"><span class="c41">                      empty</span></p><p class="c5"><span class="c41">                      (cons (vector-ref MEMORY a)</span></p><p class="c5"><span class="c41">                            (loop (sub1 count) (add1 a)))))])</span></p><p class="c5"><span class="c41">        (list-&gt;string</span></p><p class="c5"><span class="c41">         (map integer-&gt;char</span></p><p class="c5"><span class="c28">              (loop (vector-ref MEMORY </span><span class="c64">(add1 </span><span class="c28">a</span><span class="c64">)</span><span class="c28">) (+ a </span><span class="c64">2</span><span class="c41">)))))</span></p><p class="c5"><span class="c28">      </span><span class="c64">(error 'string (number-&gt;string a)))</span><span class="c41">)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">So now, starting from a fresh memory, running</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(store-str "hello")</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">still produces </span><span class="c28">0</span><span class="calibre3">, but the content of </span><span class="c28">MEMORY</span><span class="c4"> looks a bit different:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c28">'#(</span><span class="c65">5712</span></p><p class="c5"><span class="c41">   5</span></p><p class="c5"><span class="c41">   104</span></p><p class="c5"><span class="c41">   101</span></p><p class="c5"><span class="c41">   108</span></p><p class="c5"><span class="c41">   108</span></p><p class="c5"><span class="c41">   111</span></p><p class="c5"><span class="c41">   -1</span></p><p class="c5"><span class="c41">   -1</span></p><p class="c5"><span class="c41">   -1</span></p><p class="c5"><span class="c41">   …)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">That is, at address </span><span class="c28">0</span><span class="calibre3"> we first encounter the tag for strings. Only then do we get the string’s length, followed by its contents. Observe that now, storing the length up front makes even more sense: the first two locations contain the tag and the length, both of which are metadata that help us interpret what comes later, with the second (the length) </span><span class="c7">refining</span><span class="c4"> the first (the tag).</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">With this change, the interpreter stays unchanged, and effectively so do the helpers, other than using the new names we’ve chosen:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define (num+ la ra)</span></p><p class="c5"><span class="c28">  (store-num (+ (</span><span class="c64">safe-</span><span class="c28">read-num la) (</span><span class="c64">safe-</span><span class="c41">read-num ra))))</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">(define (str++ la ra)</span></p><p class="c5"><span class="c28">  (store-str (string-append (</span><span class="c64">safe-</span><span class="c28">read-str la) (</span><span class="c64">safe-</span><span class="c41">read-str ra))))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">All our “good” tests still pass, but interestingly, our “bad” tests now fail:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(test/exn (calc (cat (num 1) (str "hello"))) "string")</span></p><p class="c5"><span class="c41">(test/exn (calc (plus (num 1) (str "hello"))) "number")</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Exercise: </span><span class="c4">You may notice the error message strings above have changed slightly. Why?</span></p></body></html>
