<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.ywpuswfihawr"><span class="c4">A Richer Example</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Using what we have learned, let us consider another Python example:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">def nats():</span></p><p class="c5"><span class="c41">  n = 0</span></p><p class="c5"><span class="c41">  while True:</span></p><p class="c5"><span class="c41">    yield n</span></p><p class="c5"><span class="c41">    n += 1</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">def odds():</span></p><p class="c5"><span class="c41">  ns = nats()</span></p><p class="c5"><span class="c41">  while True:</span></p><p class="c5"><span class="c41">    n = next(ns)</span></p><p class="c5"><span class="c41">    if n % 2:</span></p><p class="c5"><span class="c41">      yield n</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">g = odds()</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">next(g) + next(g) + next(g)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">This program has two distinct generator creators: the one we’ve already seen for natural numbers, and one more that filters the natural numbers to produce only odd numbers.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">We can now think of control proceeding as follows. First, we make an instance of </span><span class="c28">odds</span><span class="calibre3"> and bind it to </span><span class="c28">g</span><span class="calibre3">. This immediately creates an instance of </span><span class="c28">nats</span><span class="calibre3"> and binds it (within the instance of </span><span class="c28">odds</span><span class="calibre3">) to </span><span class="c28">ns</span><span class="c4">. Now all our generators are set up and ready to compute.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">We now begin the infinite loop in </span><span class="c28">odds</span><span class="c4">. This calls the natural number generator. At this point, the odd number generator’s local stack looks like</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">while True:</span></p><p class="c5"><span class="c41">  n = •</span></p><p class="c5"><span class="c41">  if n % 2:</span></p><p class="c5"><span class="c41">    yield n</span></p><p class="c5"><span class="calibre3">in an environment where </span><span class="c28">ns</span><span class="calibre3"> is bound to a generator and </span><span class="c28">n</span><span class="c4"> is uninitialized</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Because we have called a generator, not a function, computation now runs in that generator’s own stack. This is the natural number generator, which we have already studied. It binds </span><span class="c28">n</span><span class="calibre3"> to </span><span class="c28">0</span><span class="calibre3"> and then </span><span class="c28">yield</span><span class="c4">s, storing its local stack—</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">while True:</span></p><p class="c5"><span class="c41">  •</span></p><p class="c5"><span class="c41">  n += 1</span></p><p class="c5"><span class="calibre3">in an environment where </span><span class="c28">n</span><span class="calibre3"> is bound to </span><span class="c41">0</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">—and returning </span><span class="c28">0</span><span class="c4"> to the odd number generator.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">This resumes the odd generator’s stack. This binds n to 0 and performs the comparison. It fails, continuing the loop body:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">    n = next(ns)</span></p><p class="c5"><span class="c41">    if n % 2:</span></p><p class="c5"><span class="c41">      yield n</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Now we are again ready to invoke the natural number generator. The odd number generator’s </span><span class="c7">local</span><span class="calibre3"> stack is unchanged from before (same context, same environment, except this time the environment does have a binding for </span><span class="c28">n</span><span class="calibre3">, to </span><span class="c28">0</span><span class="c4">). Meanwhile, the natural’s generator resumes from</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">while True:</span></p><p class="c5"><span class="c41">  •</span></p><p class="c5"><span class="c41">  n += 1</span></p><p class="c5"><span class="calibre3">in an environment where </span><span class="c28">n</span><span class="calibre3"> is bound to </span><span class="c28">0</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">This increments </span><span class="c28">n</span><span class="c4"> and resumes the loop body:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">    yield n</span></p><p class="c5"><span class="c41">    n += 1</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">This immediately causes it to yield </span><span class="c28">1</span><span class="c4">, leaving the stack</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">while True:</span></p><p class="c5"><span class="c41">  •</span></p><p class="c5"><span class="c41">  n += 1</span></p><p class="c5"><span class="calibre3">in an environment where </span><span class="c28">n</span><span class="calibre3"> is bound to </span><span class="c41">1</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">This resumes the odd generator’s stack. This binds </span><span class="c28">n</span><span class="calibre3"> to </span><span class="c28">1</span><span class="c4">, so the conditional succeeds. Therefore, the stack at the point of yielding becomes</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">  while True:</span></p><p class="c5"><span class="c41">    n = next(ns)</span></p><p class="c5"><span class="c41">    if n % 2:</span></p><p class="c5"><span class="c41">      •</span></p><p class="c5"><span class="calibre3">in an environment where </span><span class="c28">ns</span><span class="calibre3"> is bound to a generator and </span><span class="c28">n</span><span class="calibre3"> is bound to </span><span class="c41">1</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">This completes the first call to </span><span class="c28">next(g)</span><span class="c4">, enabling the top-level stack frame to have the context</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">1 + • + next(g)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">From this, we can see the next two computations will produce </span><span class="c28">3</span><span class="calibre3"> and </span><span class="c28">5</span><span class="calibre3">, and hence the total of </span><span class="c28">9</span><span class="c4">.</span></p><p class="c3"><span class="c4"></span></p></body></html>
