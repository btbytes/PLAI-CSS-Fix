<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.vji0kba4jcxk"><span class="c4">Generalizing Macros</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Finally, unlike the poor programmers stuck with their infix syntaxes and binary operators, parenthetical syntax programmers can generalize constructs to arbitrary arity. We’ve seen </span><span class="c28">…</span><span class="calibre3"> already; let’s put it to work here to create an </span><span class="c7">n</span><span class="calibre3">-ary </span><span class="c28">or</span><span class="c4">. A natural first definition is</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define-syntax orN</span></p><p class="c5"><span class="c41">  (syntax-rules ()</span></p><p class="c5"><span class="c41">    [(_ e1 e2 ...)</span></p><p class="c5"><span class="c41">     (let ([v e1])</span></p><p class="c5"><span class="c41">       (if v v (orN e2 ...)))]))</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Do Now:</span><span class="c4"> However,  see what happens when we try:</span></p><p class="c51"><span class="c4"></span></p><p class="c77"><span class="c41">(let ([v true])</span></p><p class="c77"><span class="c41">  (orN false v))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Okay, so that doesn’t work. It’s important to pay attention to the error message:</span></p><p class="c3"><span class="c72"></span></p><p class="c5"><span class="c78">orN: bad syntax in: (orN)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">This highlights the need for a base case. The problem is our definition above requires one or more sub-expressions: </span><span class="c28">e1</span><span class="calibre3"> is the first, and </span><span class="c28">e2 …</span><span class="calibre3"> means </span><span class="c7">zero or more</span><span class="c4"> from the second position onward. But nothing covers the case of no sub-terms. So we need</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define-syntax orN</span></p><p class="c5"><span class="c41">  (syntax-rules ()</span></p><p class="c5"><span class="c41">    [(_) false]</span></p><p class="c5"><span class="c41">    [(_ e1 e2 ...)</span></p><p class="c5"><span class="c41">     (let ([v e1])</span></p><p class="c5"><span class="c28">       (if v v (orN e2 ...)))]))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">and of course this works fine.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c40">Exercise: </span><span class="calibre3">The problem above appears to have been self-inflicted: why did we start with the pattern </span><span class="c28">(_ e1 e2 ...)</span><span class="calibre3">, which requires one-or-more (</span><span class="c28">e1</span><span class="calibre3"> is the first, </span><span class="c28">e2 …</span><span class="calibre3"> is zero or more)? We should have just written </span><span class="c28">(_ e...)</span><span class="calibre3"> instead, which would be zero-or-more! Rewrite the </span><span class="c28">orN</span><span class="c4"> macro using this pattern: can you make it work?</span></p></body></html>
