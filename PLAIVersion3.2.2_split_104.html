<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.yg4pidy7mny2"><span class="c4">Assume-Guarantee Reasoning</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">There is a delicate dance going on between these typing rules for application and definition (now updated to have the environment). We’ll use colors to highlight this:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c97">Γ </span><span class="c28">|- F : </span><span class="c100">(T -&gt; U)</span><span class="c28">    Γ |- A : </span><span class="c101">T</span></p><p class="c5"><span class="c41">-------------------------------</span></p><p class="c5"><span class="c97">Γ </span><span class="c28">|- (F A) : U</span></p><p class="c3"><span class="c4"></span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c97">Γ[V &lt;- </span><span class="c102">T</span><span class="c97">] </span><span class="c41">|- B : U</span></p><p class="c5"><span class="c41">--------------------------------</span></p><p class="c5"><span class="c97">Γ </span><span class="c28">|- (lambda V : T B) : </span><span class="c100">(T -&gt; U)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">The rule for </span><span class="c28">lambda</span><span class="calibre3"> </span><span class="c7">assumes</span><span class="calibre3"> the parameter will be given a value of type </span><span class="c103">T</span><span class="calibre3">; the application rule </span><span class="c7">guarantees</span><span class="calibre3"> that that the actual parameter will indeed have the expected type. The application rule </span><span class="c7">assumes</span><span class="calibre3"> that the function, if given a </span><span class="c28">T</span><span class="calibre3">, will produce a </span><span class="c28">U</span><span class="calibre3"> (because the type is </span><span class="c100">(T -&gt; U)</span><span class="calibre3">); the </span><span class="c28">lambda</span><span class="calibre3"> rule </span><span class="c7">guarantees</span><span class="c4"> that the function will indeed perform that way.</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Aside:</span><span class="calibre3"> The notation </span><span class="c28">(T -&gt; U)</span><span class="calibre3"> is not chosen at random. The </span><span class="c28">-&gt;</span><span class="calibre3"> may remind you of the notation for implication in mathematics. That’s intentional. We can read the type as “giving the function a </span><span class="c28">T</span><span class="calibre3"> implies that it will produce a </span><span class="c28">U</span><span class="calibre3">” (not giving it a </span><span class="c28">T</span><span class="calibre3"> implies nothing about what it will do…). It is that </span><span class="c7">implication</span><span class="c4"> that is assumed in the application rule, and that is guaranteed by the rule for lambda.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">This assume-guarantee reasoning shows up in many places, so look out for this pattern in other places as well.</span></p></body></html>
