<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.3z5a2cqtcvbr"><span class="c4">Structuring Our Study</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">As I have argued in greater length </span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/sk-teach-pl-post-linnaean/&amp;sa=D&amp;source=editors&amp;ust=1695232021063528&amp;usg=AOvVaw37Mi6t9TcyPiWLJtD_NsvH">elsewhere</a></span><span class="calibre3">, it is more meaningful to think of programming languages as aggregates of </span><span class="c7">features</span><span class="c4">. The features are the building blocks. Of course, once combined, languages are more like compounds than like mixtures: the features interact in ways that may not be easy to predict. Understanding both the features and their compositions is then a valuable way to approach a language.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">The book revolves around a central idea, </span><span class="c7">SMoL</span><span class="c4">, the Standard Model of Languages. This is the embodiment of the computational core of many of our widely-used programming languages, from C# and Java to JavaScript, Lua, Python, and Ruby to OCaml and Racket. The astute reader will notice that this commonality pays no respect to “paradigms”. Rather, all these languages (and many others), to a large extent, have a common computational core: safe runtime systems, automated memory management, eager evaluation, first-class lexically-scoped functions, first-order mutable variables, and first-class mutable structures. Contemporary programming demands a deep understanding of these. For instance, I believe you cannot make sense of concurrency with mutation, static members, or ownership, without understanding SMoL.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">However, because languages are artificial and programming is an almost infinitely malleable material, even “standard” features have historically seen variation. Therefore, while we progress </span><span class="c7">across</span><span class="calibre3"> features, we also want to study variation </span><span class="c7">within</span><span class="calibre3"> them. We do this by using the </span><span class="c26"><a class="c11" href="https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/pkf-teach-pl-exp-adv-think/&amp;sa=D&amp;source=editors&amp;ust=1695232021064466&amp;usg=AOvVaw0VIwT72D0WNabBksW4GD3x">mystery language</a></span><span class="calibre3"> approach: with a fixed syntax, we explore the different ways the same feature can behave. This hopes to build on the cognitive theory of </span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://www.cultofpedagogy.com/contrasting-cases/&amp;sa=D&amp;source=editors&amp;ust=1695232021064751&amp;usg=AOvVaw1sitvi37D-BaEv1xrf6erl">contrasting cases</a></span><span class="calibre3"> to improve learning</span><span class="c4">.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">What goes in SMoL is, of course, a judgment call: when a feature isn’t present across a large number of diverse languages (like static types), or shows too much variation between languages (like objects), I argue that it’s no longer part of the </span><span class="c7">standard</span><span class="calibre3"> model. But it is not a </span><span class="c7">value</span><span class="c4"> judgment: in this book we explore SMoL in some depth,  then turn our attention to several non-“standard” features that are not only important but also beautiful and fascinating.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Turning to implementation, the book provides another pillar: </span><span class="c7">SImPl</span><span class="c4">, the Standard Implementation Plan. This is the idea that programming languages are usefully thought of in terms of an abstract syntax tree; this tree is represented well by an algebraic datatype; and a program that processes this tree is a recursive function that is largely guided by the structure of the type. This level of description encompasses both the standard media for evaluation, interpreters and compilers. It also captures the essence of type-checkers, type inference, static analysis, and more. Thus, students should gain facility with this structure for when they want to implement their own language experiments.</span></p></body></html>
