<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.ls7b0qafb55w"><span class="c4">Typing Recursion</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">What went wrong above? The problem is that each application “uses up an arrow” in a function type; because a program text must be finite, it can contain at most a finite number of “arrows”, so eventually the program must terminate. To get around this, we need a way to effectively have an “infinite quiver”.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">We typically do this by adding a recursive function construct to the language, and create a custom type for it. Let’s start with a type rule for the analogous, but simpler, </span><span class="c28">let</span><span class="c4">:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c97">Γ </span><span class="c28">|- E : T    </span><span class="c97">Γ[V &lt;- T] </span><span class="c41">|- B : U</span></p><p class="c5"><span class="c41">--------------------------------</span></p><p class="c5"><span class="c97">Γ </span><span class="c28">|- (let V : T E B) : U</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Note that we’re going to expect an annotation in </span><span class="c28">let</span><span class="calibre3"> for the same reason we do for function definitions. So this says that we’ll check that </span><span class="c28">E</span><span class="calibre3"> actually does have the type promised in the declaration, </span><span class="c28">T</span><span class="calibre3">; when we extend the type environment with the </span><span class="c28">V</span><span class="calibre3"> having type </span><span class="c28">T</span><span class="calibre3">, if the body </span><span class="c28">B</span><span class="calibre3"> produces type </span><span class="c28">U</span><span class="c4">, then that’s the type of the whole expression.</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Aside:</span><span class="c4"> Notice that there’s an assume-guarantee pair in the antecedent: the first term is guaranteeing the annotation, which the second term is assuming.</span></p><p class="c51"><span class="c4"></span></p><p class="c31"><span class="c40">Aside:</span><span class="calibre3"> Technically, the type of </span><span class="c28">E</span><span class="calibre3"> could be </span><span class="c7">calculated</span><span class="calibre3">. Therefore, the </span><span class="c28">T</span><span class="c4"> annotation is not strictly necessary.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Observe that this is basically the type rule we would get from expanding the syntactic sugar for </span><span class="c28">let</span><span class="calibre3">. Therefore, this still doesn’t let us write a recursive definition. We need something more. Let’s introduce a new construct, </span><span class="c28">rec</span><span class="calibre3">, for recursive definitions. An example of a </span><span class="c28">rec</span><span class="c4"> (in an untyped setting) might be</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(rec ([inf-loop (lambda (n) (inf-loop n))])</span></p><p class="c5"><span class="c41">  (inf-loop 0))</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">(rec ([fact (lambda (n) (if (zero? n) 1 (* n (fact (- n 1)))))])</span></p><p class="c5"><span class="c41">  (fact 10))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">In the typed world, we’ll want rec to have the form</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c28">(rec V : T E B)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">so we’d instead have to write</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(rec inf-loop : (Number -&gt; Number)</span></p><p class="c5"><span class="c41">     (lambda (n) (inf-loop n))</span></p><p class="c5"><span class="c41">  (inf-loop 0))</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">(rec fact : (Number -&gt; Number)</span></p><p class="c5"><span class="c41">     (lambda (n) (if (zero? n) 1 (* n (fact (- n 1)))))</span></p><p class="c5"><span class="c28">  (fact 10))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">where </span><span class="c28">V</span><span class="calibre3"> is </span><span class="c28">fact</span><span class="calibre3">, </span><span class="c28">T</span><span class="calibre3"> is </span><span class="c28">(Number -&gt; Number)</span><span class="calibre3">, </span><span class="c28">E</span><span class="calibre3"> is the big </span><span class="c28">lambda</span><span class="calibre3"> term, and </span><span class="c28">B</span><span class="calibre3"> is </span><span class="c28">(fact 10)</span><span class="c4">.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">So this introduces a recursive definition, and then uses it. How might we type this?</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c97">???</span></p><p class="c5"><span class="c41">------------------------</span></p><p class="c5"><span class="c97">Γ </span><span class="c28">|- (rec V : T E B) : U</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Well, clearly one part of it must be the same: we have to type the body in the extended environment, and the environment must be extended with the annotated type:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c97">???    Γ[V &lt;- T] </span><span class="c41">|- B : U</span></p><p class="c5"><span class="c41">-------------------------</span></p><p class="c5"><span class="c97">Γ </span><span class="c28">|- (rec V : T E B) : U</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">We also know that we need to confirm that the annotation is correct:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c97">??? </span><span class="c28">|- E : T</span><span class="c97">    Γ[V &lt;- T] </span><span class="c41">|- B : U</span></p><p class="c5"><span class="c41">----------------------------------</span></p><p class="c5"><span class="c97">Γ </span><span class="c28">|- (rec V : T E B) : U</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">But clearly, </span><span class="c7">something</span><span class="calibre3"> needs to be different, otherwise we’ve just reproduced </span><span class="c28">let</span><span class="calibre3">. Look at the example use of </span><span class="c28">rec</span><span class="calibre3">: the </span><span class="c28">E</span><span class="calibre3"> term also needs to have </span><span class="c28">V</span><span class="calibre3"> bound in it! In other words, both </span><span class="c28">E</span><span class="calibre3"> and </span><span class="c28">B</span><span class="c4"> are typed in the same environment:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c97">Γ[V &lt;- T] </span><span class="c28">|- E : T</span><span class="c97">    Γ[V &lt;- T] </span><span class="c41">|- B : U</span></p><p class="c5"><span class="c41">----------------------------------------</span></p><p class="c5"><span class="c97">Γ </span><span class="c28">|- (rec V : T E B) : U</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">From the type, we can read off how the recursion happens: the extended environment for </span><span class="c28">B</span><span class="calibre3"> </span><span class="c7">initiates</span><span class="calibre3"> the recursion, while that for </span><span class="c28">E</span><span class="calibre3"> </span><span class="c7">sustains</span><span class="calibre3"> it. Essentially, the environment of </span><span class="c28">E</span><span class="c4"> enables arbitrary recursive depth.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">In short, to obtain arbitrary recursion—and hence infinite loops—we have to add a special construct to the language and its type-checker; we cannot obtain it just through desugaring. Once we add </span><span class="c28">rec</span><span class="c4"> to the STLC, however, we obtain a conventional programming language again.</span></p><p class="c3"><span class="c4"></span></p><p class="c3"><span class="c4"></span></p></body></html>
