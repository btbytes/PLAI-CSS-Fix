<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.9ovtdfd2w9ci"><span class="c4">Nominal Subtyping</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">We’ve been writing a bit gingerly about Java above: because we know that the </span><span class="c28">m</span><span class="calibre3"> method will accept not only </span><span class="c28">mt</span><span class="calibre3">’s but also anything that is a sub-class of </span><span class="c28">mt</span><span class="c4">. Let’s explore this further.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">To simplify things, let’s make some basic classes:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">class A { String who = "A"; }</span></p><p class="c5"><span class="c41">class B extends A { String who = "B"; }</span></p><p class="c5"><span class="c41">class C extends A { String who = "C"; }</span></p><p class="c5"><span class="c41">class D { String who = "D"; }</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">We’ll also create a shell “runner”:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">class Main {</span></p><p class="c5"><span class="c41"> public static void main(String[] args) {</span></p><p class="c5"><span class="c41">   System.out.println((true ? _____ : _____).who);</span></p><p class="c5"><span class="c41"> }</span></p><p class="c5"><span class="c41">}</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">and try filling in different values for the blanks and seeing what output we get:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c28">System.out.println((true ? </span><span class="c64">new B()</span><span class="c28"> : </span><span class="c64">new B()</span><span class="c41">).who);</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Unsurprisingly, this prints </span><span class="c28">"B"</span><span class="c4">. What about:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c28">System.out.println((true ? </span><span class="c64">new B()</span><span class="c28"> : </span><span class="c64">new A()</span><span class="c41">).who);</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">You might expect this to also print </span><span class="c28">"B"</span><span class="calibre3">, because that’s the value that we created. However, it actually prints </span><span class="c28">"A"</span><span class="c4">! Let’s see a few more examples:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c28">System.out.println((true ? </span><span class="c64">new B()</span><span class="c28"> : </span><span class="c64">new C()</span><span class="c41">).who);</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Will this print </span><span class="c28">"B"</span><span class="calibre3">? No, in fact, this also prints </span><span class="c28">"A"</span><span class="c4">! How about:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c28">System.out.println((true ? </span><span class="c64">new B()</span><span class="c28"> : </span><span class="c64">new D()</span><span class="c41">).who)</span></p><p class="c5"><span class="c28">System.out.println((true ? </span><span class="c64">new B()</span><span class="c28"> : </span><span class="c64">3</span><span class="c41">).who)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Both of these produce a static error. It’s instructive to read the error message: in both cases they reference </span><span class="c28">Object</span><span class="calibre3">. In the former case, it’s because there is nothing else common to B and D. But in the latter case, the primitive value 3 was effectively converted into an object—</span><span class="c28">new Integer(3)</span><span class="c4">—and those two object types were compared.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">What is happening in the type system that causes this error? The cause is documented here:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html%23jls-15.25.3&amp;sa=D&amp;source=editors&amp;ust=1695232021502810&amp;usg=AOvVaw13Y12I72q4_WhlbdEUkvSr">https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.25.3</a></span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Specifically, the document says:</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c4">The type of the conditional expression is the result of applying capture conversion (§5.1.10) to lub(T1, T2).</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">where “lub” stands for “least upper bound”: the “lowest” class “above” all the given ones. This type is determined </span><span class="c7">statically</span><span class="c4">. That is, the type rule is essentially:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c97">Γ </span><span class="c28">|- C : Bool    </span><span class="c97">Γ </span><span class="c28">|- T : V    </span><span class="c97">Γ </span><span class="c41">|- E : W    X = lub(V, W)</span></p><p class="c5"><span class="c41">----------------------------------------------------------</span></p><p class="c5"><span class="c97">Γ </span><span class="c28">|- (if C T E) : X</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Contrast this to the other rules we’ve seen for conditionals! The first type rule we saw was the most rigid, but produced the most usable values (because there was no ambiguity). The second type rule, for union types, was less rigid, but as a result the output type could have a union that needed to be split. This type rule is even less rigid (in terms of what the two branches produce), but the result could be as general as </span><span class="c28">Object</span><span class="c4">, with which we can do almost nothing.</span></p></body></html>
