<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.3jmxv1l9d9nw"><span class="c4">State</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Many people believe that objects primarily exist to encapsulate state.</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Aside:</span><span class="calibre3"> Curiously, Alan Kay, who won a Turing Award for inventing Smalltalk and modern object technology, disagrees. In </span><span class="c26"><a class="c11" href="https://www.google.com/url?q=http://worrydream.com/EarlyHistoryOfSmalltalk/&amp;sa=D&amp;source=editors&amp;ust=1695232021277736&amp;usg=AOvVaw2Jq9XZtuuo6438N_xh50ZK">The Early History of Smalltalk</a></span><span class="c4">, he says, “[t]he small scale [motivation for OOP] was to find a more flexible version of assignment, and then to try to eliminate it altogether”. He adds, “It is unfortunate that much of what is called ‘object-oriented programming’ today is simply old style programming with fancier constructs. Many programs are loaded with ‘assignment-style’ operations now done by more expensive attached procedures.”</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">We certainly haven’t lost that ability. If we desugar to a language with variables, we can easily have multiple methods mutate common state, such as a constructor argument:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define (mk-o-state count)</span></p><p class="c5"><span class="c41">  (lambda (m)</span></p><p class="c5"><span class="c41">    (case m</span></p><p class="c5"><span class="c41">      [(inc) (lambda () (set! count (+ count 1)))]</span></p><p class="c5"><span class="c41">      [(dec) (lambda () (set! count (- count 1)))]</span></p><p class="c5"><span class="c41">      [(get) (lambda () count)])))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">We have changed the name to </span><span class="c28">mk-o-…</span><span class="calibre3"> to reflect the fact that this is an object-</span><span class="c7">maker</span><span class="c4">, i.e., analogous to a class. For instance, we can test a sequence of operations:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(test (let ([o (mk-o-state 5)])</span></p><p class="c5"><span class="c41">        (begin (msg o 'inc)</span></p><p class="c5"><span class="c41">                   (msg o 'inc)</span></p><p class="c5"><span class="c41">               (msg o 'dec)</span></p><p class="c5"><span class="c41">               (msg o 'get)))</span></p><p class="c5"><span class="c41">      6)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">and also notice that mutating one object doesn’t affect another:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(test (let ([o1 (mk-o-state 3)]</span></p><p class="c5"><span class="c41">            [o2 (mk-o-state 3)])</span></p><p class="c5"><span class="c41">        (begin (msg o1 'inc)</span></p><p class="c5"><span class="c41">               (msg o1 'inc)</span></p><p class="c5"><span class="c41">               (+ (msg o1 'get)</span></p><p class="c5"><span class="c41">                  (msg o2 'get))))</span></p><p class="c5"><span class="c28">      (+ 5 3))</span></p></body></html>
