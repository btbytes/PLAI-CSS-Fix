<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.w7cavichendz"><span class="c4">Algebraic Datatypes Encoded With Nominal Types</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">We’ll take a different approach. Observe from the datatype definition that we have two constructors, and one type that represents their union. We can encode this in Java as:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">abstract class BT {</span></p><p class="c5"><span class="c41">  abstract public int size();</span></p><p class="c5"><span class="c41">}</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">class mt extends BT {</span></p><p class="c5"><span class="c41">  public int size() {</span></p><p class="c5"><span class="c41">    return 0;</span></p><p class="c5"><span class="c41">  }</span></p><p class="c5"><span class="c41">}</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">class node extends BT {</span></p><p class="c5"><span class="c41">  int v;</span></p><p class="c5"><span class="c41">  BT l, r;</span></p><p class="c5"><span class="c41">  node(int v, BT l, BT r) {</span></p><p class="c5"><span class="c41">    this.v = v;</span></p><p class="c5"><span class="c41">    this.l = l;</span></p><p class="c5"><span class="c41">    this.r = r;</span></p><p class="c5"><span class="c41">  }</span></p><p class="c5"><span class="c41">  public int size() {</span></p><p class="c5"><span class="c41">    return 1 + this.l.size() + this.r.size();</span></p><p class="c5"><span class="c41">  }</span></p><p class="c5"><span class="c41">}</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">class Main {</span></p><p class="c5"><span class="c41">  public static void main(String[] args) {</span></p><p class="c5"><span class="c41">    BT t = new node(5, new node(3, new mt(), new mt()), new mt());</span></p><p class="c5"><span class="c41">    System.out.println(t.size());</span></p><p class="c5"><span class="c41">  }</span></p><p class="c5"><span class="c41">}</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">How is the “if-splitting” addressed here? It’s done in a hidden way, through dynamic dispatch. When we invoke a method, Java makes sure we run the right method: there are actually two concrete </span><span class="c28">size</span><span class="calibre3"> methods, and the run-time picks the right one. Once that choice is made, the class in which the method resides automatically determines what is bound. Thus, the </span><span class="c28">size</span><span class="calibre3"> in </span><span class="c28">node</span><span class="calibre3"> can safely use </span><span class="c28">this.l</span><span class="calibre3"> and </span><span class="c28">this.r</span><span class="c4">, and the type-checker knows that those fields exist.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">This is, then, similar to, yet different from, our two prior solutions: using algebraic datatypes and union types. The solutions are structurally different, but they are all similar in that some </span><span class="c7">syntactic</span><span class="c4"> pattern must be used to make the program statically type-able. With algebraic datatypes, it was pattern-matching; with union types, it was if-splitting; in Java, it’s the splitting of the code into separate methods.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">The algebraic datatype and Java solutions are even more connected than we might imagine. With algebraic datatypes, we fixed the set of variants; but we were free to add new functions </span><span class="c7">without having to edit existing code</span><span class="calibre3">. In Java, we fix the set of behaviors (above, one method), but can add new variants without having to edit existing code. Therefore, neither has an inherent advantage over the other, and one’s strengths are the other’s weakness. How to do </span><span class="c7">both</span><span class="calibre3"> at once is the essence of the </span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://en.wikipedia.org/wiki/Expression_problem&amp;sa=D&amp;source=editors&amp;ust=1695232021492211&amp;usg=AOvVaw3l4_wQP5pOCFZHndfQMdbX">Expression Problem</a></span><span class="calibre3">. See also the concrete examples and approaches given in these two papers, one focusing on a </span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/kff-synth-fp-oo/&amp;sa=D&amp;source=editors&amp;ust=1695232021492633&amp;usg=AOvVaw2Xm1yq3fY2pVUVr5sWjXEr">Java-based approach</a></span><span class="calibre3"> and another </span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/kf-ext-sw-def/&amp;sa=D&amp;source=editors&amp;ust=1695232021492914&amp;usg=AOvVaw0SbXWoMkkqB5ySEJa9jMG3">function-centric</a></span><span class="c4">.</span></p></body></html>
