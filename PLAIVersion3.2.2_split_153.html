<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.low2y8msmm0b"><span class="c4">Strictness Points</span></h2><p class="c5"><span class="c4">Coming back to our example from earlier: when we run such a program in a language with lazy evaluation, when, if ever, does all this arithmetic resolve and print a value?</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Before we answer that question, let us also observe that sometimes programs can’t really defer decisions indefinitely. For instance, consider this program:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(deffun (f x)</span></p><p class="c5"><span class="c41">  (if (even? x)</span></p><p class="c5"><span class="c41">      7</span></p><p class="c5"><span class="c41">      11))</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">(f (+ 2 3))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">What happens when we try to evaluate it? Presumably substitution reduces this to</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(if (even? (+ 2 3))</span></p><p class="c5"><span class="c41">    7</span></p><p class="c5"><span class="c41">    11)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">and now what? Presumably that could be considered “the answer”, but that doesn’t seem very useful; and in real programs, these terms would just grow larger and larger. Furthermore, suppose the program were</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(deffun (fact n)</span></p><p class="c5"><span class="c41">  (if (zero? n)</span></p><p class="c5"><span class="c41">      1</span></p><p class="c5"><span class="c41">      (* n (fact (- n 1)))))</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">(fact 5)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">We can certainly produce as an answer</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">  (if (zero? 5)</span></p><p class="c5"><span class="c41">      1</span></p><p class="c5"><span class="c41">      (* 5 (fact (- 5 1)))))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">but…then what? And for that matter, what is </span><span class="c28">fact</span><span class="c4"> in this response? This does not seem like a very useful programming language.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Instead, lazy programming languages define certain points in the language as </span><span class="c7">strictness</span><span class="calibre3"> points, which are points where expressions are forced to compute and produce an answer. Different choices of strictness points will result in languages that behave slightly differently. Conventionally, the following are considered </span><span class="c7">useful</span><span class="c4"> strictness points:</span></p><p class="c3"><span class="c4"></span></p><ol class="c136" start="1"><li class="pcalibre20 c137"><span class="c4">The conditional portion of a conditional expression. This enables the language to determine which branch to take and which branch to ignore.</span></li><li class="pcalibre20 c137"><span class="c4">Arithmetic. This avoids long chains of computations building up.</span></li><li class="pcalibre20 c137"><span class="c4">The printer in an interactive environment. This makes the environment useful.</span></li></ol><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">All three of these are </span><span class="c7">pragmatic</span><span class="c4"> choices. Notice that our first example above concerned the top-level printer, while the second example has to do with conditionals.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Because of these strictness points, a typical lazy language will in fact compute the programs we have seen above very similarly to an eager language. To get to something that really differentiates eagerness from laziness, we need to get to richer programs.</span></p></body></html>
