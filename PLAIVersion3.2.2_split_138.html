<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.gsr5owruw55z"><span class="c4">Nominal Types</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">The type system in Java is representative of an entire class of languages. These have </span><span class="c7">nominal</span><span class="calibre3"> types, which means the </span><span class="c7">name</span><span class="calibre3"> of a class matters. (“Nominal” comes from the Latin </span><span class="c7">nomen</span><span class="c4">, or name.) It’s easiest to explain with an example.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Above we have the following class:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">class mt extends BT {</span></p><p class="c5"><span class="c41">  public int size() {</span></p><p class="c5"><span class="c41">    return 0;</span></p><p class="c5"><span class="c41">  }</span></p><p class="c5"><span class="c41">}</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Let’s now suppose we create another class that is identical in every respect but its name:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">class empty extends BT {</span></p><p class="c5"><span class="c41">  public int size() {</span></p><p class="c5"><span class="c41">    return 0;</span></p><p class="c5"><span class="c41">  }</span></p><p class="c5"><span class="c41">}</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Let’s say we have a method that takes </span><span class="c28">mt</span><span class="c4"> objects:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">class Main {</span></p><p class="c5"><span class="c41">  static int m(mt o) {</span></p><p class="c5"><span class="c41">    return o.size();</span></p><p class="c5"><span class="c41">  }</span></p><p class="c5"><span class="c41">  public static void main(String[] args) {</span></p><p class="c5"><span class="c41">    System.out.println(m(new mt()));</span></p><p class="c5"><span class="c41">  }</span></p><p class="c5"><span class="c41">}</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">But observe that </span><span class="c28">empty</span><span class="calibre3"> is a perfectly good substitute for </span><span class="c28">mt</span><span class="calibre3">: it too has a </span><span class="c28">size</span><span class="calibre3"> method, which too takes no arguments, and it too returns an </span><span class="c28">int</span><span class="c4"> (in fact, the very same value). Therefore, we try:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">class Main {</span></p><p class="c5"><span class="c41">  static int m(mt o) {</span></p><p class="c5"><span class="c41">    return o.size();</span></p><p class="c5"><span class="c41">  }</span></p><p class="c5"><span class="c41">  public static void main(String[] args) {</span></p><p class="c5"><span class="c28">    System.out.println(m(new </span><span class="c64">empty</span><span class="c41">()));</span></p><p class="c5"><span class="c41">  }</span></p><p class="c5"><span class="c41">}</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">But Java rejects this. That’s because it expects an object that was constructed by the actual class </span><span class="c28">mt</span><span class="calibre3">, not just one that “looks like” it. That is, what matters is which actual (named) class, not what </span><span class="c7">structure</span><span class="c4"> of class, created the value.</span></p></body></html>
