<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h1 class="c22" id="h.pywusgfikk5t"><span class="c4">Control on the Web</span></h1><h2 class="c23" id="h.sunhzwthclo6"><span class="c4">Server-Side Programming</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Consider a program like this:</span></p><p class="c3"><span class="c138"></span></p><p class="c5"><span class="c138">print(read("First number") + read("Second number")) </span></p><p class="c3"><span class="c138"></span></p><p class="c5"><span class="calibre3">Imagine we were to run this program on a traditional command-line operating system. What happens when we call </span><span class="c28">read</span><span class="calibre3">? The operating system’s </span><span class="c7">synchronous</span><span class="calibre3"> input-reading commands are invoked: synchronous meaning that the program suspends its execution—that is, the stack stays intact—waiting for the user to respond (if ever they do), and when they do, the program’s stack resumes, with the value typed in by the user becoming the value returned by </span><span class="c28">read</span><span class="c4">.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">This seems so straightforward that we might never think twice about how remarkable this ability is. To understand that, we should try to run this program on the Web. When we do, we run headlong into a central problem on the Web: that there is no such thing as a “</span><span class="c139">read</span><span class="c4">” operation. Why not?</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">On the Web, a hypothetical </span><span class="c28">read</span><span class="calibre3"> function can certainly send the prompt to the client. In principle, it should then wait for the client to respond with a value, which it returns. However, the </span><span class="c7">stateless</span><span class="calibre3"> nature of the Web means that this can’t happen: the program has to terminate. This is an </span><span class="c7">asynchronous</span><span class="c4"> operation. When the user responds (if they ever do), there is no computation waiting to go back to.</span></p><h3 class="c79" id="h.9i3mwy68n5ed"><span class="c80">Recording Contexts</span></h3><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Therefore, a Web computation has to be arranged in a very different way. The programmer must manually remember the rest of the computation, and store it somewhere. For instance, we would break up the above program in the following way: what is going to be done next:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c138">read("First number")</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">and what is waiting for the result:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c138">print(• + read("Second number")) </span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">(This is, of course, our old friend, a context.) But whereas the context is implicit on the program’s stack, because the program must terminate, the context needs to be written out explicitly. Of course, • is not a program operation; rather, we can think of the context as a function of one argument:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c139">lam(•</span><span class="c140">1</span><span class="c139">): print(•</span><span class="c140">1</span><span class="c139"> + read("Second number")) </span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">and this is the function that is stored in a way associated with the outgoing prompt. Then, when (if) the user responds, their response value is bound to </span><span class="c139">•</span><span class="c140">1</span><span class="calibre3">, allowing the program to resume. Suppose, for instance, the user types </span><span class="c28">5</span><span class="c4">. Then this program effectively becomes</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c139">print(5 + read("Second number"))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">This needs to also perform a Web interaction, so we again split it into what must happen now</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c139">read("Second number")</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">and what is waiting for the result:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c139">print(5 + •)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">which we can represent as a function:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c139">lam(•</span><span class="c140">2</span><span class="c139">): print(5 + •</span><span class="c140">2</span><span class="c139">)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">If and when the user resumes, this function is applied to the value they supply, and the result prints as we would expect.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">This explanation glosses over some important details. Real program evaluation, as we have seen, does not proceed by rewriting programs, so the second function is not really</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c139">lam(•</span><span class="c140">2</span><span class="c139">): print(5 + •</span><span class="c140">2</span><span class="c139">)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">but rather a </span><span class="c7">closure</span><span class="c4"> with the body</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c139">lam(•</span><span class="c140">2</span><span class="c139">): print(•</span><span class="c140">1</span><span class="c139"> + •</span><span class="c140">2</span><span class="c139">)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">closed over an environment where </span><span class="c139">•</span><span class="c140">1</span><span class="calibre3"> is bound to </span><span class="c139">5</span><span class="calibre3">. Getting into these details is interesting from a Web architecture perspective, but for us, all we care about is that </span><span class="c7">contexts must be saved and restored</span><span class="c4">.</span></p><h3 class="c79" id="h.t2bpf83zez8o"><span class="c80">Simulating in the Stacker</span></h3><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">We can simulate the above using the Stacker, provided we forego the input operation and pretend it always returns some constant:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">#lang stacker/smol/hof</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">(deffun (get-number s)</span></p><p class="c5"><span class="c41">  5)</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">(+ (get-number "first") (get-number "second"))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">At the point of the second call, we see that the state looks like this:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre33"><img alt="" src="image23.png" title="" class="calibre34"/></span></p></body></html>
