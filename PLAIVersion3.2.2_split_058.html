<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.jq7c4mh1czs0"><span class="c4">Local Binding</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Now let’s look at the </span><span class="c28">let</span><span class="calibre3"> bindings we’ve been using until now. Imagine we want to extend Racket with a </span><span class="c28">let1</span><span class="c4"> construct: for example, we want</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(let1 (x 3) (+ x x))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">to evaluate to 6.</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Do Now:</span><span class="calibre3"> Can </span><span class="c28">let1</span><span class="c4"> be defined as a function? Why or why not?</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c28">let1</span><span class="calibre3"> can’t be a function. If it were, we would first try to evaluate each of the sub-terms as arguments. There are two things here that look like argument expressions: </span><span class="c28">(x 3)</span><span class="calibre3"> and </span><span class="c28">(+ x x)</span><span class="calibre3">. Suppose we try to </span><span class="c7">evaluate</span><span class="calibre3"> </span><span class="c28">(x 3)</span><span class="calibre3">. First of all, it looks like an application. Second, </span><span class="c28">x</span><span class="calibre3"> isn’t even bound. Third, there is no meaningful “value” it could produce: its only job is instead to </span><span class="c7">bind</span><span class="calibre3"> </span><span class="c28">x</span><span class="calibre3">. No, </span><span class="c28">let1</span><span class="c4"> is also a new piece of syntax.</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Terminology:</span><span class="calibre3"> We will often refer to these new pieces of syntax as </span><span class="c7">constructs</span><span class="calibre3"> (as in, “a new language construct”). In the Lisp/Scheme/Racket community, these are sometimes also called </span><span class="c7">special forms</span><span class="c4">, because they are syntactic forms with their own special rules for binding and evaluation.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">From now on we’ll use the prefix </span><span class="c28">my-</span><span class="c4"> on our macros, because we don’t want to clash with the names of macros already built into Racket.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">From what we’ve seen above, we can probably figure out half of the macro for </span><span class="c28">my-let1</span><span class="c4">:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define-syntax my-let1</span></p><p class="c5"><span class="c41">  (syntax-rules ()</span></p><p class="c5"><span class="c41">    [(my-let1 (var val) body)</span></p><p class="c5"><span class="c41">     …]))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">But what would it </span><span class="c28">expan</span><span class="calibre3">d into? We certainly </span><span class="c7">could</span><span class="calibre3"> just expand it into the existing </span><span class="c28">let</span><span class="c4"> construct in Racket, but there’s another interesting option.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Let’s think about what </span><span class="c28">my-let1</span><span class="calibre3"> does: it </span><span class="c7">binds</span><span class="calibre3"> a name to a value, and then immediately </span><span class="c7">evaluates</span><span class="calibre3"> its body in an environment extended by its name. Now, can we think of anything else that binds names to values? Yes, functions. And functions evaluate a body in an extended environment. When do functions evaluate their body? When they are applied to an argument. Therefore, we can express </span><span class="c28">my-let1</span><span class="c4"> in terms of an anonymous function that is applied immediately:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define-syntax my-let1</span></p><p class="c5"><span class="c41">  (syntax-rules ()</span></p><p class="c5"><span class="c41">    [(my-let1 (var val) body)</span></p><p class="c5"><span class="c41">     ((lambda (var) body) val)]))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Sure enough,</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(my-let1 (x 3) (+ x x))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">will produce </span><span class="c28">6</span><span class="c4">. Use the Macro Stepper to see how!</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Terminology:</span><span class="calibre3"> This pattern, of an anonymous function that is used right away, is commonly called </span><span class="c7">left-left-lambda</span><span class="calibre3"> (where “left” stands for left-parenthesis). For a long time this remained an obscure term in the Lisp/Scheme community. But JavaScript made this pattern popular again under the name </span><span class="c7">Immediately Invoked Function Expression</span><span class="c4"> (IIFE), because of problems with the handling of scope in earlier versions of the language. If you think the parentheses look bad here, look up some examples of IIFE on the Web.</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Exercise:</span><span class="c4"> Suppose we make a mistake in the macro and swap two parts:</span></p><p class="c51"><span class="c4"></span></p><p class="c31"><span class="c41">(define-syntax my-let1</span></p><p class="c31"><span class="c41">  (syntax-rules ()</span></p><p class="c31"><span class="c41">    [(my-let1 (var val) body)</span></p><p class="c31"><span class="c41">     ((lambda (var) val) body)]))</span></p><p class="c51"><span class="c4"></span></p><p class="c31"><span class="c4">What happens when we try to evaluate</span></p><p class="c51"><span class="c4"></span></p><p class="c31"><span class="c41">(my-let1 (x 3) (+ x x))</span></p><p class="c51"><span class="c4"></span></p><p class="c31"><span class="c4">? Use the Macro Stepper to see what happened.</span></p></body></html>
