<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h1 class="c29" id="h.zgb2717gs5tn"><span class="c4"></span></h1><h1 class="c30" id="h.knlcyhi1mjgt"><span class="c4">Evaluation on Paper</span></h1><h2 class="c23" id="h.s35mokq31e72"><span class="c4">Evaluators</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">We’re trying to implement a programming language: that is, to write an </span><span class="c7">evaluator</span><span class="calibre3"> (i.e., something that “reduces programs to values”). It helps if we can first understand how </span><span class="calibre3">evaluation</span><span class="c4"> works on paper, before we start dealing with computer complexities.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Before we get into the details, it’s worth knowing that there are broadly speaking two kinds of evaluators (as well as many combinations of them). They follow very different strategies:</span></p><p class="c3"><span class="c4"></span></p><ul class="c24"><li class="c25 pcalibre"><span class="calibre3">An </span><span class="c7">interpreter</span><span class="calibre3"> consumes a program and </span><span class="c7">simulates</span><span class="c7"> its execution</span><span class="c4">. That is, the interpreter does what we would expect “running the program” should do.</span></li><li class="c25 pcalibre"><span class="calibre3">A </span><span class="c7">compiler</span><span class="calibre3"> consumes a program and </span><span class="c7">produces another program</span><span class="c4">. That output program must then be further evaluated.</span></li></ul><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">That is, an interpreter maps programs in some language </span><span class="c7">L</span><span class="c4"> to values:</span></p><p class="c3"><span class="c4"></span></p><p class="c8"><span class="calibre3">interpreter :: Program</span><span class="c36">L</span><span class="c4"> → Value</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">We leave open exactly what a </span><span class="c7">value</span><span class="c4"> is for now, informally understanding it to be an answer the user would want to see—put differently, something that either cannot or does not need to be further e-valu-ated. In contrast,</span></p><p class="c3"><span class="c4"></span></p><p class="c8"><span class="calibre3">compiler :: Program</span><span class="c36">L</span><span class="calibre3"> → Program</span><span class="c37">T</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">That is, a compiler from </span><span class="c7">L</span><span class="calibre3"> to </span><span class="c7">T</span><span class="calibre3"> (we use </span><span class="c7">T</span><span class="calibre3"> for “target”) consumes programs in </span><span class="c7">L</span><span class="calibre3"> and produces programs in </span><span class="c7">T</span><span class="calibre3">. We aren’t saying about how this </span><span class="c7">T</span><span class="c4"> program must be evaluated. It may be interpreted directly, or it may be further compiled. For instance, one can compile a Scheme program to C. The C program may be interpreted directly, but it may very well be compiled to assembly. However, we can’t keep compiling ad infinitum: at the bottom, there must be some kind of interpreter (e.g., in the computer’s hardware) to provide answers.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Note that interpreters and compilers are themselves programs written in some language and must themselves run. Naturally, this can lead to interesting ideas and problems.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">In our study, we will focus primarily on interpreters, but also see a very lightweight form of compilers. Interpreters are useful because:</span></p><p class="c3"><span class="c4"></span></p><ol class="c38" start="1"><li class="c39 pcalibre2"><span class="c4">A simple interpreter is often much easier to write than a compiler.</span></li><li class="c39 pcalibre2"><span class="c4">Debugging an interpreter can sometimes be much easier than debugging a compiler.</span></li></ol><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Therefore, they provide a useful “baseline” implementation technology that everyone can reach for. Compilers can often take an entire course of study.</span></p></body></html>
