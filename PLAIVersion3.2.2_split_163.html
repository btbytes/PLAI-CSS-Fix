<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.tbnq99ytq7iw"><span class="c4">Abstracting the Problem</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Thus, we have the same problem on both the server and client sides of the Web. The reasons are very different, but the net effect is the same: the programmer has to manually keep track of information that needs to persist, store it somewhere, halt the computation to return control to whatever called it and, when resumed, fetch information back from storage; all this code must run exactly as if an interruption had never occurred.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">This programming quandary is not new. Back in the early days of computing, programmers had to manually keep track of where in memory values resided; then we got compilers that did this for us. Then we had to manually keep track of allocation on the heap to later reclaim it; then we got garbage collectors to do this for us. The history of programming languages is full of tasks that programmers did manually until we learned to create language constructs and compilers that could do these automatically. It would be nice if we could do the same here to reduce the burden of writing such programs.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">To study these phenomena better, it would be helpful if we could abstract away from the details of servers, clients, JavaScript, Web pages, timeouts, and so on, and examine the phenomenon in its essence.</span></p><h3 class="c79" id="h.anpfmtebwmjm"><span class="c80">Using Closures</span></h3><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">We can simulate the solution by assuming a new primitive, </span><span class="c28">get-number/k</span><span class="calibre3">. Instead of taking one argument, the prompt string, it also takes a second argument. This second argument is a closure that represents the </span><span class="c7">rest</span><span class="calibre3"> of the computation—i.e., it’s the stack represented as a closure. This function binds that closure to a variable, </span><span class="c28">resume</span><span class="c4">, and then…does nothing:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(defvar yielder #false)</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">(deffun (get-number/k s rest)</span></p><p class="c5"><span class="c41">  (set! resume rest))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Recall that we want the program to invoke this function and then halt; all remaining computation—the context—needs to be in the second parameter given to </span><span class="c28">get-number/k</span><span class="c4">. Thus, our program now looks like this:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(get-number/k "first"</span></p><p class="c5"><span class="c41">              (λ (•1)</span></p><p class="c5"><span class="c41">                (get-number/k "second"</span></p><p class="c5"><span class="c41">                              (λ (•2)</span></p><p class="c5"><span class="c41">                                (+ •1 •2)))))</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Terminology: </span><span class="calibre3">The second argument—embodying the entire rest of the computation—is called the </span><span class="c7">continuation</span><span class="calibre3">, and it’s traditional to use the letter </span><span class="c28">k</span><span class="c4"> for it.</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Terminology: </span><span class="calibre3">The program structure above has been turned inside-out: instead of the first operation being innermost and last operation outermost, the first one is outermost and the last one is innermost. This unwieldy program structure has a name: </span><span class="c7">inversion of control</span><span class="calibre3">. Instead of the client calling the helper function whose values it wants (in this case, </span><span class="c28">get-number</span><span class="calibre3">), the helper function (in this case </span><span class="c28">get-number/k</span><span class="c4">) calls the client. This leads to an unnatural, unwieldy, and error-prone programming style.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Sure enough, when we run this program, it just…halts with no output. It is instructive to look at the state of the program when it ends:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre35"><img alt="" src="image5.png" title="" class="calibre36"/></span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Notice that </span><span class="c28">resume</span><span class="c4"> is bound to a function that is awaiting a number. If we invoke it:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(resume 5)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">then our state (unfortunately, we had to re-run the program) becomes:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre37"><img alt="" src="image15.png" title="" class="calibre38"/></span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Observe that resume is now bound to a closure whose environment remembers the value of </span><span class="c28">•1</span><span class="c4">. If we now resume again:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(resume 7)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">the “program” halts naturally, with an output of </span><span class="c28">12</span><span class="c4">! (We use quotes around “program” because we have really fragmented our simple program into three: one that gets the prompts for the first input, one that remembers that value and prompts for the second, and the third that sums those two values.)</span></p><h3 class="c79" id="h.jsygzmm9gzkk"><span class="c80">Using Racket</span></h3><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4"> It turns out that Racket also has tools for manipulating continuations.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Imagine we have two tabs in DrRacket. In the first (let’s suppose we save it as </span><span class="c28">"yielder.rkt"</span><span class="c4">) we have the following mysterious program:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">#lang racket</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">(provide yield resume)</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">(define resumer #false)</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">(define (yield)</span></p><p class="c5"><span class="c41">  (let/cc k</span></p><p class="c5"><span class="c41">    (set! resumer k)</span></p><p class="c5"><span class="c41">    (raise 'yield)))</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">(define (resume)</span></p><p class="c5"><span class="c41">  (resumer 'dummy))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">The operation </span><span class="c28">let/cc</span><span class="calibre3"> binds the named variable (here, </span><span class="c28">k</span><span class="c4">) to a continuation value: it turns the current stack into a value that can be treated as a function.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">In another tab, we will write a simple program that pretends to be our long-running computation: a factorial function. We can run this directly in Racket, of course. But </span><span class="c28">fact</span><span class="calibre3"> could run for a very long time, depending on the input; so following the rules of JavaScript, we want it to halt periodically, let’s say every time </span><span class="c28">n</span><span class="calibre3"> is divisible by </span><span class="c28">5</span><span class="c4"> (i.e., roughly every five iterations). That is, we would like to run:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">#lang racket</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">(require "yielder.rkt")</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">(define (fact n)</span></p><p class="c5"><span class="c41">  (if (= n 0)</span></p><p class="c5"><span class="c41">      1</span></p><p class="c5"><span class="c41">      (if (zero? (modulo n 5))</span></p><p class="c5"><span class="c41">          (begin</span></p><p class="c5"><span class="c41">            (yield)</span></p><p class="c5"><span class="c41">            (* n (fact (- n 1))))</span></p><p class="c5"><span class="c41">          (* n (fact (- n 1))))))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">where </span><span class="c28">(yield)</span><span class="calibre3"> makes it pause in a way that, when we run </span><span class="c28">(resume)</span><span class="c4">, the computation will pick up exactly where it left off. Indeed, we see the following outcome:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">&gt; (fact 7)</span></p><p class="c5"><span class="c41">uncaught exception: 'yield</span></p><p class="c5"><span class="c41">&gt; (resume)</span></p><p class="c5"><span class="c41">5040</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">The first time it yields is when </span><span class="c28">n</span><span class="calibre3"> is </span><span class="c28">5</span><span class="calibre3">. Yielding, in this case, means </span><span class="c7">terminating</span><span class="c4"> the computation using the Racket exception mechanism. Resuming somehow causes computation to continue and run to completion but, remarkably, it produces the exact same answer as if computation had never halted at all!</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Observe that thanks to the use of </span><span class="c28">let/cc</span><span class="calibre3">, we have been able to invert the inverted control, i.e., write the program in what is called </span><span class="c7">direct style</span><span class="calibre3">. The language has taken care of storing and restoring the computation without the user program having to do it manually. Thus, continuations are useful tools for inverting inverted control. We will also see another language mechanism that does this: </span><span class="c71"><a class="c11" href="https://www.google.com/url?q=https://docs.google.com/document/d/1ECyFV88K-jU-i0qHLfUNjbIYthChzpcjZ0eiostD3d8/edit%23&amp;sa=D&amp;source=editors&amp;ust=1695232021608622&amp;usg=AOvVaw1WfaeEjiDupGmDBj0AuHdK">Non-SMoL: Reactivity</a></span><span class="c4">.</span></p></body></html>
