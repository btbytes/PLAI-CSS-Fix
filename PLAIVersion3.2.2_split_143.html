<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.wtk3zpm1lfas"><span class="c4">Micro Versus Macro</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">In gradual typing, we are going to add annotations to programs and then type-check the program. Within this broad principle, there are two schools of thought.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">In “micro” gradual typing we can add annotations to any subset of the variables of the language. We saw this earlier in the Static Python example:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c28">def insort_right(a, x, lo: int = 0, hi: Optional[int] = None):</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Here, we have annotations on </span><span class="c28">lo</span><span class="calibre3"> and </span><span class="c28">hi</span><span class="calibre3">, but not on </span><span class="c28">a</span><span class="calibre3"> and </span><span class="c28">x</span><span class="calibre3">. Ergonomically, this is very convenient for the programmer: use annotations for the parts you care about, and not for the parts you don’t. Unfortunately, this comes at a cost: there is now a much more complex language where any parts of a program can be static and any other parts dynamic, and they can freely commingle in the same body of code, even in a single expression or line (e.g., from the same example: </span><span class="c28">hi = len(a)</span><span class="calibre3">). The type system needs to somehow deal with constructs it cannot meaningfully type (like </span><span class="c28">eval</span><span class="c4">). Also, previously we had a clean and simple soundness result for the typed program; now it is rather unclear what soundness means. In turn, that means that programmers may put a lot of effort into annotations, but without a clear guarantee of what they are getting in return. (A large body of literature now tries to make sense of this.)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">In contrast, there is another approach, often called “macro” gradual typing. In the macro approach, there are </span><span class="c7">two languages</span><span class="calibre3">: the typed and the dynamic one. They are expected to be very similar—so similar that they have the same run-time system and can freely share values—so we’ll refer to them as “sibling” languages. However, they may not have the same constructs (e.g., the typed language would not contain </span><span class="c28">eval</span><span class="calibre3">). Instead of freely mixing code between typed and untyped, we only have to figure out what happens when values travel </span><span class="c7">between</span><span class="c4"> the languages, not within each one. The expectation is that the programmer will gradually migrate part of their codebase from the dynamic to the typed language, typically a function at a time. Each language can import code from the other, but when importing into typed code, the programmer must specify a type for the imported code.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">A canonical example of this approach is Typed Racket. Because Typed Racket is one of the oldest and most developed gradually typed languages (technically, it’s the </span><span class="c7">combination</span><span class="c4"> of Racket and Typed Racket that is gradually typed—Typed Racket itself is fully typed), and also offers some of the most interesting perspective on what happens when values travel between languages, we will use that as our exemplar for study.</span></p></body></html>
