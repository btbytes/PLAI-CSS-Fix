<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.nhsl7b7sr2h5"><span class="c4">Static Scoping</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">The program</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">{let1 {x 1}</span></p><p class="c5"><span class="c41">  {+ {let1 {x 2} x}</span></p><p class="c5"><span class="c28">     x}}</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">introduces us to a very important concept: indeed, one of the central ideas behind SMoL. This is that a variable’s binding is determined by </span><span class="c7">its position in the source program</span><span class="calibre3">, and </span><span class="c40">not</span><span class="calibre3"> by </span><span class="c7">the order of the program’s execution</span><span class="calibre3">. That is, the </span><span class="c28">x</span><span class="c4"> on the last line is bound by the same place—and hence obtains the same value—irrespective of other bindings that took place before it was evaluated. To understand this better, let’s see a progression of programs:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">{let1 {x 1}</span></p><p class="c5"><span class="c41">  {+ {let1 {x 2} x}</span></p><p class="c5"><span class="c28">     x}}</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">You might think it’s okay whether it produces </span><span class="c28">3</span><span class="calibre3"> or </span><span class="c28">4</span><span class="c4">. How about this?</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">{let1 {x 1}</span></p><p class="c5"><span class="c41">  {+ {if true</span></p><p class="c5"><span class="c41">         {let1 {x 2} x}</span></p><p class="c5"><span class="c41">         4}</span></p><p class="c5"><span class="c28">      x}}</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">You should expect the same out of this: the conditional is always true, so clearly we are always going to evaluate the inner binding, so its answer should be the same as for the previous program. But how about this?</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">{let1 {x 1}</span></p><p class="c5"><span class="c41">  {+ {if true</span></p><p class="c5"><span class="c41">         4</span></p><p class="c5"><span class="c28">         </span><span class="c64">{let1 {x 2} x}</span><span class="c41">}</span></p><p class="c5"><span class="c28">      x}}</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Now you might not be so sure. Since the conditional is never taken, you probably don’t want the inner binding to have an influence. That is, you are willing to </span><span class="c7">let the program’s control flow influence the bindings</span><span class="c4">. On its face that sounds reasonable, but now how about this program?</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">{let1 {x 1}</span></p><p class="c5"><span class="c28">  {+ {if </span><span class="c65">{random}</span></p><p class="c5"><span class="c41">         4</span></p><p class="c5"><span class="c41">         {let1 {x 2} x}}</span></p><p class="c5"><span class="c28">      x}}</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">or</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">{let1 {x 1}</span></p><p class="c5"><span class="c28">  {+ {if </span><span class="c65">{moon-is-currently-full}</span></p><p class="c5"><span class="c41">         4</span></p><p class="c5"><span class="c41">         {let1 {x 2} x}}</span></p><p class="c5"><span class="c28">      x}}</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Are you okay with the binding structure changing every two weeks? What about this version:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">{let1 {x 1}</span></p><p class="c5"><span class="c41">  {+ {if {moon-is-currently-full}</span></p><p class="c5"><span class="c41">         4</span></p><p class="c5"><span class="c28">         {let1 {</span><span class="c64">y</span><span class="c41"> 2} x}}</span></p><p class="c5"><span class="c28">      </span><span class="c64">y</span><span class="c28">}}</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Then, depending on the phase of the moon, the program either produces an answer or results in an unbound-variable error.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">The decision to let control flow determine binding is called </span><span class="c7">dynamic scope</span><span class="calibre3">. It is the one </span><span class="c40">unambiguously wrong</span><span class="c4"> design decision in programming languages. It has a long and sordid history: the original Lisp had it, and it was not until over a decade later that Scheme fixed it. Unfortunately, those who don’t know history are doomed to repeat it: early versions of Python and JavaScript also had dynamic scope. Taking it back out has been a herculean effort. Dynamic scope means:</span></p><p class="c3"><span class="c4"></span></p><ul class="c24"><li class="c25 pcalibre"><span class="c4">We can’t be sure about the binding structure of our programs.</span></li><li class="c25 pcalibre"><span class="c4">The evaluator can’t be sure, either.</span></li><li class="c25 pcalibre"><span class="c4">Nor can programmer tools.</span></li></ul><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">For instance, a program refactoring tool needs to know binding structure: even a simple “variable renaming” tool needs to know which variables to rename. In DrRacket, there is no ambiguity, so variable renaming works correctly. This is not true in other languages: see, for instance, Appendix 2 of </span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/pmmwplck-python-full-monty/&amp;sa=D&amp;source=editors&amp;ust=1695232021187018&amp;usg=AOvVaw137u3e7Dklg2SwW_JHiS7q">this paper</a></span><span class="c4"> on the semantics of Python.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">The opposite of dynamic scope—where we can determine the binding by following the structure of the AST—is called </span><span class="c7">static scope</span><span class="c4">. Static scope is a defining characteristic of SMoL.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Dynamic scope occurred in early implementations because it was easy to obtain: it was the default behavior. We have to work a bit harder to obtain static scope, as we will see.</span></p></body></html>
