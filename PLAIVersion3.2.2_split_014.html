<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.7dcc43hwd5bt"><span class="c4">Terminology</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">It is common, on the Web, to read people speak of “interpreted languages” and “compiled languages”. These terms are </span><span class="c40">nonsense</span><span class="calibre3">. That isn’t just a judgment; that’s a literal statement: they do not make sense. Interpretation and compilation are techniques one uses to evaluate programs. A </span><span class="c7">language</span><span class="c4"> (almost) never specifies how it should be evaluated. As a result, each implementer is free to choose whatever strategy they want.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Just as an example, C is often chosen as a canonically “compiled language”, while Scheme is often presented as an “interpreted language”. However, there have been (a handful of) interpreters for C; indeed, I used one when I first learned C. Likewise, there are numerous compilers for Scheme; I used one when I first learned Scheme. Python has several interpreters and compilers.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Furthermore, this seemingly hard distinction is frequently broken down in practice. Many languages now have a “JIT”, which stands for </span><span class="c7">just-in-time</span><span class="c4"> compilation. That is, the evaluator starts out as an interpreter. If it finds itself interpreting the same code over and over, it compiles it and uses the compiled code instead. When and how to do this is a complex and fascinating topic, but it makes clear that the distinction is not a bright line.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Some people are confused by the </span><span class="c7">interface</span><span class="calibre3"> that an implementation presents. Many languages provide a </span><span class="c7">read-eval-print loop</span><span class="calibre3"> (REPL), i.e., an interactive interface. It is often easier for an interpreter to do this. However, many systems with such an interface accept code at a prompt, compile it, run it, and present the answer back to the user; they mask all these steps. Therefore, the interface is not an indicator of what kind of implementation you are seeing. It is perhaps meaningful to refer to an </span><span class="c7">implementation</span><span class="c4"> as “interactive” or “non-interactive”, but that is not a reflection of the underlying language.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">In short, please remember: </span></p><ul class="c24"><li class="c25 pcalibre"><span class="c4">(Most) Languages do not dictate implementations. Different platforms and other considerations dictate what implementation to use. </span></li><li class="c25 pcalibre"><span class="c4">Implementations usually use one of two major strategies—interpretation and compilation—but many are also hybrids of these.</span></li><li class="c25 pcalibre"><span class="calibre3">A specific implementation may offer an interactive or non-interactive interface. However, this does </span><span class="c7">not</span><span class="c4"> automatically reveal the underlying implementation strategy.</span></li><li class="c25 pcalibre"><span class="c4">Therefore, the terms “interpreted language” and “compiled language” are nonsensical.</span></li></ul></body></html>
