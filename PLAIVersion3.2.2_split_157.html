<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.7faoga2ntna1"><span class="c4">Laziness and Side-Effects</span></h2><p class="c5"><span class="c4">Given the (potential) benefits of lazy evaluation, why is laziness not more widely used?</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">The problem is that laziness makes it much harder to predict what will happen in programs that use state. Therefore, popular lazy languages do not have state, or have it in very controlled forms. (This is not a bad thing! State </span><span class="c7">should</span><span class="c4"> only be used in very controlled ways, and Haskell, for instance, has very interesting designs that help with that. But programmers have traditionally expected to have unfettered access to state.)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Consider, for instance, the following pair of functions:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define (f x y)</span></p><p class="c5"><span class="c41">  (g x y))</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">(define (g x y)</span></p><p class="c5"><span class="c41">  (if (zero? (random 2)) x y))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">On their own, they seem harmless. However, now consider this call:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(f (print "X") (print "Y"))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">In an eager language, we know both strings would be printed right away. However, in a lazy language, only one will, and we cannot tell which one. To understand which, we can no longer treat </span><span class="c28">f</span><span class="calibre3"> as an abstraction but instead have to peer into its implementation, which in turn forces us to examine the source of </span><span class="c28">g</span><span class="c4"> as well. We would have to examine every call, and track all the strictness points along the way, to determine which effects will occur and when. Here is another example:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define n 0)</span></p><p class="c5"><span class="c41">(f (set! n (add1 n)) (set! n (sub1 n)))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Again, if we ran this eagerly, we know </span><span class="c28">n</span><span class="calibre3"> would be set back to </span><span class="c28">0</span><span class="calibre3"> before the body of </span><span class="c28">f</span><span class="calibre3"> even begins to evaluate. In lazy evaluation, we cannot be sure what value </span><span class="c28">n</span><span class="calibre3"> will have: it could be </span><span class="c28">-1</span><span class="calibre3"> or </span><span class="c28">1</span><span class="calibre3">. Furthermore if, tomorrow, </span><span class="c28">g</span><span class="c4"> were altered to be</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define (g x y)</span></p><p class="c5"><span class="c41">  (if (zero? (random 2)) "X" "Y"))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">then </span><span class="c28">n</span><span class="calibre3"> remains </span><span class="c28">0</span><span class="c4">—but we can’t know without examining its code!</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">A natural reaction to reading these programs might be, “Don’t do that!” That is in fact an entirely legitimate reaction. The problem is not laziness: it’s the interaction between laziness and state. As we deprecate the use of unfettered state in programming, that increases the potential for laziness. Still, there are other situations—like errors—that we cannot avoid, and that can stay latent under lazy evaluation.</span></p></body></html>
