<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.n8627oz7x8jd"><span class="c4">How Many Unions?</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">When we wrote an algebraic datatype, the variants â€œbelongedâ€ to the new type. We had no mechanism for mixing-and-matching variants.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">In contrast, with union types, a new type is a collection of existing types. Thereâ€™s nothing that prevents those existing types from engaging in several different unions. For instance, we had</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define-type-alias BT (U mt node))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">But we could also write, say,</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(struct link ((v : Number) (r : LinkedList)))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">and reusing mt to define</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define-type-alias LinkedList (U mt link))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Therefore, given an mt, what â€œisâ€ it? Is it a </span><span class="c28">BT</span><span class="calibre3">? A </span><span class="c28">LinkedList</span><span class="calibre3">? Itâ€™s all those, but itâ€™s also just an </span><span class="c28">mt</span><span class="calibre3">, which can participate in any number of unions. This provides a degree of flexibility that we donâ€™t get with algebraic datatypesâ€”since we can create ad-hoc unions of existing typesâ€”but that also means it becomes harder to tell all the ways a value might be used, and also complicates inferring types (if we see an </span><span class="c28">mt</span><span class="calibre3">Â constructed, are we also constructing a </span><span class="c28">BT</span><span class="calibre3">? a </span><span class="c28">LinkedList</span><span class="calibre3">?). The Hindley-Milner inference algorithm [</span><span class="c16"><a class="c11" href="PLAIVersion3.2.2_split_115.html#h.bheym24u3ntv">ğŸ‘‰</a></span><span class="c4">] doesnâ€™t cover these cases, though it can be extended to do so.</span></p></body></html>
