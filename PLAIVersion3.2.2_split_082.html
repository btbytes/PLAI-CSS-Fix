<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.1d8viljk9g71"><span class="c4">What (Goes In) Else?</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Until now, our case statements have not had an </span><span class="c28">else</span><span class="calibre3"> clause. One reason to do so would be if we had a variable set of members in an object, though that is probably better handled through a different representation than a conditional: a hash-table, for instance, as we’ve discussed above. In contrast, if an object’s set of members is fixed, desugaring to a conditional works well for the purpose of illustration (because it </span><span class="c7">emphasizes</span><span class="calibre3"> the fixed nature of the set of member names, which a hash table leaves open to interpretation—and also error). There is, however, another reason for an </span><span class="c28">else</span><span class="calibre3"> clause, which is to “chain” control to another, parent, object. This is called </span><span class="c7">inheritance</span><span class="c4">.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Let’s return to our model of desugared objects. To implement inheritance, the object must be given “something” to which it can delegate method invocations that it does not recognize. A great deal will depend on what that “something” is.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">One answer could be that it is simply another object:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(case m</span></p><p class="c5"><span class="c41">  ...</span></p><p class="c5"><span class="c41">  [else (parent-object m)])</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Due to our representation of objects, this application effectively searches for the member in the parent object (and, presumably, recursively in its parents). If a member matching the name is found, it returns through this chain to the original call in </span><span class="c28">msg</span><span class="c4"> that sought the member. If none is found, the final object presumably signals a “message not found” error.</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Exercise:</span><span class="calibre3"> If you know what an l-value is, then you might notice that the application </span><span class="c28">(parent-object m)</span><span class="calibre3"> is like “half a </span><span class="c28">msg</span><span class="c4">”, just like an l-value was “half a value lookup”. Is there any connection?</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Let’s try this by extending our trees to implement another method, </span><span class="c28">size</span><span class="calibre3">. We’ll write an “extension” (you may be tempted to say “sub-class”, but hold off for now!) for each </span><span class="c28">node</span><span class="calibre3"> and </span><span class="c28">mt</span><span class="calibre3"> to implement the </span><span class="c28">size</span><span class="calibre3"> method. We intend these to extend the existing definitions of </span><span class="c28">node</span><span class="calibre3"> and </span><span class="c28">mt</span><span class="c4">, so we’ll use the extension pattern described above. In other words, if we previously had the rough equivalent of this Java code:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">class Mt   { … Mt()          { … } sum() { … } }</span></p><p class="c5"><span class="c41">class Node { … Node(v, l, r) { … } sum() { … } }</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">now we want to extend it:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">class MtSize   extends Mt   { … size() { … } … }</span></p><p class="c5"><span class="c41">class NodeSize extends Node { … size() { … } … }</span></p><p class="c3"><span class="c4"></span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Aside:</span><span class="c4"> We’re not editing the existing definitions because that is supposed to be the whole point of object inheritance: to reuse code in a black-box fashion. This also means different parties, who do not know one another, can each extend the same base code. If they had to edit the base, first they have to find out about each other, and in addition, one might dislike the edits of the other. Inheritance is meant to sidestep these issues entirely.</span></p><p class="c51"><span class="c4"></span></p><p class="c31"><span class="c40">Aside: </span><span class="calibre3">Relatedly, read about the </span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://en.wikipedia.org/wiki/Fragile_base_class&amp;sa=D&amp;source=editors&amp;ust=1695232021308845&amp;usg=AOvVaw0jUQoyWZ_AaVZEFstRRSte">fragile base class problem</a></span><span class="c4">.</span></p></body></html>
