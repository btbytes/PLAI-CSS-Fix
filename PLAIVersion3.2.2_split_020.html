<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.4auhy7kmddwe"><span class="c4">Representing Abstract Syntax</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">In the rest of this book, except where indicated otherwise, we will implement things in the </span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://docs.racket-lang.org/plait/index.html&amp;sa=D&amp;source=editors&amp;ust=1695232021101325&amp;usg=AOvVaw1V2YliLbtsEZqqySfseP61">plait</a></span><span class="c4">  language of Racket. Please make sure you have plait installed to follow along.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">We will create a new tree datatype in plait to represent ASTs. In the sentence diagram above, the leaves of the tree are words, and the nodes are grammatical terms. In our AST, the leaves will be numbers, while the nodes will be operations on the trees representing each sub-expression. For now, we have only one operation: addition. Here’s how we can represent this in plait syntax:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define-type Exp</span></p><p class="c5"><span class="c41">  [num (n : Number)]</span></p><p class="c5"><span class="c41">  [plus (left : Exp) (right : Exp)])</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">This says:</span></p><ul class="c24"><li class="c25 pcalibre"><span class="calibre3">We are defining a new type, </span><span class="c41">Exp</span></li><li class="c25 pcalibre"><span class="calibre3">There are two ways of making an </span><span class="c41">Exp</span></li><li class="c25 pcalibre"><span class="calibre3">One way is through the constructor </span><span class="c28">num</span><span class="c4">:</span></li></ul><ul class="c24"><li class="pcalibre4 c44"><span class="calibre3">A </span><span class="c28">num</span><span class="c4"> takes one argument</span></li><li class="pcalibre4 c44"><span class="c4">That argument must be an actual number</span></li></ul><ul class="c24"><li class="c25 pcalibre"><span class="calibre3">The other way is through the constructor </span><span class="c28">plus</span><span class="c4">:</span></li></ul><ul class="c24"><li class="pcalibre4 c44"><span class="calibre3">A </span><span class="c28">plus</span><span class="c4"> takes two arguments</span></li><li class="pcalibre4 c44"><span class="calibre3">Both arguments must be </span><span class="c28">Exp</span><span class="c4">s</span></li></ul><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">If it helps as you read what follows, this is very analogous to the following Java pseudocode skeleton (or the analog with Python dataclasses):</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">abstract class Exp {}</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">class num extends Exp {</span></p><p class="c5"><span class="c41">  num(Number n) { … }</span></p><p class="c5"><span class="c41">}</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">class plus extends Exp {</span></p><p class="c5"><span class="c41">  plus(Exp left, Exp right) { … }</span></p><p class="c5"><span class="c41">}</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Let’s look at how some of the previous examples would be represented:</span></p><p class="c3"><span class="c4"></span></p><a id="t.7e7a6924b39ce95ba03385693fa214c74c96fe81"></a><a id="t.0"></a><table class="c45"><tbody class="calibre14"><tr class="c46"><td class="c47" colspan="1" rowspan="1"><p class="c48"><span class="c49">Surface Syntax</span></p></td><td class="c47" colspan="1" rowspan="1"><p class="c48"><span class="c49">AST</span></p></td></tr><tr class="c46"><td class="c47" colspan="1" rowspan="1"><p class="c5"><span class="c28">1</span></p></td><td class="c47" colspan="1" rowspan="1"><p class="c50"><span class="c41">(num 1)</span></p></td></tr><tr class="c46"><td class="c47" colspan="1" rowspan="1"><p class="c5"><span class="c28">2.3</span></p></td><td class="c47" colspan="1" rowspan="1"><p class="c50"><span class="c41">(num 2.3)</span></p></td></tr><tr class="c46"><td class="c47" colspan="1" rowspan="1"><p class="c5"><span class="c28">1 + 2</span></p></td><td class="c47" colspan="1" rowspan="1"><p class="c50"><span class="c41">(plus (num 1) (num 2))</span></p></td></tr><tr class="c46"><td class="c47" colspan="1" rowspan="1"><p class="c5"><span class="c28">(1 + 2) + 3</span></p></td><td class="c47" colspan="1" rowspan="1"><p class="c50"><span class="c41">(plus (plus (num 1) (num 2))</span></p><p class="c50"><span class="c41">      (num 3))</span></p></td></tr><tr class="c46"><td class="c47" colspan="1" rowspan="1"><p class="c5"><span class="c41">1 + (2 + 3)</span></p></td><td class="c47" colspan="1" rowspan="1"><p class="c50"><span class="c41">(plus (num 1)</span></p><p class="c50"><span class="c41">      (plus (num 2) (num 3)))</span></p></td></tr><tr class="c46"><td class="c47" colspan="1" rowspan="1"><p class="c5"><span class="c41">1 + ((2 + 3) + 4)</span></p></td><td class="c47" colspan="1" rowspan="1"><p class="c50"><span class="c41">(plus (num 1)</span></p><p class="c50"><span class="c41">      (plus (plus (num 2)</span></p><p class="c50"><span class="c41">                  (num 3))</span></p><p class="c50"><span class="c41">            (num 4)))</span></p></td></tr></tbody></table><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Observe a few things about these examples:</span></p><ul class="c24"><li class="c25 pcalibre"><span class="calibre3">The datatype definition does not let us </span><span class="c7">directly</span><span class="calibre3"> represent surface syntax terms such as </span><span class="c28">1 + 2 + 3 + 4</span><span class="c4">; any ambiguity has to be handled by the time we construct the corresponding AST term.</span></li><li class="c25 pcalibre"><span class="calibre3">The number representation might look a bit odd: we have a </span><span class="c28">num</span><span class="c4"> constructor whose only job is to “wrap” a number. We do this for consistency of representation. As we start writing programs to process these data, it’ll become clear why we did this.</span></li><li class="c25 pcalibre"><span class="calibre3">Notice that every significant part of the expression went into its AST representation, though not always in the same way. In particular, the </span><span class="c28">+</span><span class="calibre3"> of an addition is represented by the </span><span class="c7">constructor</span><span class="c4">; it is not part of the parameters.</span></li><li class="c25 pcalibre"><span class="calibre3">The AST really doesn’t care what surface syntax was used. The last term could instead have been written as<br class="calibre"/><br class="calibre"/></span><span class="c28">(+ 1<br class="calibre"/>   (+ (+ 2 3)<br class="calibre"/>      4))</span><span class="calibre3"><br class="calibre"/><br class="calibre"/>or even as<br class="calibre"/><br class="calibre"/></span><span class="calibre15"><img alt="" src="image11.png" title="" class="calibre16"/></span><span class="c4"><br class="calibre"/><br class="calibre"/>and it would presumably produce the same AST. </span></li></ul><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">In short, ASTs are tree-structured data that </span><span class="c40">represent programs in programs</span><span class="c4">. This is a profound idea! In fact, it’s one of the great ideas of the 20th century, building on the brilliant work of Gödel (encoding), Turing (universal machine), von Neumann (stored program computer), and McCarthy (metacircular interpreter).</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Aside:</span><span class="calibre3"> Not every part of the source program has been represented in the AST. For instance, presumably both </span><span class="c28">1 + 2</span><span class="calibre3"> and </span><span class="c28">1    +  2</span><span class="c4"> would be represented the same way, ignoring the spaces. In practice, a real language implementation does need to know something about the syntax: for instance, to highlight pieces of the program source when there is an error, as DrRacket does. Therefore, real-world implementations use abstract syntax but with metadata relating it back to the source.</span></p><p class="c3"><span class="c4"></span></p></body></html>
