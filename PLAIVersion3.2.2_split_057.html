<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.uwpyf6uoxhek"><span class="c4">A New Conditional</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Recall that Racket is a truthy/falsy language, where </span><span class="c28">if</span><span class="calibre3"> takes any non-false value to be true. Suppose we want a strict </span><span class="c28">if</span><span class="calibre3"> that takes only Booleans. That is, we want to extend Racket itself with a </span><span class="c28">strict-if</span><span class="c4">. Let’s try this:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define (strict-if C T E)</span></p><p class="c5"><span class="c41">  (if (boolean? C)</span></p><p class="c5"><span class="c41">      (if C T E)</span></p><p class="c5"><span class="c41">      (error 'strict-if "expected a boolean")))</span></p><p class="c3"><span class="c49"></span></p><p class="c5"><span class="c4">Try examples like:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(strict-if true 1 2)</span></p><p class="c5"><span class="c41">(strict-if 0 1 2)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Seems to work as desired!</span></p><p class="c3"><span class="c49"></span></p><p class="c31"><span class="c40">Do Now:</span><span class="c4"> Do you see what the problem is?</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">The problem is that we have an eager language (this is true of SMoL in general!), so </span><span class="c28">strict-if</span><span class="c4">s arguments are going to be evaluated before the body begins to execute. However, the whole point of a conditional is to avoid evaluating part of the evaluation: Try</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(strict-if true 1 (/ 1 0))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Compare this to what happens with</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(if true 1 (/ 1 0))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Okay, so we can’t use functions for this purpose. We need some other definition mechanism that consumes the </span><span class="c7">syntax</span><span class="c4"> and rewrites that, instead of letting it evaluate right away. These are macros.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Let’s dive into how the macro is written, because it’s not so different from the function:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define-syntax strict-if</span></p><p class="c5"><span class="c41">  (syntax-rules ()</span></p><p class="c5"><span class="c41">    [(strict-if C T E)</span></p><p class="c5"><span class="c41">     (if (boolean? C)</span></p><p class="c5"><span class="c41">         (if C T E)</span></p><p class="c5"><span class="c41">         (error 'strict-if "expected a boolean"))]))</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="calibre3">What are the pieces? </span><span class="c28">define-syntax</span><span class="calibre3"> says we’re defining a new piece of </span><span class="c7">syntax</span><span class="calibre3"> (as opposed to a function). </span><span class="c28">syntax-rules</span><span class="calibre3"> introduces a pattern-matcher (for now, ignore what the </span><span class="c28">()</span><span class="calibre3"> means: but you do need to include it). Each rule, in brackets, is a pattern and output: if the input matches the pattern, then the desugarer (here called a </span><span class="c7">macro expander</span><span class="calibre3">) produces the corresponding output, but with the </span><span class="c7">names</span><span class="calibre3"> in the pattern (here, </span><span class="c28">C</span><span class="calibre3">, </span><span class="c28">T</span><span class="calibre3">, and </span><span class="c28">E</span><span class="c4">) copied as program source into the output. Thus, given</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c28">(strict-if true 1 (/ 1 0))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">the above macro definition transforms it into</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(if (boolean? true)</span></p><p class="c5"><span class="c41">    (if true 1 (/ 1 0))</span></p><p class="c5"><span class="c41">    (error 'strict-if "expected a boolean"))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">which then evaluates exactly as we’d expect.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">One nice feature of Racket is the Macro Stepper (</span><span class="calibre23"><img alt="" src="image25.png" title="" class="calibre24"/></span><span class="c4">). It shows the program expanding step-by-step, which is useful both for understanding macros and debugging them. If necessary, change the “Macro hiding” option at the bottom-left to read “Standard”.</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Exercise:</span><span class="c4"> Try it out with the above macro definition and use. See what you get. Observe how, at each step, it highlights the macro use about to be expanded followed by the result of that expansion.</span></p><p class="c51"><span class="c4"></span></p><p class="c31"><span class="c40">Note:</span><span class="calibre3"> The Macro Stepper is not an </span><span class="c7">evaluator</span><span class="calibre3">. It does not show the steps of evaluation, only the steps of expansion! Thus, if you write a program that will produce an error at run-time, the Macro Stepper does not show that error. It only shows </span><span class="c7">syntax</span><span class="c4"> errors.</span></p></body></html>
