<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.1vry9xp4q0qh"><span class="c4">Returning to Our Timer</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">We can write the original timer program using FrTime’s GUI library. Here is the program, explained.</span></p><h3 class="c79" id="h.qqvpxt94c7zg"><span class="c80">Elapsed Time Without Resetting</span></h3><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">First we will write a simpler version that simply shows the elapsed time since the program began. To do so, we need to load the GUI library:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(require frtime/gui)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">and then we need to determine how much time has elapsed. It may be tempting to write</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define init-time seconds)</span></p><p class="c5"><span class="c41">(define elapsed-time (- seconds init-time))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">and then make a GUI display object that presents this (after converting the number into a string):</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(make-message (number-&gt;string elapsed-time))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">When we run this, however, we get a rather disappointing display that seems to always show </span><span class="c28">0</span><span class="calibre3">. That is because that’s what we asked for! We can check this by asking for the value of </span><span class="c28">init-time</span><span class="c4"> in the REPL:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">&gt; init-time</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">When we do, we see that it is constantly changing. But that’s what we should expect: we defined it to be the same as </span><span class="c28">seconds</span><span class="calibre3">! Instead, we need to hold on to the value of </span><span class="c28">seconds</span><span class="calibre3"> </span><span class="c7">at the time</span><span class="calibre3"> we started the program: i.e., we do </span><span class="c7">not</span><span class="c4"> want it to automatically update. For that, we instead write</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define init-time (value-now seconds))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">and then the rest of the program works as we would expect.</span></p><h3 class="c79" id="h.25o8auykyyi0"><span class="c80">Adding Resets</span></h3><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Now let’s add the button. We create a button object, which returns an event stream of its clicks:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define reset-clicks (make-button "Reset"))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Every time there’s a click, we want the elapsed time to reset to </span><span class="c28">0</span><span class="calibre3">. That is, we want to keep track of when the reset occurred. Note that again we need to use </span><span class="c28">value-now</span><span class="calibre3"> to get the time when it </span><span class="c7">occurred</span><span class="calibre3">, not the current time. We use </span><span class="c28">map-e</span><span class="c4"> to map over event streams:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define click-times (map-e (lambda (_) (value-now seconds)) reset-clicks))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">So we have two kinds of events: the start of the program, and the clicks. We want a single behavior that reflects when these occurred: starting with when the program began, and updating whenever there’s a click. The function </span><span class="c28">switch</span><span class="c4"> does this, “switching” the behavior’s value whenever an event occurs:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define event-times (switch click-times init-time))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">At this point, the elapsed time to show is how far the current time is from the last event:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define elapsed-time (- seconds event-times))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Visually:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre53"><img alt="" src="image16.png" title="" class="calibre54"/></span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Putting this all together, and adding the output directive:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define init-time (value-now seconds))</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">(define reset-clicks (make-button "Reset"))</span></p><p class="c5"><span class="c41">(define click-times (map-e (lambda (_) (value-now seconds)) reset-clicks))</span></p><p class="c5"><span class="c41">(define event-times (switch click-times init-time))</span></p><p class="c5"><span class="c41">(define elapsed-time (- seconds event-times))</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">(make-message (number-&gt;string elapsed-time))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Observe that in this program, there are two kinds of changes that can occur:</span></p><p class="c3"><span class="c4"></span></p><ul class="c24"><li class="c25 pcalibre"><span class="calibre3">Another second elapses. Thus, </span><span class="c28">seconds</span><span class="calibre3"> changes; so does </span><span class="c28">elapsed-time</span><span class="calibre3">; and so </span><span class="c28">make-message</span><span class="c4"> updates its output.</span></li><li class="c25 pcalibre"><span class="calibre3">The user clicks the button. Then </span><span class="c28">reset-clicks</span><span class="calibre3"> has an event, so </span><span class="c28">click-times</span><span class="calibre3"> has an event, </span><span class="c28">event-times</span><span class="calibre3"> updates, and so does </span><span class="c28">elapsed-time</span><span class="calibre3">, thereby also causing </span><span class="c28">make-message</span><span class="c4"> to also update its output.</span></li></ul><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">In both cases </span><span class="c28">elapsed-time</span><span class="calibre3"> updates, triggering a change in the output. But there are two inputs to the subtraction in </span><span class="c28">elapsed-time</span><span class="c4">, and they update for different reasons.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">What may be lost in the above presentation, which is incremental to enhance readability, is that we actually have deeply nested expressions that we can think of algebraically. To make that clearer, here is the whole program written as a single expression, with each name replaced with the expression it was bound to (though this is almost certainly a less readable version):</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(make-message (number-&gt;string</span></p><p class="c5"><span class="c41">               (- seconds</span></p><p class="c5"><span class="c41">                  (switch</span></p><p class="c5"><span class="c41">                   (map-e (lambda (_) (value-now seconds))</span></p><p class="c5"><span class="c41">                          (make-button "Reset"))</span></p><p class="c5"><span class="c41">                   (value-now seconds)))))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">The interested reader can prove properties of the time shown based purely on the rules of algebra, perhaps even identifying a slightly unsatisfying behavior in the time shown by the timer (which was also a problem with the callback version).</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">This example shows that we really can compose expressions in a conventional manner </span><span class="c7">even though</span><span class="c4"> we are writing a reactive program using a GUI library. It is worth comparing the structure of this program against the callback-based version that we started with.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/ick-adapt-oo-fwk-frp/&amp;sa=D&amp;source=editors&amp;ust=1695232021664301&amp;usg=AOvVaw1WOPAKU7HpkFtzRQxaaDl3">This paper</a></span><span class="c4"> shows how the GUI library was given a functional-reactive interface by exploiting the encapsulation of object-oriented state.</span></p></body></html>
