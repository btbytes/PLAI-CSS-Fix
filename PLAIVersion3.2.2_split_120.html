<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h1 class="c22" id="h.e43aokkp4uwk"><span class="c4">Algebraic Datatypes</span></h1><p class="c5"><span class="calibre3">We have written numerous </span><span class="c28">define-type</span><span class="c4"> definitions so far, e.g., for expressions. Now we will study this mechanism, which is increasingly found in many new programming languages, in more detail.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">To simplify things, consider a simple plait data definition of a binary tree of numbers:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define-type BT</span></p><p class="c5"><span class="c41">  [mt]</span></p><p class="c5"><span class="c28">  [node (v : Number) (l : BT) (r : BT)])</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">The </span><span class="c28">define-type</span><span class="c4"> construct here is doing three different things, and it’s worth teasing them apart:</span></p><p class="c3"><span class="c4"></span></p><ol class="c107" start="1"><li class="pcalibre16 c108"><span class="calibre3">Giving a </span><span class="c7">name</span><span class="calibre3"> to a new type, </span><span class="c28">BT</span><span class="c4">.</span></li><li class="pcalibre16 c108"><span class="calibre3">Allowing the type to be defined by multiple cases or </span><span class="c7">variants</span><span class="calibre3"> (</span><span class="c28">mt</span><span class="calibre3"> and </span><span class="c28">node</span><span class="c4">).</span></li><li class="pcalibre16 c108"><span class="calibre3">Permitting a </span><span class="c7">recursive</span><span class="calibre3"> definition (</span><span class="c28">BT</span><span class="calibre3"> references </span><span class="c28">BT</span><span class="c4">).</span></li></ol><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">It’s worth asking whether all these pieces of functionality really have to be bundled together, or whether they can be handled separately. While they can indeed be separated, they often end up working in concert, especially when it comes to recursive definitions, which are quite common. A recursive definition needs a name for creating the recursion; therefore, the third feature requires the first. Furthermore, a recursive definition often needs a non-recursive case to “bottom out”; this requires there to be more than one variant, using the second feature. Putting the three together, therefore, makes a lot of sense.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">This construct is called an </span><span class="c7">algebraic datatype</span><span class="calibre3">, sometimes also known as a “sum of products”. That is because the variants are read as an “or”: a </span><span class="c28">BT</span><span class="calibre3"> is an </span><span class="c28">mt</span><span class="calibre3"> </span><span class="c7">or</span><span class="calibre3"> a </span><span class="c28">node</span><span class="calibre3">. Each variant is an “and” of its fields: a node has a </span><span class="c28">v</span><span class="calibre3"> </span><span class="c7">and</span><span class="calibre3"> an </span><span class="c28">l</span><span class="calibre3"> </span><span class="c7">and</span><span class="calibre3"> an </span><span class="c28">r</span><span class="c4">. In Boolean algebra, “or” is analogous to a sum and “and” is analogous to a product.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Sometimes, you will also see this referred to as a </span><span class="c7">tagged union</span><span class="calibre3">. The word “union” is because we can conceptually think of a </span><span class="c28">BT</span><span class="calibre3"> as a union of </span><span class="c28">mt</span><span class="calibre3">s and </span><span class="c28">node</span><span class="calibre3">s. The tag is the constructor. This term makes more sense once we compare it against “untagged” union types [</span><span class="c16"><a class="c11" href="PLAIVersion3.2.2_split_125.html#h.tg4ohkq8ngzt">👉</a></span><span class="c4">].</span></p></body></html>
