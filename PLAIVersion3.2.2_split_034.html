<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.k44dp8d0lvuz"><span class="c4">Adding Booleans</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Okay, so what if we wanted proper Booleans?</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Again, to employ SImPl, we need to alter the AST, the evaluator, and the parser.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">We can add Booleans much like we did numbers: with a constructor that wraps a plait representation of the Boolean.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define-type Exp</span></p><p class="c5"><span class="c41">Â  [num (n : Number)]</span></p><p class="c5"><span class="c41">Â  [bool (b : Boolean)]</span></p><p class="c5"><span class="c41">Â  [plus (left : Exp) (right : Exp)]</span></p><p class="c5"><span class="c41">Â  [cnd (test : Exp) (then : Exp) (else : Exp)])</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Itâ€™s very important to keep in mind what the </span><span class="c28">num</span><span class="calibre3">Â and </span><span class="c28">bool</span><span class="calibre3">Â constructors stand for. Recall that this is </span><span class="c7">abstract syntax</span><span class="calibre3">: we are just (abstractly) representing the </span><span class="c7">program that the user wrote</span><span class="calibre3">, not the result of its evaluation. Therefore, these constructors are capturing syntactic </span><span class="c7">constants</span><span class="calibre3">Â in the source program: values like </span><span class="c28">3.14</span><span class="calibre3">Â and </span><span class="c28">-1</span><span class="calibre3">Â for the former and </span><span class="c28">#true</span><span class="calibre3">Â and </span><span class="c28">#false</span><span class="calibre3">Â for the latter. They do </span><span class="c61">not</span><span class="calibre3">Â represent compound expressions that will </span><span class="c7">evaluate to</span><span class="calibre3">Â numbers or Booleans. What an expression will evaluate to, for now, can only be determined by running it. Later [</span><span class="c16"><a class="c11" href="PLAIVersion3.2.2_split_088.html#h.7rb3ecnk20em">ðŸ‘‰</a></span><span class="c4">], we will see there are other ways of doing it too!</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Aside:</span><span class="calibre3">Â The abstract syntax does not dictate what concrete syntax we use. For instance, we may write numbers as </span><span class="c28">3</span><span class="calibre3">Â or as </span><span class="c28">III</span><span class="calibre3">. We might write Boolean values as </span><span class="c28">#t</span><span class="calibre3">, </span><span class="c28">#true</span><span class="calibre3">, </span><span class="c28">true</span><span class="calibre3">, </span><span class="c28">True</span><span class="calibre3">, â€¦. We may even have different concrete syntaxes for the same abstract syntax. This is precisely the </span><span class="c7">abstraction</span><span class="c4">Â that abstract syntax provides!</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Easy peasy! This naturally suggests what we should do in the evaluator:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define (calc e)</span></p><p class="c5"><span class="c41">Â  (type-case Exp e</span></p><p class="c5"><span class="c41">Â  Â  [(num n) n]</span></p><p class="c5"><span class="c41">Â  Â  [(bool b) b]</span></p><p class="c5"><span class="c41">Â  Â  [(plus l r) (+ (calc l) (calc r))]</span></p><p class="c5"><span class="c41">Â  Â  [(cnd c t e) (if (zero? (calc c))</span></p><p class="c5"><span class="c41">Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â (calc t)</span></p><p class="c5"><span class="c41">Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â (calc e))]))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Ohâ€¦oops. This version of </span><span class="c28">calc</span><span class="c4">Â doesnâ€™t type-check, because our calculator is supposed to return only numbers, not Booleans!</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">In fact, we had to know that this couldnâ€™t last. We arenâ€™t interested only in calculators; we want to build full-fledged programming languages. They have a wide range of values, i.e., answers: numbers, Boolean, strings, images, functions, and more.</span></p></body></html>
