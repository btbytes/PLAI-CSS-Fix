<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.iaguafowwwxv"><span class="c4">A Java Excursion</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Let’s first understand what’s going on in Java. For simplicity, let’s use a canonical “2d point” and “3d point” example. We’ll start with this class:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">class Pt2 {</span></p><p class="c5"><span class="c41">    Pt2(int x, int y) {</span></p><p class="c5"><span class="c41">        System.out.println("Pt2 with " + x + " and " + y);</span></p><p class="c5"><span class="c41">    }</span></p><p class="c5"><span class="c41">}</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">We can make instances of it easily enough:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">class Main {</span></p><p class="c5"><span class="c41">    public static void main(String[] args) {</span></p><p class="c5"><span class="c41">        Pt2 p2 = new Pt2(1, 2);</span></p><p class="c5"><span class="c41">    }</span></p><p class="c5"><span class="c41">}</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c4">and this prints the expected output. Now suppose we extend this class:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">class Pt3 extends Pt2 {</span></p><p class="c5"><span class="c41">    Pt3(int x, int y, int z) {</span></p><p class="c5"><span class="c41">        System.out.println("Pt3 with " + z);</span></p><p class="c5"><span class="c41">    }</span></p><p class="c5"><span class="c41">}</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c7">This won’t even compile</span><span class="calibre3">. We will get a somewhat strange-looking error. The error is because Java is expecting to make an instance of </span><span class="c28">Pt2</span><span class="calibre3"> as well, but we have not told it how to. In the absence of anything else, it invokes a “default constructor”, which takes </span><span class="c7">no</span><span class="calibre3"> parameters (because Java has no way of knowing which parameters to pass). If we modify </span><span class="c28">Pt2</span><span class="c4"> to instead be</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">class Pt2 {</span></p><p class="c5"><span class="c41">   Pt2() {</span></p><p class="c5"><span class="c41">       System.out.println("default constructor");</span></p><p class="c5"><span class="c41">   }</span></p><p class="c5"><span class="c41">    Pt2(int x, int y) {</span></p><p class="c5"><span class="c41">        System.out.println("Pt2 with " + x + " and " + y);</span></p><p class="c5"><span class="c41">    }</span></p><p class="c5"><span class="c41">}</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="calibre3">then we find that the program compiles and, if we change </span><span class="c28">Main</span><span class="c4"> suitably,</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">class Main {</span></p><p class="c5"><span class="c41">  public static void main(String[] args) {</span></p><p class="c5"><span class="c41">    Pt3 p3 = new Pt3(1, 2, 3);</span></p><p class="c5"><span class="c41">  }</span></p><p class="c5"><span class="c41">}</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">it runs, but perhaps without the effect we were expecting. The solution, in Java terms, is to explicitly invoke the constructor of the super-class:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">class Pt3 extends Pt2 {</span></p><p class="c5"><span class="c41">    Pt3(int x, int y, int z) {</span></p><p class="c5"><span class="c41">        System.out.println("Pt3 with " + z);</span></p><p class="c5"><span class="c41">        super(x, y);</span></p><p class="c5"><span class="c41">    }</span></p><p class="c5"><span class="c41">}</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">but this won’t work either: Java expects the </span><span class="c28">super</span><span class="calibre3"> invocation to be the </span><span class="c7">first</span><span class="c4"> thing in the sub-class’s constructor.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">As the error message above reveals, hidden in the constructor of the extended class is lurking something important: it tries to </span><span class="c7">create an instance</span><span class="calibre3"> of the super-class, just as if we had written </span><span class="c28">new Pt2</span><span class="calibre3">. This is entirely masked by the syntactic sugar of </span><span class="c28">super</span><span class="calibre3">. The actual </span><span class="c28">Pt2</span><span class="c4"> instance is hidden out of sight, and it takes a little effort to coax it into view.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">To see it, let’s first add some instance variables:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">class Pt2 {</span></p><p class="c5"><span class="c41">    public int x;</span></p><p class="c5"><span class="c41">    Pt2(int x, int y) {</span></p><p class="c5"><span class="c41">        this.x = x - 3;</span></p><p class="c5"><span class="c41">        System.out.println("Pt2 with " + x + " and " + y);</span></p><p class="c5"><span class="c41">    }</span></p><p class="c5"><span class="c41">}</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">class Pt3 extends Pt2 {</span></p><p class="c5"><span class="c41">    public int x;</span></p><p class="c5"><span class="c41">    Pt3(int x, int y, int z) {</span></p><p class="c5"><span class="c41">        super(x, y);</span></p><p class="c5"><span class="c41">        this.x = x + 7;</span></p><p class="c5"><span class="c41">        System.out.println("Pt3 with " + z);</span></p><p class="c5"><span class="c41">    }</span></p><p class="c5"><span class="c41">}</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c4">We’ve purposely made the instance variables have values that look different from those of the parameters, so that when we try to examine them, we can tell them apart. Now let’s modify the constructor to make two objects:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">class Main {</span></p><p class="c5"><span class="c41">    public static void main(String[] args) {</span></p><p class="c5"><span class="c41">        Pt3 p3345 = new Pt3(3, 4, 5);</span></p><p class="c5"><span class="c41">        Pt3 p3678 = new Pt3(6, 7, 8);</span></p><p class="c5"><span class="c41">    }</span></p><p class="c5"><span class="c41">}</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c7">Two</span><span class="calibre3"> objects…how many objects did we really make? Well, we made </span><span class="c7">at least</span><span class="c4"> two, because adding</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">        System.out.println(p3345.x);</span></p><p class="c5"><span class="c41">        System.out.println(p3678.x);</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="calibre3">to the constructor shows that there are two different objects with two different values for </span><span class="c28">x</span><span class="c4">. So far, so unsurprising.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">However, I’ve claimed that there are two more objects, of type </span><span class="c28">Pt2</span><span class="calibre3">. Can we </span><span class="c7">see</span><span class="calibre3"> them? Yes, in fact, we can. The problem is that they’re of type </span><span class="c28">Pt2</span><span class="calibre3">, and what we have are </span><span class="c28">Pt3</span><span class="calibre3"> objects. We can’t just make a </span><span class="c28">Pt2</span><span class="calibre3">, because that doesn’t reveal the </span><span class="c7">hidden</span><span class="calibre3"> </span><span class="c28">Pt2</span><span class="calibre3">. But in fact the Java type system lets us get to the </span><span class="c28">Pt2</span><span class="calibre3"> by </span><span class="c7">casting</span><span class="c4">:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">        System.out.println(((Pt2)p3345).x);</span></p><p class="c5"><span class="c41">        System.out.println(((Pt2)p3678).x);</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="calibre3">And that’s how we can see that there are actually two </span><span class="c28">Pt2</span><span class="c4"> objects lurking as well!</span></p></body></html>
