<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.9ailyuprz16v"><span class="c4">Where Types Diverge from Evaluation</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Something very important, and subtle, happened above. Compare the </span><span class="c7">type rule</span><span class="calibre3"> for a conditional with the </span><span class="c7">evaluation</span><span class="calibre3"> process [</span><span class="c16"><a class="c11" href="PLAIVersion3.2.2_split_000.html#h.d1lwuw2pv936">👉</a></span><span class="calibre3">]. If the rule is too abstract, just look at the example judgments (or failed judgments) above. The evaluator evaluates only </span><span class="c7">one</span><span class="calibre3"> branch out of </span><span class="c28">T</span><span class="calibre3"> and </span><span class="c28">E</span><span class="calibre3">; indeed, that is the </span><span class="c7">entire point</span><span class="calibre3"> of a conditional. The type-checker, in contrast, traverses </span><span class="c7">both</span><span class="calibre3"> branches! In other words, it looks at code that </span><span class="c7">might</span><span class="calibre3"> evaluate, not only code that absolutely </span><span class="c7">does</span><span class="c4"> evaluate.<br class="calibre"/></span></p><p class="c5"><span class="calibre3">In other words, the idea that a type-checker is like an “evaluator that runs over simple values” is a convenient starting analogy, but it is in fact false. An evaluator and type-checker follow different traversal strategies. That is why a program like </span><span class="c28">(if true 1 "hi")</span><span class="c4"> might run without any difficulty but is rejected by a type-checker. While this particular example may make the type-checker look overly pedantic, what if the same program were</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c28">(if (is-full-moon) 1 "hi")</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">What now? Should the type-checker pass the program every month? Should it consider the moon’s phase at the time of type-checking or at execution? Unfortunately, the type-checker doesn’t know when the program will run; indeed, the program is type-checked once but may run an arbitrary number of times. Therefore, a type-checker must necessarily be </span><span class="c7">conservative</span><span class="c4">.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">This also lets us relate type-checking to </span><span class="c40">testing</span><span class="calibre3">. In software testing, making sure that all branches are visited is called </span><span class="c7">branch coverage</span><span class="calibre3">, and making sure all branches have coverage is both important and very difficult (because each branch may have additional branches which in turn may have even more branches which…). In contrast, a type-checker effortlessly covers both branches. The trade-off is that it does so only at the </span><span class="c7">type</span><span class="c4"> level (and indeed, the abstraction of values to types is precisely what enables it to do this).</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Thus, testing and type-checking are complementary. Type-checking provides code coverage at a lightweight level; testing typically provides only partial coverage but at the deep level of specific values. In recent years, people have invented a notion of </span><span class="c26"><a class="c11" href="https://www.google.com/url?q=https://en.wikipedia.org/wiki/Concolic_testing&amp;sa=D&amp;source=editors&amp;ust=1695232021370424&amp;usg=AOvVaw1QJrbACLLfoZOf01gPppBi">concolic</a></span><span class="c4">—i.e., “concrete” + “symbolic”—testing to try to create the best of both worlds.</span></p><p class="c3"><span class="c4"></span></p><p class="c3"><span class="c4"></span></p></body></html>
