<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.9ailyuprz16v"><span class="c4">Where Types Diverge from Evaluation</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Something very important, and subtle, happened above. Compare the </span><span class="c7">type rule</span><span class="calibre3">Â for a conditional with the </span><span class="c7">evaluation</span><span class="calibre3">Â process [</span><span class="c16"><a class="c11" href="PLAIVersion3.2.2_split_000.html#h.d1lwuw2pv936">ğŸ‘‰</a></span><span class="calibre3">]. If the rule is too abstract, just look at the example judgments (or failed judgments) above. The evaluator evaluates only </span><span class="c7">one</span><span class="calibre3">Â branch out of </span><span class="c28">T</span><span class="calibre3">Â and </span><span class="c28">E</span><span class="calibre3">; indeed, that is the </span><span class="c7">entire point</span><span class="calibre3">Â of a conditional. The type-checker, in contrast, traverses </span><span class="c7">both</span><span class="calibre3">Â branches! In other words, it looks at code that </span><span class="c7">might</span><span class="calibre3">Â evaluate, not only code that absolutely </span><span class="c7">does</span><span class="c4">Â evaluate.<br class="calibre"/></span></p><p class="c5"><span class="calibre3">In other words, the idea that a type-checker is like an â€œevaluator that runs over simple valuesâ€ is a convenient starting analogy, but it is in fact false. An evaluator and type-checker follow different traversal strategies. That is why a program like </span><span class="c28">(if true 1 "hi")</span><span class="c4">Â might run without any difficulty but is rejected by a type-checker. While this particular example may make the type-checker look overly pedantic, what if the same program were</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c28">(if (is-full-moon) 1 "hi")</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">What now? Should the type-checker pass the program every month? Should it consider the moonâ€™s phase at the time of type-checking or at execution? Unfortunately, the type-checker doesnâ€™t know when the program will run; indeed, the program is type-checked once but may run an arbitrary number of times. Therefore, a type-checker must necessarily be </span><span class="c7">conservative</span><span class="c4">.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">This also lets us relate type-checking to </span><span class="c40">testing</span><span class="calibre3">. In software testing, making sure that all branches are visited is called </span><span class="c7">branch coverage</span><span class="calibre3">, and making sure all branches have coverage is both important and very difficult (because each branch may have additional branches which in turn may have even more branches whichâ€¦). In contrast, a type-checker effortlessly covers both branches. The trade-off is that it does so only at the </span><span class="c7">type</span><span class="c4">Â level (and indeed, the abstraction of values to types is precisely what enables it to do this).</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Thus, testing and type-checking are complementary. Type-checking provides code coverage at a lightweight level; testing typically provides only partial coverage but at the deep level of specific values. In recent years, people have invented a notion of </span><span class="c26"><a class="c11" href="https://www.google.com/url?q=https://en.wikipedia.org/wiki/Concolic_testing&amp;sa=D&amp;source=editors&amp;ust=1695232021370424&amp;usg=AOvVaw1QJrbACLLfoZOf01gPppBi">concolic</a></span><span class="c4">â€”i.e., â€œconcreteâ€ + â€œsymbolicâ€â€”testing to try to create the best of both worlds.</span></p><p class="c3"><span class="c4"></span></p><p class="c3"><span class="c4"></span></p></body></html>
