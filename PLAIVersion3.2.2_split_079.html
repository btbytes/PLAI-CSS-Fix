<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.5e60w47v68ti"><span class="c4">Objects with Self Reference</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Until now, our objects have simply been packages of named functions: functions with multiple named entry-points, if you will. We’ve seen that many of the features considered important in object systems are actually simple patterns over functions and scope, and have indeed been used—without names assigned to them—for decades by programmers armed with lambdas.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">What this means is that the different members are actually independent of each other: they can’t, for instance, directly reference one another. This is too limiting for a true object system, where a method has a way of referencing the object it is part of so that it can use other members of that object. To enable this, many object systems automatically equip each object with a reference to itself, often called </span><span class="c28">self</span><span class="calibre3"> or </span><span class="c28">this</span><span class="c4">. Can we implement this?</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Aside</span><span class="c4">: I prefer this slightly dry way of putting it to the anthropomorphic “knows about itself” terminology often adopted by object advocates. Indeed, note that we have gotten this far into object system properties without ever needing to resort to anthropomorphism. </span></p><h3 class="c79" id="h.weagppgxo8s8"><span class="c80">Self-Reference Using Mutation</span></h3><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Yes, we can! This relies on a pattern that sets up the name for the recursive reference, then uses that to create the body that will employ the recursion, and finally uses mutation to make the name refer to the defined body. For simplicity, we will go back to the</span><span class="c7"> object</span><span class="c4"> pattern, ignoring the class-related features:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define o-self!</span></p><p class="c5"><span class="c41">  (let ([self 'dummy])</span></p><p class="c5"><span class="c41">    (begin</span></p><p class="c5"><span class="c41">      (set! self</span></p><p class="c5"><span class="c41">            (lambda (m)</span></p><p class="c5"><span class="c41">              (case m</span></p><p class="c5"><span class="c41">                [(first) (lambda (x) (msg self 'second (+ x 1)))]</span></p><p class="c5"><span class="c41">                [(second) (lambda (x) (+ x 1))])))</span></p><p class="c5"><span class="c41">      self)))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">We can test it by having </span><span class="c28">first</span><span class="calibre3"> invoke </span><span class="c28">second</span><span class="c4">. Sure enough, this produces the expected answer:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(test (msg o-self! 'first 5) 7)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Here is the above program translated into the simpler smol/fun language. Once translated, we can run it in the Stacker:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">#lang stacker/smol/hof</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">(defvar o-self!</span></p><p class="c5"><span class="c41">  (let ([self 0])</span></p><p class="c5"><span class="c41">    (begin</span></p><p class="c5"><span class="c41">      (set! self</span></p><p class="c5"><span class="c41">            (lambda (m)</span></p><p class="c5"><span class="c41">              (if (equal? m "first")</span></p><p class="c5"><span class="c41">                  (lambda (x) ((self "second") (+ x 1)))</span></p><p class="c5"><span class="c41">                  (if (equal? m "second")</span></p><p class="c5"><span class="c41">                      (lambda (x) (+ x 1))</span></p><p class="c5"><span class="c41">                      (error "no such member")))))</span></p><p class="c5"><span class="c41">      self)))</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">((o-self! "first") 5)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Run it for yourself! What do you learn from it? Do you see how </span><span class="c28">self</span><span class="c4"> works?</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Exercise:</span><span class="calibre3"> This change to the object pattern is essentially </span><span class="c7">independent</span><span class="c4"> of the class pattern. Extend the class pattern to include self-reference.</span></p><h3 class="c79" id="h.uh01s2uf032m"><span class="c80">Self-Reference Without Mutation</span></h3><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">There’s another pattern we can use that avoids mutation, which is to send the object itself as a parameter:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define o-self-no!</span></p><p class="c5"><span class="c41">  (lambda (m)</span></p><p class="c5"><span class="c41">    (case m</span></p><p class="c5"><span class="c41">      [(first) (lambda (self x) (msg/self self 'second (+ x 1)))]</span></p><p class="c5"><span class="c41">      [(second) (lambda (self x) (+ x 1))])))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Each method now takes </span><span class="c28">self</span><span class="c4"> as an argument. That means method invocation must be modified to follow this new pattern:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define (msg/self o m . a)</span></p><p class="c5"><span class="c41">  (apply (o m) o a))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">That is, when invoking a method on </span><span class="c28">o</span><span class="calibre3">, we must pass </span><span class="c28">o</span><span class="c4"> as a parameter to the method. Notice that we did not do any such thing when invoking a function! This distinguishes functions and methods.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Obviously, this approach is dangerous because we can potentially pass a different object as the “self”. Exposing this to the developer is therefore probably a bad idea; if this implementation technique is used, it should only be done in desugaring. (Unfortunately, Python exposes exactly this in its surface syntax.) Sure enough:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(test (msg/self o-self-no! 'first 5) 7)</span></p></body></html>
