<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.db719pow9mrl"><span class="c4">Class Extensions: Mixins and Traits</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">When we write </span><span class="c28">class</span><span class="calibre3"> in Java, what are we really defining between the opening and closing braces? It is not the entire class: that depends on the parent that it extends, and so on recursively. Rather, what we define inside the braces is a class </span><span class="c7">extension</span><span class="c4">. It only becomes a full-blown class because we also identify the parent class in the same place.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Naturally, we should ask: Why? Why not separate the act of </span><span class="c7">defining</span><span class="calibre3"> an extension from </span><span class="c7">applying</span><span class="c4"> the extension to a base class? That is, suppose instead of</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">class C extends B { ... }</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">we instead write:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">classext E { ... }</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">and separately</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">class C = E(B)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">where </span><span class="c28">B</span><span class="c4"> is some already-defined class?</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Thus far, it looks like we’ve just gone to great lengths to obtain what we had before. However, the function-application-like syntax is meant to be suggestive: we can “apply” this extension to several different base classes. Thus:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">class C1 = E(B1);</span></p><p class="c5"><span class="c41">class C2 = E(B2);</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">and so on. What we have done by separating the definition of </span><span class="c28">E</span><span class="calibre3"> from that of the class it extends is to liberate class extensions from the tyranny of the fixed base class. We have a name for these extensions: they’re called </span><span class="c7">mixins</span><span class="c4">.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Mixins make class definition more compositional. They provide many of the benefits of multiple-inheritance (reusing multiple fragments of functionality) but within the aegis of a single-inheritance language (i.e., no complicated rules about lookup order). Observe that when desugaring, it’s actually quite easy to add mixins to the language. A mixin is just a “function over classes”. Because we have already determined how to desugar classes, and our target language for desugaring also has functions, and classes desugar to expressions that can be nested inside functions, it becomes almost trivial to implement a simple model of mixins.</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Aside:</span><span class="calibre3"> This is a case where the greater generality of the target language of desugaring can lead us to a </span><span class="c7">better</span><span class="c4"> construct, if we reflect it back into the source language.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">In a typed language, a good design for mixins can actually improve object-oriented programming practice. Suppose we’re defining a mixin-based version of Java. If a mixin is effectively a class-to-class function, what is the “type” of this “function”? Clearly, mixins ought to use </span><span class="c7">interfaces</span><span class="calibre3"> to describe what they expect and what they provide. Java already enables (but does not require) the latter, namely classes can say what interfaces they provide. However, it does not enable the former, namely specifying its parent as an </span><span class="c7">interface</span><span class="calibre3">: a class (extension) in Java extends its parent class—with all the parent’s members visible to the extension—rather than an interface that </span><span class="c7">stands for</span><span class="calibre3"> the parent (or any </span><span class="c7">other</span><span class="c4"> class that matches that same interface). That means it obtains all of the parent’s behavior, not a specification thereof. In turn, if the parent changes, the class might break. Mixins help break this asymmetry between extension and provision.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">In a mixin language, we can instead write</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">mixin M extends I1 implements I2 { ... }</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">where </span><span class="c28">I1</span><span class="calibre3"> and </span><span class="c28">I2 </span><span class="calibre3">are interfaces. Then </span><span class="c28">M</span><span class="calibre3"> can only be applied to a class that satisfies the interface </span><span class="c28">I1</span><span class="calibre3">, and in turn the language can ensure that only members specified in</span><span class="c28"> I1</span><span class="calibre3"> are visible in </span><span class="c28">M</span><span class="calibre3">. This becomes directly analogous to how a client of </span><span class="c28">M</span><span class="calibre3"> can only see what is provided by </span><span class="c28">I2</span><span class="c4">, and follows one of the important principles of good software design:</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Quote:</span><span class="calibre3"> “Program to an interface, not an implementation.” —</span><span class="c26"><a class="c11" href="https://www.google.com/url?q=https://en.wikipedia.org/wiki/Design_Patterns&amp;sa=D&amp;source=editors&amp;ust=1695232021331399&amp;usg=AOvVaw0oLqFKll63oSL1E3kTxWev">Design Patterns</a></span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">In short, a mixin is a class that has been turned into a function over parent classes:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">M :: I1 -&gt; I2</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">A good design for mixins can go even further. A class can only be used once in an inheritance chain, by definition (if a class eventually referred back to itself, there would be a cycle in the inheritance chain, causing potential infinite loops). In contrast, when we compose functions, we have no qualms about using the same function twice (e.g.: </span><span class="c28">(map ... (filter ... (map ...))))</span><span class="c4">. Is there value to using a mixin twice?</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Aside:</span><span class="calibre3"> There certainly is! See sections 3 and 4 of </span><span class="c26"><a class="c11" href="https://www.google.com/url?q=http://www.cs.brown.edu/~sk/Publications/Papers/Published/fkf-classes-mixins/&amp;sa=D&amp;source=editors&amp;ust=1695232021332340&amp;usg=AOvVaw2wOohANSHEwTtdW3WtYZHP">Classes and Mixins</a></span><span class="c4">.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Mixins solve an important problem that arises in the design of libraries. Suppose we have a dozen different features which can be combined in different ways. How many classes should we provide? Furthermore, not all of these can be combined with each other. It is obviously impractical to generate the entire combinatorial explosion of classes. It would be better if the developer could pick and choose the features they care about, with some mechanism to prevent unreasonable combinations. This is precisely the problem that mixins solve: they provide the class extensions, which the developers can combine, in an interface-preserving way, to create just the classes they need.</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Aside:</span><span class="calibre3"> Mixins are used extensively in the Racket GUI library. For instance, </span><span class="c28">color:text-mixin</span><span class="c4"> consumes basic text editor interfaces and implements the colored text editor interface. The latter is itself a basic text editor interface, so additional basic text mixins can be applied to the result.</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Exercise:</span><span class="c4"> How does the analogous library in your favorite object-oriented language solve this same problem?</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Mixins do have one limitation: they enforce a linearity of composition. This strictness is sometimes misplaced, because it puts a burden on programmers that may not be necessary. A generalization of mixins called </span><span class="c7">traits</span><span class="c4"> says that instead of extending a single mixin, we can extend a set of them. Of course, the moment we extend more than one, we must again contend with potential name-clashes. Thus traits must be equipped with mechanisms for resolving name clashes, often in the form of some name-combination algebra. Traits thus offer a nice complement to mixins, enabling programmers to choose the mechanism that best fits their needs. As a result, Racket provides both mixins and traits.</span></p><p class="c3"><span class="c4"></span></p></body></html>
