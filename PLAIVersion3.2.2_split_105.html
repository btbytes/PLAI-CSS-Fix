<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.3x1o016rduha"><span class="c4">Recursion and Infinite Loops</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">We alluded, earlier, to how we can desugar more interesting features into functions and application. Let’s take a look at a very specific feature: an infinite loop. Let’s first confirm that we can write an infinite loop. Here’s a program that does it:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">fun f():</span></p><p class="c5"><span class="c41">  f()</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">f()</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">But this assumes we already have recursion. Can we write it without recursion? Actually we can! We’ll use historical names (</span><span class="c104">ω</span><span class="c4"> is the lower-case Greek omega):</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c28">(let ([</span><span class="c104">ω</span><span class="c41"> (lambda (x) (x x))])</span></p><p class="c5"><span class="c28">  (</span><span class="c104">ω</span><span class="c28"> </span><span class="c104">ω</span><span class="c41">))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Run this in Racket and confirm that it runs forever!</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Do Now:</span><span class="calibre3"> Write a conditional type rule for </span><span class="c28">let</span><span class="c4">.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Now let’s see what happens when we try to type this. We have to provide a type annotation:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c28">(let ([</span><span class="c104">ω</span><span class="c41"> (lambda (x : ???) (x x))])</span></p><p class="c5"><span class="c28">  (</span><span class="c104">ω</span><span class="c28"> </span><span class="c104">ω</span><span class="c41">))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Historically, the overall term is called </span><span class="c104">Ω</span><span class="c4"> (the capital Greek omega).</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Okay, so what is the annotation? To determine a type for </span><span class="c28">x</span><span class="calibre3">, we have to see how it’s used. It’s used twice. One use is in a function application position, so we know that the type must be of the form </span><span class="c28">(T -&gt; U)</span><span class="calibre3">; now we have to determine what </span><span class="c28">T</span><span class="calibre3"> and </span><span class="c28">U</span><span class="calibre3"> are. Let’s focus on the parameter type, </span><span class="c28">T</span><span class="calibre3">. But what are we passing in? We’re passing in </span><span class="c28">x</span><span class="calibre3">, whose type is </span><span class="c28">(T -&gt; U)</span><span class="c4">. So we need a solution to the equation</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c28">T</span><span class="calibre3"> = </span><span class="c41">(T -&gt; U)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">with one coming from the application position and the other from the argument position. Of course, there is no finite type that can fit this equation! Therefore, it appears that this program cannot be typed!</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Of course, this is not a proof. However, there is a formal property associated with this programming language, which is called the Simply Typed Lambda Calculus (STLC): the property is called </span><span class="c7">strong normalization</span><span class="calibre3">, and it means that </span><span class="c7">all programs in this language terminate</span><span class="c4">.</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Aside:</span><span class="c4"> If you have heard about the Halting Problem, how does that square with what you just read?</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">It may seem rather useless to have a language in which all programs terminate—you can’t write an operating system, or Web server, or many other programs in such a language. However, that misses two things.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">First, there are many cases where we </span><span class="c7">want</span><span class="calibre3"> programs to always terminate. You don’t want a network packet filter or a device driver or a compiler or a type-checker or … to run forever. Of course we also want them to run quickly, but it would be nice if we had a guarantee that no matter what we did, we </span><span class="c7">cannot</span><span class="c4"> create an infinite loop. The STLC is very useful in some of these settings. Another example of a place where we want guaranteed termination is in program linking, and the module language of Standard ML is therefore built atop the STLC: it lets you even write higher-order programs, but the type language guarantees that all module compositions (linkages) will terminate.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Second, many long-running programs are actually a composition of an infinite loop and a short-running program. Think about an operating system with device drivers, a Web server with a Web application, a GUI with callbacks, etc. In each case, there is a “spine” of an infinite loop that simply keeps the program reactive, and “ribs” of short computations that do a little specific work and terminate. In fact, on the Web these programs </span><span class="c7">must</span><span class="calibre3"> terminate quickly, otherwise the Web browser thinks the server has hung and offers to kill the window! These kinds of </span><span class="c7">reactive systems</span><span class="c4"> are therefore a composition of a very generic infinite loop calling out to specific programs for which a termination guarantee will often be very useful.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Finally, observe that we’ve learned something profound. Until now, we have probably thought of types as just a convenience or as a way of eliminating basic errors. However, we have just now seen that adding a type system can </span><span class="c7">change the expressive power of a language</span><span class="c4">. That is, these types are “semantic”.</span></p></body></html>
