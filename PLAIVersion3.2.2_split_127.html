<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.i5byz3jrh4uv"><span class="c4">Union Types</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Oopsâ€”what do we write here?!? We have to also introduce a notion of a binary tree. But we already have two existing types, </span><span class="c28">mt</span><span class="calibre3">Â and (in progress) </span><span class="c28">node</span><span class="calibre3">. Therefore, we need a way to define a binary tree that has a sum that combines these two existing types. This suggests that we have a way of describing a new type as a </span><span class="c7">union</span><span class="c4">Â of existing types:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define-type-alias BT (U mt node))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Observe that in this case, there are no special constructors to distinguish between the two kinds of BT. Therefore, this is called an </span><span class="c7">untagged union</span><span class="calibre3">, in contrast to tagged unions [</span><span class="c16"><a class="c11" href="PLAIVersion3.2.2_split_120.html#h.e43aokkp4uwk">ðŸ‘‰</a></span><span class="c4">].</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Now we can go back and complete our definition of </span><span class="c28">node</span><span class="c4">:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(struct node ([v : Number] [l : BT] [r : BT]))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Now letâ€™s look at what Typed Racket tells us are the types of </span><span class="c28">node</span><span class="c4">â€™s constructor, predicate, and selectors:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">&gt; node</span></p><p class="c5"><span class="c41">- : (-&gt; Number BT BT node)</span></p><p class="c5"><span class="c41">&gt; node-v</span></p><p class="c5"><span class="c41">- : (-&gt; node Number)</span></p><p class="c5"><span class="c41">&gt; node-l</span></p><p class="c5"><span class="c41">- : (-&gt; node BT)</span></p><p class="c5"><span class="c41">&gt; node-r</span></p><p class="c5"><span class="c41">- : (-&gt; node BT)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Using these definitions we can create trees: e.g.,</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define t1</span></p><p class="c5"><span class="c41">Â  (node 5</span></p><p class="c5"><span class="c41">Â  Â  Â  Â  (node 3</span></p><p class="c5"><span class="c41">Â  Â  Â  Â  Â  Â  Â  (node 1 (mt) (mt))</span></p><p class="c5"><span class="c41">Â  Â  Â  Â  Â  Â  Â  (mt))</span></p><p class="c5"><span class="c41">Â  Â  Â  Â  (node 7</span></p><p class="c5"><span class="c41">Â  Â  Â  Â  Â  Â  Â  (mt)</span></p><p class="c5"><span class="c41">Â  Â  Â  Â  Â  Â  Â  (node 9 (mt) (mt)))))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">But now letâ€™s try to write a program to compute its size:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define (size-tr [t : BT]) : Number</span></p><p class="c5"><span class="c41">Â  (cond</span></p><p class="c5"><span class="c41">Â  Â  [(mt? t) 0]</span></p><p class="c5"><span class="c41">Â  Â  [(node? t) (+ 1 (size-tr (node-l t)) (size-tr (node-r t)))]))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">It is not clear at all that this program should type-check. Consider the expression </span><span class="c28">(node-l t)</span><span class="calibre3">. The type of </span><span class="c28">node-l</span><span class="calibre3">Â expects its argument to be of type </span><span class="c28">node</span><span class="calibre3">. However, all we know is that </span><span class="c28">t</span><span class="calibre3">Â is of type </span><span class="c28">BT</span><span class="c4">. Yet this program type-checks!</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">The fact that this does type-check, however, should not fill us with too much joy. We saw how </span><span class="c28">size-wrong</span><span class="c4">Â type-checked, only to halt with an undesired run-time error. So what if we instead write its analog, which is this?</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define (size-tr-wrong [t : BT]) : Number</span></p><p class="c5"><span class="c41">Â  (+ 1 (size (node-l t)) (size (node-r t))))</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="calibre3">This program does </span><span class="c40">not</span><span class="calibre3">Â type-check! Instead, it gives us a type error of exactly the sort we would have expected: </span><span class="c28">node-l</span><span class="calibre3">Â and </span><span class="c28">node-r</span><span class="calibre3">Â both complain that they were expecting an </span><span class="c28">node</span><span class="calibre3">Â and were given a </span><span class="c28">BT</span><span class="calibre3">. So the wonder is not that </span><span class="c28">size-tr-wrong</span><span class="calibre3">Â has a type-error, but rather that </span><span class="c28">size-tr</span><span class="c4">Â does not!</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">To understand why it type-checks, we have to go back to the types of the predicates:</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">&gt; mt?</span></p><p class="c5"><span class="c41">- : (-&gt; Any Boolean : mt)</span></p><p class="c5"><span class="c41">&gt; node?</span></p><p class="c5"><span class="c41">- : (-&gt; Any Boolean : node)</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="calibre3">Critically, the </span><span class="c28">: mt</span><span class="calibre3">Â and </span><span class="c28">: node</span><span class="calibre3">Â are Typed Racketâ€™s way of saying that the Boolean will be true only when the input is an </span><span class="c28">mt</span><span class="calibre3">Â or </span><span class="c28">node</span><span class="calibre3">, respectively. This crucial </span><span class="c7">refinement</span><span class="calibre3">Â information is picked up by the type-checker. In the right-hand-side of the </span><span class="c28">cond</span><span class="calibre3">Â clauses, it </span><span class="c7">narrows</span><span class="calibre3">Â the type of </span><span class="c28">t</span><span class="calibre3">Â to be </span><span class="c28">mt</span><span class="calibre3">Â and </span><span class="c28">node</span><span class="calibre3">, respectively. Thus, </span><span class="c28">(node-l t)</span><span class="calibre3">Â is type-checked in a type environment where the type of </span><span class="c28">t</span><span class="calibre3">Â is </span><span class="c28">node</span><span class="calibre3">Â and not </span><span class="c28">BT</span><span class="c4">.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">To test this theory, we can try another wrong program:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define (size-tr-w2 [t : BT]) : Number</span></p><p class="c5"><span class="c41">Â  (cond</span></p><p class="c5"><span class="c41">Â  Â  [(node? t) 0]</span></p><p class="c5"><span class="c41">Â  Â  [(mt? t) (+ 1 (size-tr-w2 (node-l t)) (size-tr-w2 (node-r t)))]))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Here, we have swapped the predicates. It is not only important that this version produces a type error, it is also instructive to understand why, by reading the type error. This explicitly says that the program expected an </span><span class="c28">node</span><span class="calibre3">Â (for instance, in </span><span class="c28">node-l</span><span class="calibre3">) and was given an </span><span class="c28">mt</span><span class="calibre3">Â (based on the </span><span class="c28">mt?</span><span class="c4">). This confirms that Typed Racket is refining the types in branches based on predicates.</span></p></body></html>
