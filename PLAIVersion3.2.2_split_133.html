<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.69zcn56ptd5w"><span class="c4">If-Splitting with Control Flow and State</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Here’s another program, taken from the Python 2.5.2 standard library:</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">def insort_right(a, x, lo=0, hi=None):</span></p><p class="c5"><span class="c41">    if hi is None:</span></p><p class="c5"><span class="c41">        hi = len(a)</span></p><p class="c5"><span class="c41">    while lo &lt; hi:</span></p><p class="c5"><span class="c41">        mid = (lo+hi)//2</span></p><p class="c5"><span class="c41">        if x &lt; a[mid]: hi = mid</span></p><p class="c5"><span class="c41">        else: lo = mid+1</span></p><p class="c5"><span class="c41">    a.insert(lo, x)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">This function inserts an element (</span><span class="c28">x</span><span class="calibre3">) into an already-sorted list (</span><span class="c28">a</span><span class="calibre3">). It also takes a low search interval index (</span><span class="c28">lo</span><span class="calibre3">), which defaults to </span><span class="c28">0</span><span class="calibre3">, and a high interval (</span><span class="c28">hi</span><span class="calibre3">), which defaults to </span><span class="c28">None</span><span class="c4">. It inserts the element into the right place in the array.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Now let’s ask whether this is actually type-correct. Observe that </span><span class="c28">lo</span><span class="calibre3"> and </span><span class="c28">hi</span><span class="c4"> are used in several arithmetic operations. These are the ones we’re most interested in.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">If it helps, here’s the code with type annotations in </span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://github.com/facebookincubator/cinder&amp;sa=D&amp;source=editors&amp;ust=1695232021481698&amp;usg=AOvVaw2pIqSg2CpkTCGrPRBDemlf">Static Python</a></span><span class="c4">:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">from typing import Optional</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">def insort_right(a, x, lo: int = 0, hi: Optional[int] = None):</span></p><p class="c5"><span class="c41">    if hi is None:</span></p><p class="c5"><span class="c41">        hi = len(a)</span></p><p class="c5"><span class="c41">    while lo &lt; hi:</span></p><p class="c5"><span class="c41">        mid = (lo+hi)//2</span></p><p class="c5"><span class="c41">        if x &lt; a[mid]:</span></p><p class="c5"><span class="c41">            hi = mid</span></p><p class="c5"><span class="c41">        else:</span></p><p class="c5"><span class="c41">            lo = mid+1</span></p><p class="c5"><span class="c41">    a.insert(lo, x)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">(In Static Python, </span><span class="c28">Optional[T]</span><span class="calibre3"> is an abbreviation for </span><span class="c28">(T U None)</span><span class="calibre3">. So the annotation on </span><span class="c28">hi</span><span class="calibre3"> above allows the user to pass in either an </span><span class="c28">int</span><span class="calibre3"> or </span><span class="c28">None</span><span class="calibre3">. What makes the last two arguments optional is (perhaps confusingly) not the type </span><span class="c28">Optional</span><span class="c4"> but rather the fact that they have default values in the function header.)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">It’s easier to see what’s happening with </span><span class="c28">lo</span><span class="calibre3">: it’s allowed to be optional; if the optional argument is provided, it must be an </span><span class="c28">int</span><span class="calibre3">; and if it’s not provided, it has value </span><span class="c28">0</span><span class="calibre3">, which also has type </span><span class="c28">int</span><span class="calibre3">. So its type is effectively </span><span class="c28">(int U int)</span><span class="calibre3">, which is just </span><span class="c28">int</span><span class="calibre3">, so all uses of </span><span class="c28">lo</span><span class="calibre3"> as an </span><span class="c28">int</span><span class="c4"> are fine.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">But now consider the type of </span><span class="c28">hi</span><span class="calibre3">. It is also optional. If it is provided, it has to be an </span><span class="c28">int</span><span class="calibre3">, which would be fine. But if it’s </span><span class="c7">not</span><span class="calibre3"> provided, its value is </span><span class="c28">None</span><span class="calibre3">, which cannot be used in arithmetic. However, right at the top, the function checks whether it is </span><span class="c28">None</span><span class="calibre3"> and, if so, </span><span class="c7">changes</span><span class="calibre3"> it to the result of </span><span class="c28">len(a)</span><span class="calibre3">—which is an </span><span class="c28">int</span><span class="calibre3">. Therefore, once the if is done, no matter which path the program takes, </span><span class="c28">hi</span><span class="calibre3"> is an </span><span class="c28">int</span><span class="c4">. Thus, the program is actually type-safe.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">That’s all well and good for us to reason about by hand. However, our job is to build a type-checker that will neither reject programs needlessly nor approve type-incorrect programs. This balance is very hard to maintain.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">This represents the challenge retrofitted type system designers face: they must either reject idiomatic programs or add complexity to the type system to handle them. If we reject the program, we reject many other programs like it, which are idiomatically found in many “scripting” languages. The result would be very safe, but also very useless—indeed, safe </span><span class="c7">because</span><span class="c4"> it would be very useless—type-checker (a type-checker that rejects every program would be extremely safe…). Instead, we need an even more complicated solution than what we have seen until now.</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Aside:</span><span class="calibre3"> See </span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://cs.brown.edu/people/sk/Publications/Papers/Published/gsk-flow-typing-theory/&amp;sa=D&amp;source=editors&amp;ust=1695232021485488&amp;usg=AOvVaw2-6nKeOUE7cQ6F3KqzAJ7z">this paper</a></span><span class="calibre3"> for how to type such programs.</span></p></body></html>
