<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h1 class="c29" id="h.759kfdvfe109"><span class="c4"></span></h1><h1 class="c30" id="h.j0kt5t35bpug"><span class="c4">Growing Types: Division, Conditionals</span></h1><h2 class="c23" id="h.5z2pgu9d57y5"><span class="c4">Handling Division</span></h2><p class="c5"><span class="calibre3">Addition, multiplication, and subtraction are </span><span class="c7">total</span><span class="calibre3"> functions over numbers: they consume two numbers and produce one. In contrast, division is a </span><span class="c7">partial</span><span class="c4"> function: it isn’t defined when the denominator is zero. Therefore, we need a strategy for handling it. There are several available strategies:</span></p><p class="c3"><span class="c4"></span></p><ol class="c88" start="1"><li class="pcalibre13 c89"><span class="calibre3">We can declare that division doesn’t </span><span class="c7">return</span><span class="calibre3"> a number but instead something else that captures its partiality, such as </span><span class="c28">(Optionof Number)</span><span class="c4">. This can work just fine. However, it means every single use of division will need to check whether it obtained a proper number or not. This can get quite onerous.</span></li><li class="pcalibre13 c89"><span class="calibre3">We can declare that division only </span><span class="c7">consumes</span><span class="calibre3"> non-zero numbers in its second argument. This is a major change to our type system, because until now we had lumped all numbers together into a single numeric type. This now affects all callers of division, who must now prove that they are not calling it on zero as the second argument. This is onerous in a different way. Observe that the type checker cannot automatically prove that a value is non-zero without error, because this is not decidable (see </span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://en.wikipedia.org/wiki/Rice%2527s_theorem&amp;sa=D&amp;source=editors&amp;ust=1695232021350115&amp;usg=AOvVaw1sfdnpfOgVLtiDbnXxEjlG">Rice’s Theorem</a></span><span class="c4">).</span></li><li class="pcalibre13 c89"><span class="c4">We give it the same type as other binary numeric operations, and declare that the exceptional case will be handled by an exception or error. This implicitly puts the burden on the rest of the program, which must be aware of this possibility and handle it.</span></li></ol><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">For more about general strategies for handling partial functions, see</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://dcic-world.org/2022-08-28/partial-domains.html&amp;sa=D&amp;source=editors&amp;ust=1695232021350790&amp;usg=AOvVaw1xa-O5dafyrpg45paMpzmj">https://dcic-world.org/2022-08-28/partial-domains.html</a></span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Most programming languages have taken the third option above, which seems the most pragmatic. However, a growing number of languages are exploring the first two options. They get around Rice’s Theorem in the second case by trying to prove non-zero-ness and, when they cannot, putting the burden on the programmer. While this creates more effort for the programmer, it increases the program’s robustness.</span></p></body></html>
