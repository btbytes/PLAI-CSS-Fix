<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.n0mbf5n0cyae"><span class="c4">Space Consumption</span></h2><p class="c5"><span class="c4">The ability to automatically memoize computation seems to show even more benefit to making lazy evaluation a default. Why not do it?</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">One problem is that lazy evaluation can often take up significant amounts of space, </span><span class="c7">beyond</span><span class="c4"> the space consumed by memoization. To understand this, consider this squaring function:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define (sq x)</span></p><p class="c5"><span class="c41">  (* x x))</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="calibre3">Because we are evaluating lazily, </span><span class="c28">x</span><span class="calibre3"> is bound to an </span><span class="c7">expression</span><span class="c4"> represented as a closure. Now suppose our program looks like</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define v (make-vector 1000 0))</span></p><p class="c5"><span class="c41">(sq (vector-ref v 2))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">and beyond this we make no further reference to </span><span class="c28">v</span><span class="calibre3">. In an eager language, we would extract the second element of </span><span class="c28">v</span><span class="calibre3"> and can reclaim all the remaining storage. But in a lazy language, the </span><span class="c7">entire vector</span><span class="c4"> needs to stay alive until the last use of the closure that refers to it. Seemingly straightforward programs that have an intuitive space model in an eager language can have much more subtle and complicated space models in lazy programming. Observe that the issue above has nothing to do with memoization; it’s inherent in laziness.</span></p></body></html>
