<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.tho13dunr1bq"><span class="c4">A Subtle Test</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">In the examples above, we always use the closure in the scope in which it was defined. However, our language is actually more powerful than that: we can </span><span class="c7">return</span><span class="calibre3"> a closure and use it </span><span class="c7">outside</span><span class="c4"> the scope in which it was defined. Here’s a sample Racket program:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">((let ([x 3])</span></p><p class="c5"><span class="c41">   (lambda (y) (+ x y)))</span></p><p class="c5"><span class="c41"> 4)</span></p><p class="c3"><span class="c41"></span></p><p class="c31"><span class="c40">Do Now:</span><span class="c4"> Take a moment to read it carefully. What should it produce?</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">First we bind the </span><span class="c28">x</span><span class="calibre3">, then we evaluate the lambda. This creates a closure that remembers the binding to </span><span class="c28">x</span><span class="c4">. This closure is the value returned by this expression:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c28">(</span><span class="c65">(let ([x 3])</span></p><p class="c5"><span class="c65">   (lambda (y) (+ x y)))</span></p><p class="c5"><span class="c28"> 4)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">This value is now applied to </span><span class="c28">4</span><span class="calibre3">. It’s legal to do this, because the value returned is a function. When we apply it to </span><span class="c28">4</span><span class="calibre3">, that evaluates the sum of </span><span class="c28">4</span><span class="calibre3"> and </span><span class="c28">3</span><span class="calibre3">, producing </span><span class="c28">7</span><span class="calibre3">. Sure enough, translating this and sending it to our interpreter produces </span><span class="c28">7</span><span class="c4">:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(test (interp (appE (let1E 'x (numE 3)</span></p><p class="c5"><span class="c41">                           (lamE 'y (plusE (varE 'x) (varE 'y))))</span></p><p class="c5"><span class="c41">                    (numE '4))</span></p><p class="c5"><span class="c41">              mt-env)</span></p><p class="c5"><span class="c41">      (numV 7))</span></p><p class="c3"><span class="c41"></span></p><p class="c31"><span class="c40">Exercise:</span><span class="c4"> Here’s another test to try out, written as a Racket program:</span></p><p class="c51"><span class="c4"></span></p><p class="c31"><span class="c41">((let ([y 3])</span></p><p class="c31"><span class="c41">   (lambda (y) (+ y 1)))</span></p><p class="c31"><span class="c41"> 5)</span></p><p class="c51"><span class="c41"></span></p><p class="c31"><span class="c4">What does it produce in Racket? Translate it and try it in your interpreter.</span></p></body></html>
