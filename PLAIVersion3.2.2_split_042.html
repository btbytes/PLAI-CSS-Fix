<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.adxf5kdwo57u"><span class="c4">Caching Substitution</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">We repeatedly—and rightly—refer back to substitution to understand how programs should work, and indeed will do so again later. But substitution as an </span><span class="c7">evaluation</span><span class="calibre3"> technique is messy. This requires us to constantly keep rewriting the program text, which takes time linear in the size of the program (which can get quite large) for </span><span class="c7">every</span><span class="c4"> variable binding. Most real language implementations do not work this way.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Instead, we might think of employing a space-time tradeoff: we’ll use a little extra space to save ourselves a whole lot of time. That is, we’ll </span><span class="c7">cache</span><span class="calibre3"> the substitution in a data structure called the </span><span class="c7">environment</span><span class="c4">. An environment records names and their corresponding values: that is, it’s a collection of key-value pairs. Thus, whenever we encounter a binding we remember its value, and when we encounter a variable, we look up its value.</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Aside: </span><span class="calibre3">A</span><span class="calibre3">s with all caches, we want them to only improve performance along a dimension, not change the meaning. That is, we no longer want substitution to define </span><span class="c7">how</span><span class="calibre3"> we produce an answer. But, we still want it to tell us </span><span class="c7">what</span><span class="c4"> answer to produce. This will become important below.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">We will use a hash table to represent the environment:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define-type-alias Env (Hashof Symbol Value))</span></p><p class="c5"><span class="c41">(define mt-env (hash empty)) ;; "empty environment"</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">We will need the interpreter to actually take an environment as a formal parameter, to use in place of substitution. Thus:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(interp : (Exp Env -&gt; Value))</span></p><p class="c5"><span class="c41">(define (interp e nv) …)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Now what happens when we encounter a variable? We try to look it up in the environment. That may succeed or, in the case of our last example above, fail. We will use </span><span class="c28">hash-ref</span><span class="calibre3">, which looks up keys in hash tables, and returns an </span><span class="c28">Optionof</span><span class="c4"> type to account for the possibility of failure. We can encapsulate it in a function that we will repeatedly find useful:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define (lookup (s : Symbol) (n : Env))</span></p><p class="c5"><span class="c41">  (type-case (Optionof Value) (hash-ref n s)</span></p><p class="c5"><span class="c41">    [(none) (error s "not bound")]</span></p><p class="c5"><span class="c41">    [(some v) v]))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">In the event the lookup succeeds, then we want the value found, which is wrapped in </span><span class="c28">some</span><span class="c4">. This function  enables our interpreter to stay very clean and readable:</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">    [(varE s) (lookup s nv)]</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Finally, we are ready to tackle </span><span class="c28">let1</span><span class="c4">. What happens here? We must </span></p><ul class="c24"><li class="c25 pcalibre"><span class="c4">evaluate the body of the expression, in</span></li><li class="c25 pcalibre"><span class="c4">an environment that has been extended, with</span></li><li class="c25 pcalibre"><span class="c4">the new name </span></li><li class="c25 pcalibre"><span class="c4">bound to its value.</span></li></ul><p class="c5"><span class="c4">Phew!</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Fortunately, this isn’t as bad as it sounds. Again, a function will help a lot:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(extend : (Env Symbol Value -&gt; Env))</span></p><p class="c5"><span class="c41">(define (extend old-env new-name value)</span></p><p class="c5"><span class="c41">  (hash-set old-env new-name value))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">With this, we can see the structure clearly:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">    [(let1E var val body)</span></p><p class="c5"><span class="c41">     (let ([new-env (extend nv</span></p><p class="c5"><span class="c41">                            var</span></p><p class="c5"><span class="c41">                            (interp val nv))])</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="calibre3">(Observe that we used </span><span class="c28">let</span><span class="calibre3"> in plait to define </span><span class="c28">let1</span><span class="c4"> in Paret. We’ll see more of this…)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">In sum, our core interpreter is now:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define (interp e nv)</span></p><p class="c5"><span class="c41">  (type-case Exp e</span></p><p class="c5"><span class="c41">    [(numE n) n]</span></p><p class="c5"><span class="c41">    [(varE s) (lookup s nv)]</span></p><p class="c5"><span class="c41">    [(plusE l r) (+ (interp l nv) (interp r nv))]</span></p><p class="c5"><span class="c41">    [(let1E var val body)</span></p><p class="c5"><span class="c41">     (let ([new-env (extend nv</span></p><p class="c5"><span class="c41">                            var</span></p><p class="c5"><span class="c41">                            (interp val nv))])</span></p><p class="c5"><span class="c41">       (interp body new-env))]))</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Exercise:</span><span class="c4"> </span></p><ol class="c66" start="1"><li class="pcalibre9 c67"><span class="calibre3">What if we had not called </span><span class="c28">(interp val nv)</span><span class="c4"> above?</span></li><li class="pcalibre9 c67"><span class="calibre3">What if we’d used </span><span class="c28">nv</span><span class="calibre3"> instead of </span><span class="c28">new-env</span><span class="calibre3"> in the call to </span><span class="c28">interp</span><span class="c4">?}</span></li><li class="pcalibre9 c67"><span class="c4">Are there any other errors in the interpreter based on copying what we had before?</span></li><li class="pcalibre9 c67"><span class="c4">We seem to extend the environment but never remove anything from it. Is that okay? If not, it should cause an error. What program would demonstrate this error, and does it actually do so? (If not, why not?)</span></li></ol><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">This concludes our first interesting “programming language”. We have already been forced to deal with some fairly subtle questions of scope, and with how to interpret them. Things will only get more interesting from here!</span></p></body></html>
