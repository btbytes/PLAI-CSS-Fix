<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.nyfouco82zsf"><span class="c4">More Informal Examples</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">With that important detail out of the way, let’s return to our process of </span><span class="c7">inferring</span><span class="calibre3"> or </span><span class="c7">reconstructing</span><span class="c4"> the types of variables from the way they’re used in a program. Here’s another example with a two-parameter function:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(lambda ((x : ___) (y : ___))</span></p><p class="c5"><span class="c41">  (if x</span></p><p class="c5"><span class="c41">      (+ y 1)</span></p><p class="c5"><span class="c41">      (+ y 2)))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Once again, we can’t just calculate its type with our type-checker; instead, we must reconstruct the type from the function body. Let’s do that. What can we tell? Let’s again refer to the conditional rule:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c97">Γ </span><span class="c28">|- C : Bool    </span><span class="c97">Γ </span><span class="c28">|- T : U    </span><span class="c97">Γ </span><span class="c41">|- E : U</span></p><p class="c5"><span class="c41">-----------------------------------------</span></p><p class="c5"><span class="c97">Γ </span><span class="c28">|- (if C T E) : U</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">This tells us that what’s in the </span><span class="c28">C</span><span class="calibre3"> position—here, </span><span class="c28">x</span><span class="calibre3">—must be a </span><span class="c28">Bool</span><span class="calibre3">. Furthermore, both branches </span><span class="c28">(+ y 1)</span><span class="calibre3"> and </span><span class="c28">(+ y 2)</span><span class="calibre3"> must have the same type. That’s all we can learn from the rule for </span><span class="c28">if</span><span class="calibre3">! But now we can (and must) recur into the sub-expressions. Each one is an addition, and the addition rule tells us that both arguments must be </span><span class="c28">Num</span><span class="calibre3">s. Both of these indicate that the type of </span><span class="c28">y</span><span class="calibre3"> must be </span><span class="c28">Num</span><span class="calibre3">. Furthermore, both indicate that the overall addition returns a </span><span class="c28">Num</span><span class="c4">. From that we can tell that the entire expression must have the type</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(Bool Num -&gt; Num)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">By this process, we can figure out what types to put in the missing annotations. More subtly, notice that by running through this process, we have effectively applied all the typing rules; therefore, if we have successfully reconstructed the type annotations, we need not bother type-checking the program with those annotations: it will have to type-check.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Now let’s consider a slight variation on the above program:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(lambda (x : ___)</span></p><p class="c5"><span class="c41">  (if x</span></p><p class="c5"><span class="c41">      (+ x 1)</span></p><p class="c5"><span class="c28">      (+ x 2)))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Now let’s figure out everything we can learn about </span><span class="c28">x</span><span class="c4"> from the function’s body:</span></p><ul class="c24"><li class="c25 pcalibre"><span class="c28">x</span><span class="calibre3"> is used in the conditional position of an </span><span class="c28">if</span><span class="calibre3">. Therefore, it must have type </span><span class="c28">Bool</span><span class="c4">.</span></li><li class="c25 pcalibre"><span class="c28">x</span><span class="calibre3"> is used as a parameter to </span><span class="c28">+</span><span class="calibre3">. Therefore, it must have type </span><span class="c28">Num</span><span class="c4">.</span></li><li class="c25 pcalibre"><span class="c28">x</span><span class="calibre3"> is again used as a parameter to </span><span class="c28">+</span><span class="calibre3">. Therefore, it must have type </span><span class="c28">Num</span><span class="c4">.</span></li></ul><p class="c5"><span class="calibre3">Notice that each of these conclusions is perfectly fine on its own. However, when we </span><span class="c7">put them together</span><span class="calibre3"> (which is what we meant by “additional information” above), there’s a problem: </span><span class="c28">x</span><span class="calibre3"> cannot be both of those. That is, we are unable to find a single type for </span><span class="c28">x</span><span class="calibre3">. This inability to find a type for </span><span class="c28">x</span><span class="calibre3"> means that the program has a </span><span class="c7">type error</span><span class="calibre3">. And indeed, there </span><span class="c7">is</span><span class="c4"> no type we could have given that would have enabled this program to execute safely.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Observe something subtle. While we can report that the program clearly has a type error, our error message must necessarily be much more ambiguous. Previously, when we had a type annotation on </span><span class="c28">x</span><span class="calibre3">, we could pinpoint where the error occurred. Now, all we can say is that the program is not type-</span><span class="c7">consistent</span><span class="calibre3">, but cannot blame one spot or the other without potentially misleading the programmer. Instead, we must report all these locations and let the programmer decide where the error is based on their </span><span class="c7">unstated intent</span><span class="c4"> (in the form of a type annotation).</span></p></body></html>
