<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.whl38kyxs86p"><span class="c4">Pattern-Matching and Type-Checking</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">This kind of error cannot occur naturally in languages like OCaml and Haskell. Instead of exposing all these predicates and accessors, instances of an algebraic datatype are deconstructed using pattern-matching. Thus, the size computation would be written as (</span><span class="c28">-pm</span><span class="c4"> stands for “pattern matching”):</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(size-pm : (BT -&gt; Number))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define (size-pm t)</span></p><p class="c5"><span class="c41">  (type-case BT t</span></p><p class="c5"><span class="c41">    [(mt) 0]</span></p><p class="c5"><span class="c41">    [(node v l r) (+ 1 (+ (size-pm l) (size-pm r)))]))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">This might seem like a convenience—it certainly makes the code much more compact and perhaps also much more readable—but it’s also doing something more. The pattern-matcher is effectively baked into the way programs are type-checked. That is, the above algebraic datatype definition effectively adds the following typing rule to the type checker:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c97">Γ </span><span class="c28">|- e : </span><span class="c91">BT</span></p><p class="c5"><span class="c109">Γ</span><span class="c97"> </span><span class="c28">|- e1 : </span><span class="c110">T</span></p><p class="c5"><span class="c97">Γ</span><span class="c111">[V &lt;- Number, L &lt;- BT, R &lt;- BT]</span><span class="c97"> </span><span class="c28">|- e2 : </span><span class="c110">T</span></p><p class="c5"><span class="c41">-----------------------------------------</span></p><p class="c5"><span class="c109">Γ</span><span class="c97"> </span><span class="c41">|- (type-case BT e</span></p><p class="c5"><span class="c41">       [(mt) e1]</span></p><p class="c5"><span class="c28">       [(node V L R) e2]) : T</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">The first antecedent is clear: we have to confirm that the expression </span><span class="c28">e</span><span class="calibre3"> evaluates to a </span><span class="c90">BT</span><span class="calibre3"> before we pattern-match </span><span class="c28">BT</span><span class="calibre3"> patterns against it. The second type-checks </span><span class="c28">e1</span><span class="calibre3"> in the </span><span class="c112">same</span><span class="calibre3"> environment as in the consequent because the </span><span class="c28">mt</span><span class="calibre3"> variant does not add any local bindings. The type of this expression needs to be the </span><span class="c113">same</span><span class="calibre3"> as the type from the other branch, due to how we’re handling conditionals. Finally, to type-check </span><span class="c28">e2</span><span class="calibre3">, we have to </span><span class="c114">extend</span><span class="calibre3"> the consequent’s type environment with the bound variables; their types we can read off directly from the data </span><span class="c7">definition</span><span class="c4">. In short, the above typing rule can be defined automatically by desugaring.</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Aside:</span><span class="calibre3"> Notice that there is also an assume-guarantee here: we type-check </span><span class="c28">e2</span><span class="calibre3"> in an environment that </span><span class="c7">assumes</span><span class="calibre3"> the annotated types; this is </span><span class="c7">guaranteed</span><span class="calibre3"> by the </span><span class="c28">node</span><span class="c4"> constructor.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">In particular, observe what we </span><span class="c7">couldn’t</span><span class="calibre3"> do! We didn’t have awkward selectors, like </span><span class="c28">node-v</span><span class="calibre3">, for which we had to come up with some type. By saying they consumed a </span><span class="c28">BT</span><span class="calibre3">, we had to let them statically consume any kind of </span><span class="c28">BT</span><span class="calibre3">, which caused a problem at run-time. Here, there is </span><span class="c7">no selector</span><span class="calibre3">: pattern-matching means we can only write pattern-variables in variants where the algebraic datatype definition permits it, and the variables automatically gets the right type. Thus, pattern-matching plays a crucial role in the </span><span class="c7">statically safe</span><span class="c4"> handling of types.</span></p></body></html>
