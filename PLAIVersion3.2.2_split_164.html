<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.r1ucqb2c2bz7"><span class="c4">Yielding on a Web Server</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">The Racket Web server has a special primitive that does just this for the Web. We’ll build it up in stages. First, we’ll use a special Racket language, designed to make it easier to write server-side Web programs:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">#lang web-server/insta</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Programs in this language must have a “main” function, called </span><span class="c28">start</span><span class="calibre3">, which is given an initial request (whatever information is provided when we first run the computation). This function is then written assuming a convenient fiction: the existence of a function </span><span class="c28">get-number</span><span class="calibre3"> that will print a prompt, send out a Web page, </span><span class="c7">wait for its response</span><span class="c4">, extract the value entered, and return it as a number:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define (start req)</span></p><p class="c5"><span class="c28">  (let ([result </span><span class="c64">(+ (get-number "first") (get-number "second"))</span><span class="c41">])</span></p><p class="c5"><span class="c41">    (response/xexpr</span></p><p class="c5"><span class="c41">     `(html (body (p "The result is " ,(number-&gt;string result)))))))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">If we can make this fiction reality, then we can write a program like the above: it calls </span><span class="c28">get-number</span><span class="c4"> in a “deep” context, twice, adds the results, and then converts the result into a string to embed it into a Web page.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">The question, of course, is how such a function can exist. First, we have to discuss some Web mechanics. When we create a Web form, it needs a field called the </span><span class="c28">action</span><span class="calibre3">, which holds a URL. When the user submits the form, the browser bundles up the information entered into the fields of the form and sends them—effectively, as a set of key-value pairs—</span><span class="c7">to the URL</span><span class="c4">, i.e., to the server, requesting it to run the program at that URL and provide the key-value pairs to that program.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Therefore, we can see that we’ve turned the problem of suspending the program’s execution into one of being able to fill in this URL with something meaningful. If the URL can somehow correspond to the stack, then perhaps the stack (and hence the computation) can be restored, and can be provided with these key-value pairs, from which the program can extract the required information.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">The “secret sauce” that the Racket Web server provides is a primitive called </span><span class="c28">send/suspend</span><span class="c4">. It does the following:</span></p><p class="c3"><span class="c4"></span></p><ul class="c24"><li class="c25 pcalibre"><span class="calibre3">It takes a </span><span class="c7">single-argument function</span><span class="c4"> as a parameter. </span></li><li class="c25 pcalibre"><span class="c4">It records the current stack as a value.</span></li><li class="c25 pcalibre"><span class="c4">It stores this stack in a hash-table, associated with a unique, unguessable string.</span></li><li class="c25 pcalibre"><span class="c4">It turns this string into a URL.</span></li><li class="c25 pcalibre"><span class="calibre3">It then </span><span class="c7">calls</span><span class="c4"> the given function with this URL string.</span></li></ul><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">The resulting function can then use this URL string as the </span><span class="c28">action</span><span class="c4"> field of the form.</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Aside:</span><span class="c4"> This is not the only way to use it. The URL could also, for instance, be sent in an email message. This is a handy way to validate email addresses. Because the URL is unique and unguessable, the only way for someone to resume the computation would be to receive that URL, i.e., to have access to the email address. Thus, resuming the computation can be thought of as having validated the email address (assuming, of course, that an intruder is not reading emails and clicking on validation links that the email’s owner would not have clicked on).</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">So here is an actual working implementation of get-number:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define (get-number which)</span></p><p class="c5"><span class="c41">  (define title (format "What is the ~a number?" which))</span></p><p class="c5"><span class="c41">  (define req</span></p><p class="c5"><span class="c41">    (send/suspend</span></p><p class="c5"><span class="c41">     (lambda (k-url)</span></p><p class="c5"><span class="c28">       </span><span class="c141">(response/xexpr</span></p><p class="c5"><span class="c28">        </span><span class="c142">`(html (head (title ,title))</span></p><p class="c5"><span class="c115">               (body</span></p><p class="c5"><span class="c115">                (form ([action ,</span><span class="c143">k-url</span><span class="c142">])</span></p><p class="c5"><span class="c142">                      ,title ": "</span></p><p class="c5"><span class="c142">                      (input ([name "number"]))</span></p><p class="c5"><span class="c115">                      (input ([type "submit"]))))</span><span class="c144">)</span><span class="c41">))))</span></p><p class="c5"><span class="c41">  (string-&gt;number</span></p><p class="c5"><span class="c28">    </span><span class="c141">(extract-binding/single 'number</span></p><p class="c5"><span class="c144">      (request-bindings req))</span><span class="c41">))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Observe that most of this function is just </span><span class="c145">HTML</span><span class="calibre3"> and </span><span class="c146">API</span><span class="calibre3"> bookkeeping. We have to construct the Web page with the relevant components. When (if) the computation resumes, it returns with the key-value pairs sent from the form. These are bound to </span><span class="c28">req</span><span class="c4">. From there, it’s a simple matter of extracting the right value using the APIs.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">And that’s it! That gives us a full, working program.</span></p></body></html>
