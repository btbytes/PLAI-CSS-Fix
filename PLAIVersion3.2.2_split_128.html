<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.jo5pzefb48p1"><span class="c4">If-Splitting</span></h2><p class="c5"><span class="calibre3">To summarize, </span><span class="c28">size-tr</span><span class="c4"> type-checks is because the type-checker is doing something special when it sees the pattern</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define (size-tr [t : BT]) : Number</span></p><p class="c5"><span class="c41">  (cond</span></p><p class="c5"><span class="c41">    [(mt? t) …]</span></p><p class="c5"><span class="c41">    [(node? t) …]))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">It knows that every </span><span class="c28">BT</span><span class="calibre3"> is related to </span><span class="c28">mt</span><span class="calibre3"> and </span><span class="c28">node</span><span class="calibre3"> through the union. When it sees the predicate, it </span><span class="c7">narrows</span><span class="calibre3"> the type from the full union to the branch of the union that the predicate has checked. Thus, in the </span><span class="c28">mt?</span><span class="calibre3"> branch, it narrows the type of </span><span class="c28">t</span><span class="calibre3"> from </span><span class="c28">BT</span><span class="calibre3"> to </span><span class="c28">mt</span><span class="calibre3">; in the </span><span class="c28">node?</span><span class="calibre3"> branch, similarly, it narrows the type of </span><span class="c28">t</span><span class="calibre3"> to just </span><span class="c28">node</span><span class="calibre3">. Now, </span><span class="c28">node-l</span><span class="calibre3">, say, gets confirmation that it is indeed processing a </span><span class="c28">node</span><span class="calibre3"> value, and the program is statically type-safe. In the absence of those predicates, in </span><span class="c28">size-tr-wrong</span><span class="calibre3">, the type of </span><span class="c28">t</span><span class="calibre3"> does not get narrowed, resulting in the error. In </span><span class="c28">size-tr-w2</span><span class="c4">, swapping the predicates also gives an error. Here is one more version:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define (size-tr-else [t : BT]) : Number</span></p><p class="c5"><span class="c41">  (cond</span></p><p class="c5"><span class="c41">    [(mt? t) 0]</span></p><p class="c5"><span class="c41">    [else (+ 1 (size-tr (node-l t)) (size-tr (node-r t)))]))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">This program could go either way! It just so happens that it does type-check in typed/racket, because typed/racket is “smart” enough to determine that there are only two kinds of </span><span class="c28">BT</span><span class="calibre3"> and one has been excluded, so in the </span><span class="c28">else</span><span class="calibre3"> case, it must be the other kind. But one could also imagine a less clever checker that expects to see an explicit test of </span><span class="c28">node?</span><span class="c4"> to be able to bless the second clause.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">In short, both the algebraic datatype and union type approaches need some special treatment of syntax by the type-checker to handle variants. In the former case it’s through pattern-matching. The narrowing technique above is sometimes called </span><span class="c7">if-splitting</span><span class="calibre3">, because an </span><span class="c28">if</span><span class="calibre3"> (which </span><span class="c28">cond</span><span class="calibre3"> and other conditional constructs desugar to) “splits” the union. You will sometimes also see the terms </span><span class="c7">occurrence typing</span><span class="calibre3"> and </span><span class="c7">flow typing</span><span class="c4"> to describe variants of the ideas in this chapter.</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Aside:</span><span class="calibre3"> This idea was invented by </span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://docs.racket-lang.org/ts-guide/occurrence-typing.html&amp;sa=D&amp;source=editors&amp;ust=1695232021469775&amp;usg=AOvVaw0FOrR34cG9UC9PeiZoFxr8">Typed Racket</a></span><span class="c4"> by studying how programmers write code in Scheme and Racket programs. It has later proved to be relevant to many real-world retrofitted type systems.</span></p></body></html>
