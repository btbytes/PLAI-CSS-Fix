<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.alo6yiwuqyeh"><span class="c4">The Meaning of Local Binding</span></h2><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Do Now:</span><span class="calibre3"> Here are some examples of this new construct; what do you </span><span class="c7">expect</span><span class="c4"> each one to produce?</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">{let1 {x 1}</span></p><p class="c5"><span class="c41">  {+ x x}}</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">{let1 {x 1}</span></p><p class="c5"><span class="c41">  {let1 {y 2}</span></p><p class="c5"><span class="c41">    {+ x y}}}</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">{let1 {x 1}</span></p><p class="c5"><span class="c41">  {let1 {y 2}</span></p><p class="c5"><span class="c41">    {let1 {x 3}</span></p><p class="c5"><span class="c41">      {+ x y}}}}</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">{let1 {x 1}</span></p><p class="c5"><span class="c41">  {+ x</span></p><p class="c5"><span class="c41">     {let1 {x 2} x}}}</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">{let1 {x 1}</span></p><p class="c5"><span class="c41">  {+ {let1 {x 2} x}</span></p><p class="c5"><span class="c41">     x}}</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">x</span></p><p class="c3"><span class="c41"></span></p><p class="c31"><span class="c40">Do Now: </span><span class="c4">Oh, did you notice something? None of the above programs is syntactically legal! Why?</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">It’s because there is no syntax yet for variables. Our syntax permits us to </span><span class="c7">bind</span><span class="calibre3"> variables but not to </span><span class="c7">use</span><span class="c4"> them. So we have to fix that:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">&lt;expr&gt; ::= &lt;num&gt;</span></p><p class="c5"><span class="c41">         | {+ &lt;expr&gt; &lt;expr&gt;}</span></p><p class="c5"><span class="c41">         | {let1 {&lt;var&gt; &lt;expr&gt;} &lt;expr&gt;}</span></p><p class="c5"><span class="c28">         | &lt;var&gt;</span></p><p class="c5"><span class="c4"> </span></p><p class="c5"><span class="c4">Now the above terms are all syntactically valid, so we can go back to the question of what they should evaluate to.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">The first two programs are pretty obvious:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">{let1 {x 1}</span></p><p class="c5"><span class="c28">  {+ x x}}</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">should evaluate to 2, and</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">{let1 {x 1}</span></p><p class="c5"><span class="c41">  {let1 {y 2}</span></p><p class="c5"><span class="c28">    {+ x y}}}</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">should evaluate to 3.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">How about this program?</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">{let1 {x 1}</span></p><p class="c5"><span class="c41">  {let1 {y 2}</span></p><p class="c5"><span class="c41">    {let1 {x 3}</span></p><p class="c5"><span class="c41">      {+ x y}}}}</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Here we see the advantage of the parenthetical notation. In a more conventional syntax, this might correspond to</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">x = 1</span></p><p class="c5"><span class="c41">y = 2</span></p><p class="c5"><span class="c41">x = 3</span></p><p class="c5"><span class="c41">x + y</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">where any number of things could happen: we might have two different </span><span class="c28">x</span><span class="calibre3">’s; we might have an </span><span class="c28">x</span><span class="calibre3"> bound and then modified; and in some languages, an introduction of </span><span class="c28">x</span><span class="calibre3"> could be “lifted” so that it’s no longer clear which </span><span class="c28">x</span><span class="calibre3"> is most recent. With our parenthetical syntax, though, it’s pretty clear what scopes we want. To determine the value, we can rely on our old friend, substitution. However, when we substitute the outer </span><span class="c28">x</span><span class="calibre3">, we expect that to stop at the point where the inner </span><span class="c28">x</span><span class="calibre3"> begins: that is, the inner </span><span class="c28">x</span><span class="calibre3"> </span><span class="c7">shadows</span><span class="calibre3"> the outer one. Hence, the result should be </span><span class="c28">5</span><span class="c4">.</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Do Now: </span><span class="calibre3">The example above is uninteresting in that the outer </span><span class="c28">x</span><span class="calibre3"> never sees any use. What kind of program might we write that has two </span><span class="c28">let</span><span class="calibre3"> bindings of </span><span class="c28">x</span><span class="calibre3"> that lets us clearly see that there are two </span><span class="c28">x</span><span class="c4">’s?</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">That’s what this program shows:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">{let1 {x 1}</span></p><p class="c5"><span class="c41">  {+ x</span></p><p class="c5"><span class="c28">     {let1 {x 2} x}}}</span></p><p class="c5"><span class="c4"> </span></p><p class="c5"><span class="calibre3">It seems fairly clear that the left </span><span class="c28">x</span><span class="calibre3"> in the addition should be </span><span class="c28">1</span><span class="calibre3">, while </span><span class="c28">x</span><span class="calibre3"> in the right expression should be shadowed and hence should evaluate to </span><span class="c28">2</span><span class="calibre3">. The sum should therefore be </span><span class="c28">3</span><span class="c4">. Incidentally, DrRacket is useful in such cases, because we can write an equivalent expression in #lang racket—</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(let ([x 1])</span></p><p class="c5"><span class="c41">  (+ x</span></p><p class="c5"><span class="c41">     (let ([x 2]) </span></p><p class="c5"><span class="c41">       x)))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">—and hover over the last </span><span class="c28">x</span><span class="c4">, and DrRacket (for Racket, which represents a fairly ideal form of SMoL) will automatically draw a blue arrow showing where the variable is bound:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre17"><img alt="" src="image18.png" title="" class="calibre18"/></span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Now for a more complex example:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">{let1 {x 1}</span></p><p class="c5"><span class="c41">  {+ {let1 {x 2} x}</span></p><p class="c5"><span class="c28">     x}}</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Here, it’s especially useful to turn to substitution to determine the answer. Again, it seems clear that </span><span class="c28">x</span><span class="calibre3"> in the left expression is shadowed and hence should be </span><span class="c28">2</span><span class="calibre3">. The big question, of course, is what about the </span><span class="c28">x</span><span class="c4"> on the right hand side of the addition (i.e., on the last line)?</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Here, again, conventional textual syntax is fraught with ambiguity: is</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">x = 2</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">on the left a </span><span class="c7">binding</span><span class="calibre3"> of a new </span><span class="c28">x</span><span class="calibre3"> or a</span><span class="c7"> modification</span><span class="calibre3"> of the outer </span><span class="c28">x</span><span class="calibre3">? Those are two very different things! But with our syntax it’s much clearer that it </span><span class="c7">should</span><span class="calibre3"> be the former, not the latter. Thus, by substitution, the outer </span><span class="c28">x</span><span class="calibre3"> is replaced by </span><span class="c28">1</span><span class="c4">, giving</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">{+ {let1 {x 2} x}</span></p><p class="c5"><span class="c28">   1}</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">in which we perform one more substitution, producing</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">{+ 2</span></p><p class="c5"><span class="c28">   1}</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">and hence </span><span class="c28">3</span><span class="c4">. This time, DrRacket is especially useful confirmation:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre19"><img alt="" src="image2.png" title="" class="calibre20"/></span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">That leaves just one program:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c28">x</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Because </span><span class="c28">x</span><span class="c4"> is not bound anywhere, this is just a syntax error.</span></p></body></html>
