<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.k8d10uqtunn0"><span class="c4">What is an Object?</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">The central question we must answer, before we start thinking about implementations, is what an object is. There is a lot of variation between languages, but they all seem to agree that an object is</span></p><ul class="c24"><li class="c25 pcalibre"><span class="c4">a value, that</span></li><li class="c25 pcalibre"><span class="c4">maps names to </span></li><li class="c25 pcalibre"><span class="c4">stuff: either other values or “methods”.</span></li></ul><p class="c5"><span class="c4">From a minimalist perspective, methods seem to be just functions, and since we already have those in the language, we can put aside this distinction.</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Terminology:</span><span class="calibre3"> We will use the term </span><span class="c7">member</span><span class="c4"> to refer to a generic entry in an object, when we don’t want to make a distinction between fields and methods.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">How can we capture this? An object is just a value that dispatches on a given name. For simplicity, we’ll use </span><span class="c28">lambda</span><span class="calibre3"> to represent the object and Racket’s </span><span class="c28">case</span><span class="c4"> construct to implement the dispatching. Here’s an object that responds to either add1 or sub1, and in each case returns a function that either increments or decrements:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define o</span></p><p class="c5"><span class="c41">  (lambda (m)</span></p><p class="c5"><span class="c41">    (case m</span></p><p class="c5"><span class="c41">      [(add1) (lambda (x) (+ x 1))]</span></p><p class="c5"><span class="c41">      [(sub1) (lambda (x) (- x 1))])))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">We would use this as follows:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(test ((o 'add1) 5) 6)</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Aside:</span><span class="calibre3"> Observe that basic objects are a generalization of </span><span class="c28">lambda</span><span class="calibre3"> to have multiple “entry-points”. Conversely, a </span><span class="c28">lambda</span><span class="calibre3"> is an object with only </span><span class="c7">one</span><span class="c4"> entry-point; therefore, it doesn’t need a “method name” to disambiguate.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Of course, writing method invocations with these nested function calls is unwieldy (and is about to become even more so), so we’d be best off equipping ourselves with a convenient syntax for invoking methods:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define (msg o m . a)</span></p><p class="c5"><span class="c41">  (apply (o m) a))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">This enables us to rewrite our test:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(test (msg o 'add1 5) 6)</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Aside:</span><span class="calibre3"> We’ve taken advantage of Racket’s variable-arity syntax: </span><span class="c28">. a</span><span class="calibre3"> says “bind all the remaining—zero or more—arguments to a list named </span><span class="c28">a</span><span class="calibre3">”. The </span><span class="c28">apply</span><span class="c4"> function “splices” in such lists of arguments to call functions.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Observe something very subtle about our language: nothing precludes us from writing an arbitrary expression in the second position of a call to </span><span class="c28">msg</span><span class="calibre3">. That is, we can </span><span class="c7">compute</span><span class="c4"> which member we want to access. For instance:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(test (msg o (first '(add1)) 5) 6)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">This is unlike many languages with objects, which force you to write the literal </span><span class="c7">name</span><span class="c4"> of the member (e.g., in Java, in most cases). We’ll return to this later!</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Aside:</span><span class="calibre3"> This is a general problem with desugaring: the target language may allow expressions that have no counterpart in the source, and hence cannot be mapped back to it. Fortunately we don’t often need to perform this inverse mapping, though it does arise in some debugging and program comprehension tools. More subtly, however, we must ensure that the target language does not produce </span><span class="c7">values</span><span class="c4"> that have no corresponding equivalent in the source.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Now that we have basic objects, let’s start adding the kinds of features we’ve come to expect from most object systems.</span></p></body></html>
