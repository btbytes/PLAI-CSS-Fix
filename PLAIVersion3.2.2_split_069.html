<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h1 class="c22" id="h.d119ko5rrsdg"><span class="c4">A Standard Model of Objects</span></h1><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Now we’re ready to start looking at our first major language feature that goes beyond SMoL: objects. Not all SMoL languages have objects; though many do, they have them in very different ways. Nevertheless, what we will see is that there is a fairly uniform way to think about objects across all these languages, and furthermore this way of thinking really builds on our understanding of SMoL.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">When building the essence of objects, though, we now have a choice: we can do it either in the core or through syntactic sugar. The former is frustrating in several ways:</span></p><ul class="c24"><li class="c25 pcalibre"><span class="calibre3">We have to do more low-level bookkeeping (e.g., with environments) that may not necessarily be </span><span class="c7">instructive</span><span class="c4">.</span></li><li class="c25 pcalibre"><span class="c4">The interpreter gets larger and more unwieldy, because all the new constructs go in the same place rather than each being independent definitions.</span></li><li class="c25 pcalibre"><span class="c4">Most of all: it becomes a lot harder to write illustrative programs and tests, because the core language may not have all the features we need to make this convenient.</span></li></ul><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">In contrast, all these problems go away if we use syntactic sugar instead. Therefore, even though a real implementation may well have at least parts of objects (especially the parts needed for efficiency) in the core language, we are going to build objects entirely through desugaring, using macros. In fact, in this book, we will do something even simpler: we will give </span><span class="c7">concrete examples </span><span class="calibre3">of what programs desugar </span><span class="c7">to</span><span class="c4">. Figuring out the general desugaring will be left as an exercise for you. To aid in that process, we will write code in as stylized a form as possible, not using any short-cuts that might obscure the macro rules.</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Note:</span><span class="calibre3"> The programs in this section cannot be written in the language </span><span class="c28">plait</span><span class="calibre3">. Instead, we will use  </span><span class="c28">#lang racket</span><span class="c4">, which does not perform static type-checking. Add the line</span></p><p class="c51"><span class="c4"></span></p><p class="c31"><span class="c41">(require [only-in plait test print-only-errors])</span></p><p class="c51"><span class="c4"></span></p><p class="c31"><span class="calibre3">at the top to access the testing operator and printing control parameter from </span><span class="c28">plait</span><span class="c4">.</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Exercise:</span><span class="calibre3"> Spot the point at which the type-checker would become problematic. </span><span class="c40">Hint:</span><span class="calibre3"> The easiest way is, of course, to keep using </span><span class="c28">#lang plait</span><span class="c4"> until you run into a problem. Make sure you understand what the problem is!</span></p></body></html>
