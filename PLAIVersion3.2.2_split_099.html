<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.y05m31xxm5lb"><span class="c4">Typing Function Applications</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">A function application expression has two parts: the function and the arguments. For simplicity, we’re going to assume that we’re working with single-argument functions.</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Exercise:</span><span class="calibre3"> Extend the rules below to deal with functions of arbitrary number of parameters (formally called </span><span class="c7">arity</span><span class="c4">).</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Because functions are first-class values, the function position is itself an expression. We have to check each sub-expression before we can type the whole expression. Therefore, function applications are conditional rules with two terms in the antecedent:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">|- F : ???    |- A : ???</span></p><p class="c5"><span class="c41">------------------------</span></p><p class="c5"><span class="c41">|- (F A) : ???</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">First, let’s notice that functions are different kinds of values than other values: a function is not itself a number, or string, or Boolean—it may </span><span class="c7">produce</span><span class="calibre3"> one of those, but it is not </span><span class="c7">itself</span><span class="calibre3"> one of those (an important distinction). Therefore, we need a different type for functions, which reflects what functions consume and what they produce. A natural idea is to assume functions have some “function” type, here called </span><span class="c28">Fun</span><span class="c4">:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">|- F : Fun    |- A : ???</span></p><p class="c5"><span class="c41">------------------------</span></p><p class="c5"><span class="c41">|- (F A) : ???</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">What do we know about the argument expression (the actual parameter)? It had better match the type demanded by the formal parameter. But how do we check that here? We’ve collapsed </span><span class="c7">all</span><span class="calibre3"> functions in the world into a single type, </span><span class="c28">Fun</span><span class="c4">. That’s far too coarse.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Instead, following convention, we’ll use the “arrow” syntax for functions:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">|- F : (??? -&gt; ???)    |- A : ???</span></p><p class="c5"><span class="c41">---------------------------------</span></p><p class="c5"><span class="c28">|- (F A) : ???</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">(Technically, the arrow is a </span><span class="c7">constructor</span><span class="c4"> of function types. It’s a two-place constructor, for reasons we will see below.)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">With this, we can now say that the function’s formal parameter’s type had better match up with the type of the actual argument. Which type, exactly? Functions could consume numbers, strings, even other functions…all we know is that these should be </span><span class="c7">consistent</span><span class="c4">. Notice that this is very similar to the consistency we expected of the branches of a conditional. We can again encode this by using the same placeholder in both places:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">|- F : (T -&gt; ???)    |- A : T</span></p><p class="c5"><span class="c41">-----------------------------</span></p><p class="c5"><span class="c28">|- (F A) : ???</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Now, what about what the function returns? Again, it could return values of any type. Whatever that type is, that is what the entire application produces. Again, we use a common placeholder to reflect this:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">|- F : (T -&gt; U)    |- A : T</span></p><p class="c5"><span class="c41">---------------------------</span></p><p class="c5"><span class="c28">|- (F A) : U</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">So here’s how we read this:</span></p><ul class="c24"><li class="c25 pcalibre"><span class="calibre3">Type-check the </span><span class="c28">F</span><span class="calibre3"> position. Make sure it’s a function type (</span><span class="c28">-&gt;</span><span class="calibre3">). Assuming it is, call the formal parameter’s type </span><span class="c28">T</span><span class="calibre3"> and the return type </span><span class="c28">U</span><span class="c4">.</span></li><li class="c25 pcalibre"><span class="c4">Type-check the actual parameter (the argument). Make sure it has the same type as what the function is expecting in its formal parameter.</span></li><li class="c25 pcalibre"><span class="c4">If both of those hold, then the function’s return type is the type of the entire application.</span></li></ul><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">This list of steps is what a conventional type-checker would implement. Observe that again, a type error is the result of a failure to construct a judgment. If, for instance, the actual argument’s type doesn’t match that of the formal parameter, then </span><span class="c7">the conditional rule above doesn’t apply</span><span class="calibre3"> (it applies only when we can write the same type for the </span><span class="c28">T</span><span class="c4"> placeholder), which is how we learn that the program has a type error.</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Exercise:</span><span class="c4"> Construct an example to illustrate the above type-error case.</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Aside:</span><span class="calibre3"> We intentionally don’t use a </span><span class="c7">numbered</span><span class="calibre3"> list because formally, the semantics of judgments doesn’t say that these steps have to occur in this order! For instance, the argument can be type-checked before the function; if so, that determines what the placeholder </span><span class="c28">T</span><span class="calibre3"> stands for, and the checking of </span><span class="c28">F</span><span class="calibre3"> confirms that </span><span class="c28">F</span><span class="c4">’s type matches that.</span></p><p class="c31"><span class="calibre3">Even more perversely, you can imagine checking the application, determining—from the context—what its type </span><span class="c7">needs</span><span class="calibre3"> to be (e.g., if it’s in an addition, it had better produce a number), and using that to drive the checking of </span><span class="c28">F</span><span class="calibre3">. In fact, all of these things can happen if instead of a </span><span class="c7">checker</span><span class="calibre3">, we implement type-</span><span class="c7">inference</span><span class="c4">—as we will soon see.</span></p></body></html>
