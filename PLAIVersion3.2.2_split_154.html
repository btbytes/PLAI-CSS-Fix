<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.yil5odt1xmy7"><span class="c4">Evaluating Without Substitution</span></h2><p class="c5"><span class="c4">Above, we saw how we can think of lazy evaluation using substitution. While this is a useful mental model, as we have seen in earlier interpreters, we don’t really want to use substitution as our implementation strategy. That involves repeatedly rewriting program source, which is not how our interpreter worked.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">So let’s say we don’t pass the value but instead “the expression”. Does it mean the above sequence becomes this?</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">  (f (+ 2 3))</span></p><p class="c5"><span class="c28">→ (g (+ x x))</span><span class="calibre3"> where </span><span class="c28">x</span><span class="calibre3"> is bound to </span><span class="c41">(+ 2 3)</span></p><p class="c5"><span class="c28">→ (h (* y 2))</span><span class="calibre3"> where </span><span class="c28">y</span><span class="calibre3"> is bound to </span><span class="c41">(+ (+ 2 3) (+ 2 3)))</span></p><p class="c5"><span class="c28">→ (+ x 5)</span><span class="calibre3"> where </span><span class="c28">x</span><span class="calibre3"> is bound to </span><span class="c41">(* (+ (+ 2 3) (+ 2 3)) 2)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">In fact, even this isn’t quite right. It should rather be</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">  (f (+ 2 3))</span></p><p class="c5"><span class="c28">→ (g (+ x x))</span><span class="calibre3"> where </span><span class="c28">x</span><span class="calibre3"> is bound to </span><span class="c41">(+ 2 3)</span></p><p class="c5"><span class="c28">→ (h (* y 2))</span><span class="calibre3"> where </span><span class="c28">y</span><span class="calibre3"> is bound to </span><span class="c28">(+ x x))</span><span class="calibre3"> whose </span><span class="c28">x</span><span class="calibre3"> is </span><span class="c41">(+ 2 3)</span></p><p class="c5"><span class="c28">→ (+ x 5)</span><span class="calibre3"> where </span><span class="c28">x</span><span class="calibre3"> is bound to </span><span class="c28">(* y 2)</span><span class="calibre3"> whose </span><span class="c28">y</span><span class="calibre3"> is </span><span class="c28">(+ x x))</span><span class="calibre3"> whose </span><span class="c28">x</span><span class="calibre3"> is </span><span class="c41">(+ 2 3)</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c4">In other words, we want to pass the unevaluated expression…but you can probably see where this is going! If we’re not careful, we will end up with dynamic scope. Even setting that aside, we can’t just pass the expression on its own, because when we eventually get a strictness point, we simply will have no idea what value a variable resolves to.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">However, the solution also presents itself very naturally. We don’t just pass an expression, we pass along its corresponding environment. An expression and environment combine to form a…closure! Of course, this closure does not take any parameters; its only job is to </span><span class="c7">suspend the evaluation of the expression</span><span class="calibre3"> until we reach a strictness point, and at that point, </span><span class="c7">evaluate it in the right environment</span><span class="c4">. Fortunately, we don’t need to do any new work here; closure application already does it for us.</span></p></body></html>
