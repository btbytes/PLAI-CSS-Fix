<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.xd5vu82nq8vr"><span class="c4">Return to Static Scope</span></h2><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Exercise: </span><span class="c4">Run the following programs in the Stacker.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">So how do we fix this? The examples above actually give us a clue, but there is another source of inspiration as well. Do you remember that we started with </span><span class="c7">substitution</span><span class="c4">? We’ll walk through these examples in Racket, so that you can run each of them directly and check that they produce the same answer. Consider again this program:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(let ([x 1])</span></p><p class="c5"><span class="c41">  (let ([f (lambda (y) x)])</span></p><p class="c5"><span class="c41">    (let ([x 2])</span></p><p class="c5"><span class="c41">      (f 10))))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Substituting </span><span class="c28">1</span><span class="calibre3"> for </span><span class="c28">x</span><span class="c4"> produces:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">  (let ([f (lambda (y) 1)])</span></p><p class="c5"><span class="c41">    (let ([x 2])</span></p><p class="c5"><span class="c41">      (f 10)))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Substituting </span><span class="c28">f</span><span class="c4"> produces:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">    (let ([x 2])</span></p><p class="c5"><span class="c41">      ((lambda (y) 1) 10))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Finally, substituting </span><span class="c28">x</span><span class="calibre3"> with </span><span class="c28">2</span><span class="calibre3"> produces (note that there are no </span><span class="c28">x</span><span class="c4">s left in the program!):</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c28">      ((lambda (y) 1) 10)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">When you see it this way, it’s clear </span><span class="c7">why</span><span class="calibre3"> the later binding of </span><span class="c28">x</span><span class="calibre3"> should have no impact: it’s a different </span><span class="c28">x</span><span class="calibre3">, and the earlier </span><span class="c28">x</span><span class="calibre3"> has effectively already been substituted. Since we have agreed that substitution is how we want our programs to work, our job now is to make sure that the environment actually implements that </span><span class="c7">correctly</span><span class="c4">.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">The way to do it is to recognize that the environment represents the substitutions waiting to happen, and just </span><span class="c7">remember</span><span class="c4"> them. That is, our representation of a function needs to also keep track of the environment at the moment of function creation:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define-type Value</span></p><p class="c5"><span class="c41">  [numV (the-number : Number)]</span></p><p class="c5"><span class="c41">  [boolV (the-boolean : Boolean)]</span></p><p class="c5"><span class="c28">  [funV (var : Symbol) (body : Exp) </span><span class="c64">(nv : Env)</span><span class="c41">])</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="calibre3">This new and richer kind of </span><span class="c28">funV</span><span class="calibre3"> value has a special name: it’s called a </span><span class="c7">closure</span><span class="c4">. That’s because the expression is “closed” over the environment in which it was defined.</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Terminology:</span><span class="calibre3"> A </span><span class="c7">closed</span><span class="calibre3"> term is one that has no unbound variables. The body of a function may have unbound variables—like </span><span class="c28">x</span><span class="calibre3"> above—but the closure makes sure that they aren’t </span><span class="c7">really</span><span class="c4"> unbound, because they can get their values from the stored environment.</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Quote:</span><span class="calibre3"> “Save the environment! Create a closure today!” —</span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://users.soe.ucsc.edu/~cormac/&amp;sa=D&amp;source=editors&amp;ust=1695232021221610&amp;usg=AOvVaw0ubwf31ENzplf9Txn7x4SS">Cormac Flanagan</a></span></p><p class="c51"><span class="c4"></span></p><p class="c31"><span class="c40">Quote:</span><span class="calibre3"> “Lambdas are relegated to relative obscurity until Java makes them popular by not having them.” </span><span class="c40">—</span><span class="calibre3">James Iry, </span><span class="c26"><a class="c11" href="https://www.google.com/url?q=http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html&amp;sa=D&amp;source=editors&amp;ust=1695232021222322&amp;usg=AOvVaw15zUkk_RscjegRPA01Zrxb">A Brief, Incomplete, and Mostly Wrong History of Programming Languages</a></span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">That means, when we create a closure, we have to record the environment at the time of its creation:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c28">    [(lamE v b) (funV v b </span><span class="c64">nv</span><span class="c41">)]</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Finally, when we use a function (represented by a closure), we have to make sure we use the </span><span class="c7">stored</span><span class="calibre3"> environment, not the one present at the point of calling the function, which is the </span><span class="c7">dynamic</span><span class="c4"> one:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">    [(appE f a) (let ([fv (interp f nv)]</span></p><p class="c5"><span class="c41">                      [av (interp a nv)])</span></p><p class="c5"><span class="c41">                  (type-case Value fv</span></p><p class="c5"><span class="c28">                    [(funV v b </span><span class="c64">nv</span><span class="c41">)</span></p><p class="c5"><span class="c41">                     (interp b (extend nv v av))]</span></p><p class="c5"><span class="c41">                    [else (error 'app "didn't get a function")]))]</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Just to be clear: in the code above, the </span><span class="c28">nv</span><span class="calibre3"> in the </span><span class="c28">funV</span><span class="calibre3"> case </span><span class="c7">intentionally shadows</span><span class="calibre3"> the </span><span class="c28">nv</span><span class="calibre3"> bound at the top of the interpreter. Thus, the call to </span><span class="c28">extend</span><span class="calibre3"> extends the environment </span><span class="c7">from the closure</span><span class="c4">, rather than the one present at the point of the call.</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Exercise:</span><span class="calibre3"> Notice that the function and argument expressions (</span><span class="c28">f</span><span class="calibre3"> and </span><span class="c28">a</span><span class="c4">, respectively) are evaluated in the environment given to the interpreter, not the one inside the closure. Is this correct? Or should they be using the closure’s environment? </span></p><p class="c51"><span class="c4"></span></p><p class="c31"><span class="calibre3">You can do two things: argue from first principles or argue with examples. In the latter case, you would modify the interpreter to make the other choice. You would then use a sample input that produces different answers depending on which environment is used, indicate which one is correct (showing what the equivalent Racket program would produce can be a good argument), and use that to justify the chosen environment. </span><span class="c40">Hint:</span><span class="c4"> One of these you will need to argue from first principles, the other you should be able to argue using a program.</span></p></body></html>
