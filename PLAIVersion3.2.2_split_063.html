<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.e0xxnn77cgxc"><span class="c4">Name Capture</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">But now, what if we use the above code in this kind of context:</span></p><p class="c3"><span class="c72"></span></p><p class="c5"><span class="c41">(let ([not (λ (v) v)])</span></p><p class="c5"><span class="c41">  (unless false</span></p><p class="c5"><span class="c41">    (println 1)</span></p><p class="c5"><span class="c28">    (println 2)))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">This seems problematic: it seems to expand into</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(let ([not (λ (v) v)])</span></p><p class="c5"><span class="c41">  (if (not false)</span></p><p class="c5"><span class="c41">      (begin</span></p><p class="c5"><span class="c41">        (println 1)</span></p><p class="c5"><span class="c41">        (println 2))</span></p><p class="c5"><span class="c41">      (void)))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">which is pretty much the opposite of what we want. That’s because the </span><span class="c28">not</span><span class="calibre3"> outside the macro seems to have captured the </span><span class="c28">not</span><span class="c4"> inside the macro. This is roughly analogous to dynamic scope: any use context can modify what happens inside the abstraction. If this were true, it would be terrifying to be a macro writer!</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Do Now:</span><span class="c4"> Run both versions. Do they produce the same answer?</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">But running the macro version makes clear that the name </span><span class="c28">not</span><span class="calibre3"> is </span><span class="c7">not</span><span class="calibre3"> being captured. Most of all, use the Macro Stepper to see how the expansion works. The important thing is that variables are more than just </span><span class="c7">names</span><span class="c4">; they record binding information, which keeps names introduced in different settings separate. They may print the same way, but internally Racket keeps them separate (and shows this separation in the Macro Stepper using colors). That is, it’s as if we start with this program:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c73">(let ([not (λ (v) v)])</span></p><p class="c5"><span class="c73">  (unless false</span></p><p class="c5"><span class="c73">    (println 1)</span></p><p class="c5"><span class="c74">    (println 2)))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">which, after expansion, turns into this program:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c73">(let ([not (λ (v) v)])</span></p><p class="c5"><span class="c28">  </span><span class="c75">(if (not false)</span></p><p class="c5"><span class="c75">      (begin</span></p><p class="c5"><span class="c75">        (println 1)</span></p><p class="c5"><span class="c75">        (println 2))</span></p><p class="c5"><span class="c76">      (void))</span><span class="c73">)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">So now we can easily keep the identifiers apart: the red </span><span class="c74">not</span><span class="calibre3"> is different from the blue </span><span class="c76">not</span><span class="calibre3">. The actual internal representation is an efficient analog to colors. If necessary, the macro expander can also use distinct </span><span class="c7">fresh</span><span class="calibre3"> (i.e., previously unused) names—</span><span class="c28">not1</span><span class="calibre3">, </span><span class="c28">not2</span><span class="c4">, etc.—to represent the different variables of the same name.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">This property, which recovers an analog of static scoping for macros, and is called </span><span class="c7">hygiene</span><span class="calibre3">. Hygiene is a critical feature for macros (and, notably, is one </span><span class="c7">not</span><span class="c4"> given by the C pre-processor). It lets programmers use whatever name they want in the macro definition without worrying about what names will be bound in the use context; and similarly, lets users use whatever variable names they want without worrying about the macro’s code.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">That said, you may wonder whether hygiene is just for built-in functions like </span><span class="c28">not</span><span class="c4">. We’ll see that it’s not. But to get there, we’ll work through some other idiomatic examples.</span></p></body></html>
