<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.zf7hekvcesl"><span class="c4">Algebraic Datatypes and Space</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Earlier, we’ve seen that types can save us both time and space. We have to be a little more nuanced when it comes to algebraic datatypes.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">The new type introduced by an algebraic datatype still enjoys the space saving. Because the type checker can tell a </span><span class="c28">BT</span><span class="calibre3"> apart from every other type, at run-time we don’t need to record that a value is a </span><span class="c28">BT</span><span class="calibre3">: it doesn’t need a type-tag. However, we still need to tell apart the different </span><span class="c7">variants</span><span class="calibre3">: the function </span><span class="c28">size-pm</span><span class="calibre3"> effectively desugars into (</span><span class="c28">-ds</span><span class="c4"> stands for “desugared”):</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define (size-pm-ds (t : BT))</span></p><p class="c5"><span class="c41">  (cond</span></p><p class="c5"><span class="c41">    [(mt? t) 0]</span></p><p class="c5"><span class="c41">    [(node? t)</span></p><p class="c5"><span class="c41">     (let ([v (node-v t)]</span></p><p class="c5"><span class="c41">           [l (node-l t)]</span></p><p class="c5"><span class="c41">           [r (node-r t)])</span></p><p class="c5"><span class="c41">       (+ 1 (+ (size-pm-ds l) (size-pm-ds r))))]))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">(We’ve introduced the </span><span class="c28">let</span><span class="calibre3"> to bind the names introduced by the pattern.) What this shows is that at run-time, there are conditional checks that need to know what kind of </span><span class="c28">BT</span><span class="calibre3"> is bound to </span><span class="c28">t</span><span class="c4"> on this iteration. Therefore, we need just enough tagging to tell the variants apart. In practice, this means we need as many bits as the logarithm of the number of variants; since this number is usually small, this information can often be squeezed into other parts of the data representation.</span></p><p class="c3"><span class="c4"></span></p></body></html>
