<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.ro21l25wy6zu"><span class="c4">Extending Values</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">What happens when evaluating a function? Both Racket and Python seem to suggest that we return a function.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">We could have no additional information about the function:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define-type Value</span></p><p class="c5"><span class="c41">  [numV (the-number : Number)]</span></p><p class="c5"><span class="c41">  [boolV (the-boolean : Boolean)]</span></p><p class="c5"><span class="c41">  [funV])</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="calibre3">(That syntax means </span><span class="c28">funV</span><span class="calibre3"> is a constructor of no parameters. It conveys no information at all other than the fact that it’s a </span><span class="c28">funV</span><span class="calibre3">; because we can’t mix types, it says, in particular, that a value is not numeric or a Boolean—and nothing more.) But now think about a program like this (assuming </span><span class="c28">x</span><span class="c4"> is bound):</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">{{if0 x</span></p><p class="c5"><span class="c41">      {lam x {+ x 1}}</span></p><p class="c5"><span class="c41">      {lam x {- x 2}}}</span></p><p class="c5"><span class="c41"> 5}</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">In both cases we’re going to get a </span><span class="c28">funV</span><span class="c4"> value with no additional information, so when we try to perform the application, we…can’t.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Instead, it’s clear that the function value needs to tell us about the function. We need to know the body, because that’s what we need to evaluate; but the body can (and very likely does) reference the name of the formal parameter, so we need that too. Therefore, what we really need is</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define-type Value</span></p><p class="c5"><span class="c41">  [numV (the-number : Number)]</span></p><p class="c5"><span class="c41">  [boolV (the-boolean : Boolean)]</span></p><p class="c5"><span class="c41">  [funV (var : Symbol) (body : Exp)])</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">At this point, it seems like we’ve gone to a lot of trouble for nothing. We take numeric and Boolean values and simply re-wrap them in new constructors, and now we’re doing the same thing for functions.  A certain Shakespeareian play’s title comes to mind.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Patience.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">With what we have, we can already have a functioning interpreter. The lam case is obviously very simple:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c28">    [(lamE v b) (funV v b)]</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">The application case is a bit more detailed. We need to:</span></p><ol class="c68" start="1"><li class="c69 pcalibre10"><span class="c4">Evaluate the function position, to figure out what kind of value it is.</span></li><li class="c69 pcalibre10"><span class="c4">Evaluate the argument position, since we’ve agreed that’s what happens in SMoL.</span></li><li class="c69 pcalibre10"><span class="c4">Check that the function position really does evaluate to a function. If it does not, raise an error.</span></li><li class="c69 pcalibre10"><span class="c4">Evaluate the body of the function. But because the body can refer to the formal parameter…</span></li><li class="c69 pcalibre10"><span class="c4">…first make sure the formal is bound to the actual value of the argument.</span></li></ol><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Codifying this, in stages:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c28">    [(appE f a) </span><span class="c65">(let ([fv (interp f nv)]</span></p><p class="c5"><span class="c65">                      [av (interp a nv)])</span></p><p class="c5"><span class="c64">                  …)</span><span class="c41">]</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">    [(appE f a) (let ([fv (interp f nv)]</span></p><p class="c5"><span class="c41">                      [av (interp a nv)])</span></p><p class="c5"><span class="c28">                  </span><span class="c65">(type-case Value fv</span></p><p class="c5"><span class="c65">                    [(funV v b) …]</span></p><p class="c5"><span class="c64">                    [else (error 'app "didn't get a function")]</span><span class="c28">))]</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">    [(appE f a) (let ([fv (interp f nv)]</span></p><p class="c5"><span class="c41">                      [av (interp a nv)])</span></p><p class="c5"><span class="c41">                  (type-case Value fv</span></p><p class="c5"><span class="c41">                    [(funV v b)</span></p><p class="c5"><span class="c28">                     </span><span class="c64">(interp b …)</span><span class="c41">]</span></p><p class="c5"><span class="c28">                    [else (error 'app "didn't get a function")]))]</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">    [(appE f a) (let ([fv (interp f nv)]</span></p><p class="c5"><span class="c41">                      [av (interp a nv)])</span></p><p class="c5"><span class="c41">                  (type-case Value fv</span></p><p class="c5"><span class="c41">                    [(funV v b)</span></p><p class="c5"><span class="c28">                     (interp b </span><span class="c64">(extend nv v av)</span><span class="c41">)]</span></p><p class="c5"><span class="c28">                    [else (error 'app "didn't get a function")]))]</span></p></body></html>
