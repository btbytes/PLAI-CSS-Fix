<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.d70s6cjh8dnk"><span class="c4">Typing Conditionals</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Now we’re ready to add a rule for </span><span class="c28">if</span><span class="c4">. As we have seen, different languages have different rules for what can go in the conditional clause. Since the goal of a type-checker is to catch type errors, it is common for languages with type-checkers to demand that the conditional be a Boolean (without a truthy/falsy set of Boolean values). Our goal here is not to make a value judgment but rather to illustrate how we would add a type rule for it.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">By now, we can see that we will need a conditional rule (because we want to type-check more than just constants); following SImPl, and we will need the antecedent to say something about the sub-expressions. Clearly, we need at least:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">|- C : Bool    …</span></p><p class="c5"><span class="c41">------------------</span></p><p class="c5"><span class="c41">|- (if C T E) : …</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Okay, what now? What is the type of the entire conditional expression? Technically, it should be whatever type is returned by the branch that was executed. However, a type-checker can’t know which branch will be executed; over time, both might. So we have to somehow capture the </span><span class="c7">uncertainty</span><span class="c4"> in this situation. There are two common solutions:</span></p><p class="c3"><span class="c4"></span></p><ol class="c93" start="1"><li class="pcalibre14 c94"><span class="calibre3">Introduce a new kind of type that stands for “this type </span><span class="c7">or</span><span class="calibre3"> that type” (a </span><span class="c7">union</span><span class="c4">). This is easy to introduce but creates a burden for every piece of code that will consume such a value.</span></li><li class="pcalibre14 c94"><span class="c4">Just rule that both branches should have the same type.</span></li></ol><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">The latter is a very elegant solution, because it eliminates the uncertainty entirely.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Okay, so we need to do the following things:</span></p><p class="c3"><span class="c4"></span></p><ul class="c24"><li class="c25 pcalibre"><span class="c4">Compute the type of T.</span></li><li class="c25 pcalibre"><span class="c4">Compute the type of E.</span></li><li class="c25 pcalibre"><span class="c4">Make sure T and E have the same type.</span></li><li class="c25 pcalibre"><span class="c4">Make this (same) type the result of the conditional.</span></li></ul><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">That seems like a lot: how will we express all that? Very easily, actually:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">|- C : Bool    |- T : U    |- E : U</span></p><p class="c5"><span class="c41">-----------------------------------</span></p><p class="c5"><span class="c41">|- (if C T E) : U</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Here, </span><span class="c28">U</span><span class="calibre3"> is a placeholder: it isn’t a concrete type but rather </span><span class="c7">stands for</span><span class="calibre3"> whatever type might go in that place. The repeated use of </span><span class="c28">U</span><span class="calibre3"> accomplishes all of our goals above. Read this as: “if </span><span class="c28">C </span><span class="calibre3">has type </span><span class="c28">Bool</span><span class="calibre3"> and </span><span class="c28">T</span><span class="calibre3"> has type </span><span class="c28">U</span><span class="calibre3"> and </span><span class="c28">E</span><span class="calibre3"> has [</span><span class="c7">the </span><span class="c95">same</span><span class="calibre3">] type </span><span class="c28">U</span><span class="calibre3">, then </span><span class="c28">(if C T E)</span><span class="calibre3"> has [the same] type </span><span class="c28">U</span><span class="c4">”.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Let’s see this in action on the following program:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c28">(if true 1 2)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">We get:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c90">|- true : Bool</span><span class="c41">    |- 1 : U    |- 2 : U</span></p><p class="c5"><span class="c41">--------------------------------------</span></p><p class="c5"><span class="c28">|- (if true 1 2) : U</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Either of the axioms for the other two antecedents tells us what U must be, which lets us fill in the result of U everywhere:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c90">|- true : Bool</span><span class="c41">    |- 1 : Num    |- 2 : Num</span></p><p class="c5"><span class="c41">------------------------------------------</span></p><p class="c5"><span class="c28">|- (if true 1 2) : Num</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Fortunately, the other two antecedents are also axioms:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c90">|- true : Bool</span><span class="c28">    </span><span class="c90">|- 1 : Num</span><span class="c28">    </span><span class="c91">|- 2 : Num</span></p><p class="c5"><span class="c41">------------------------------------------</span></p><p class="c5"><span class="c28">|- (if true 1 2) : Num</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">This lets us conclude that the overall term is well-typed, and that it has type </span><span class="c28">Num</span><span class="c4">.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Now let’s look at:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(if 4 1 2)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Applying the conditional rule gives us:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">|- 4 : Bool    |- 1 : U    |- 2 : U</span></p><p class="c5"><span class="c41">-----------------------------------</span></p><p class="c5"><span class="c41">|- (if 4 1 2) : U</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">However, we do not have any axiom or conditional rule that lets us conclude that </span><span class="c28">4</span><span class="calibre3"> has type </span><span class="c28">Bool</span><span class="c4"> (because, in fact, it does not). Therefore, we cannot complete the judgment:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c96">|- 4 : Bool</span><span class="c41">    |- 1 : U    |- 2 : U</span></p><p class="c5"><span class="c41">-----------------------------------</span></p><p class="c5"><span class="c28">|- (if 4 1 2) : U</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">and the program is (rightly) judged to have a type error.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">One last example:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(if true 1 "hi")</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Again, applying the conditional rule and checking off the first antecedent:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c90">|- true : Bool</span><span class="c41">    |- 1 : U    |- "hi" : U</span></p><p class="c5"><span class="c41">-----------------------------------------</span></p><p class="c5"><span class="c28">|- (if true 1 "hi") : U</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">But now we have a problem. If we apply the axiom for numbers, we replace all instances of </span><span class="c28">U</span><span class="calibre3"> with </span><span class="c28">Num</span><span class="c4"> to get:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c90">|- true : Bool</span><span class="c28">    </span><span class="c90">|- 1 : Num</span><span class="c28">    </span><span class="c92">|- "hi" : Num</span></p><p class="c5"><span class="c41">---------------------------------------------</span></p><p class="c5"><span class="c28">|- (if true 1 "hi") : Num</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Maybe we just tried the wrong axiom? We do have one more option! However, it ends up with the same net effect:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c90">|- true : Bool</span><span class="c28">    </span><span class="c96">|- 1 : Str</span><span class="c28">    </span><span class="c91">|- "hi" : Str</span></p><p class="c5"><span class="c41">---------------------------------------------</span></p><p class="c5"><span class="c28">|- (if true 1 "hi") : Str</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Because there is </span><span class="c7">no</span><span class="c4"> way to construct a judgment for this program, it too has a type error.</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Exercise:</span><span class="calibre3"> Let’s now add functions. We need two new constructs: one to introduce them (</span><span class="c28">lambda</span><span class="calibre3">) and one to use them (function application). Write down judgments for each. </span><span class="c40">Hint:</span><span class="c4"> You may need to revisit the set of types, too.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Observe that because </span><span class="c28">let</span><span class="calibre3"> desugars into </span><span class="c28">lambda</span><span class="calibre3">, once we have this, in principle we also have a conditional rule for </span><span class="c28">let</span><span class="calibre3">. (For more sophisticated language constructs this is not so straightforward; </span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/pk-resuarging-types/&amp;sa=D&amp;source=editors&amp;ust=1695232021368048&amp;usg=AOvVaw3PHiJldDLQfYPUNuwxOBi_">this paper</a></span><span class="c4"> works out some of the details.)</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Exercise:</span><span class="c4"> Add desugaring to the type-checker.</span></p></body></html>
