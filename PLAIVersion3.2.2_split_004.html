<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.dqtvwiexggqn"><span class="c4">Why a Third Edition</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Over the past several years, a significant part of </span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/&amp;sa=D&amp;source=editors&amp;ust=1695232021062166&amp;usg=AOvVaw1RZYx27xWDC--rnWjNoVEQ">my research</a></span><span class="c4"> examines how students understand programming languages at many different levels. What I have learned has convinced me that we need a new approach to teaching this material. This edition is a first iteration to that end. (It was also a chance to rewrite the prose in my current “voice”, which has evolved a lot over two decades. Virtually no text is in common with the first edition, and only some with the second.)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">We also live in a world of unprecedented linguistic diversity and novelty. It seems like every few weeks I learn about someone trying some new linguistic experiment. The wide availability of robust and interesting run-time systems—as diverse as Erlang’s, the Java Virtual Machine, the browser’s JavaScript, Racket’s, and more—makes it easy to get a working prototype “with batteries” and focus on novelty. This affects both people trying to learn new languages and those trying to build them.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Relatedly, the first edition took a very “classical” look at programming languages, shaped by my own formal training in the subject. The second edition started to migrate from it, but not entirely. The third edition has mostly broken free of those constraints, reflecting more of the current linguistic landscape. There are not many books that cover topics like “scripting” and “gradual typing” without reducing them to slogans and fluff; this book tries to cover them in more rigorous ways.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">But all this diversity brings up the important challenge of how to approach it. In other disciplines, we approach new objects by decomposing them into familiar constituent elements. Their commonalities provide an anchor, and a point of departure for what makes them novel. What are those elements for programming languages? Pedagogic tradition holds that “paradigms” are one such organizational medium, but I find them a moribund legacy of a period when computing wanted to be viewed as a “science” and felt the best way to do this was to put things in labeled boxes. But programming languages are artificial, not natural, entities, and nothing prevents designers from freely mixing between the boxes—as indeed many have. When virtually everything is “multiparadigm”, how can we make sense out of the world?</span></p></body></html>
