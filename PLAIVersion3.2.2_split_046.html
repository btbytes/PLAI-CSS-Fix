<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.9bu9gdibar49"><span class="c4">Evaluating Functions</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Now let’s think about the evaluator, which by now we can think of as turning into a full-blown interpreter.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Let’s start with the (almost) simplest kind of new program:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">{lam x {+ x x}}</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">which is represented as</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">(lamE 'x (plusE (varE 'x) (varE 'x)))</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Do Now:</span><span class="c4"> What do we want this program to evaluate to? Think in terms of types!</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Remember that </span><span class="c28">calc</span><span class="calibre3"> produces numbers. What </span><span class="c7">number</span><span class="calibre3"> does the above expression evaluate to? What number do you </span><span class="c7">expect</span><span class="c4"> it to produce?</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">If we really want to stretch our credibility, we could either make up an encoding of it in a number, or use a number in memory. But neither of these is what we would </span><span class="c7">expect</span><span class="c4">! Let’s look at what some other languages do:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">&gt; (lambda (x) (+ x x))</span></p><p class="c5"><span class="c41">#&lt;procedure&gt;</span></p><p class="c5"><span class="c41">&gt; (number? (lambda (x) (+ x x)))</span></p><p class="c5"><span class="c41">#f</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">&gt;&gt;&gt; lambda x: x + x</span></p><p class="c5"><span class="c41">&lt;function &lt;lambda&gt; at 0x108fd16a8&gt;</span></p><p class="c5"><span class="c41">&gt;&gt;&gt; isinstance(lambda x: x + x, numbers.Number)</span></p><p class="c5"><span class="c41">False</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Both Racket and Python agree: the result of creating an anonymous function is a function-kind of value, not a number. What this says is that we have to broaden the kinds of values that </span><span class="c28">interp</span><span class="c4"> can produce.</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Terminology: </span><span class="calibre3">A </span><span class="c7">side-effect</span><span class="calibre3"> is a change to the system that is visible from outside the body of a function. Typical side-effects are modifications to variables that are defined outside the function, communication with a network, changes to files, and so on.</span></p><p class="c51"><span class="c49"></span></p><p class="c31"><span class="c40">Terminology:</span><span class="calibre3"> A function is </span><span class="c7">pure</span><span class="calibre3"> if, for a given input, it always produces the same output, and has no side-effects. In reality, a computation always has </span><span class="c7">some</span><span class="c4"> side-effects, such as the consumption of energy and production of heat, but we usually overlook these because they are universal. In a few settings, however, they can matter: e.g., if a cryptographic key can be stolen by measuring these side-effects.</span></p><p class="c51"><span class="c49"></span></p><p class="c31"><span class="c40">Terminology:</span><span class="calibre3"> Traditionally, some languages have used the terms </span><span class="c7">procedure</span><span class="calibre3"> and </span><span class="c7">function</span><span class="c4"> for similar but not identical concepts. Both are function-like entities that encapsulate a body of code and can be applied (or “called”). A procedure is an encapsulation that does not produce a value; therefore, it must have side-effects to be of any use. In contrast, a function always produces a value (and may be expected to not have any side-effects). This terminology has gotten completely scrambled over the years and people now use the terms interchangeably, but if someone seems to be making a distinction between the two, they probably mean something like the above.</span></p></body></html>
