<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.v6fayh5pylk0"><span class="c4">Encoding Type Rules</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">You may have noticed that we’re writing rules that are quite similar to the typing rules we’ve written. Let’s see whether we can encode them directly.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">First, we need to encode the rules for syntactic constants:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">tc(numE, numT).</span></p><p class="c5"><span class="c41">tc(strE, strT).</span></p><p class="c5"><span class="c41">tc(boolE, boolT).</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">We will use the Prolog constant </span><span class="c28">numE</span><span class="c4"> to stand for a syntactic numeric expression, and so on.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Now, using just what we already know, we can encode the conditional rules:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">tc(plusE(L, R), numT) :-</span></p><p class="c5"><span class="c41">    tc(L, numT),</span></p><p class="c5"><span class="c41">    tc(R, numT).</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">tc(catE(L, R), strT) :-</span></p><p class="c5"><span class="c41">    tc(L, strT),</span></p><p class="c5"><span class="c41">    tc(R, strT).</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">tc(ifE(C, T, E), Ty) :-</span></p><p class="c5"><span class="c41">    tc(C, boolT),</span></p><p class="c5"><span class="c41">    tc(T, Ty),</span></p><p class="c5"><span class="c41">    tc(E, Ty).</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Note that this is literally just a syntactic transformation of the rules we wrote before!</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">With this, we can now use Prolog as a </span><span class="c7">checker</span><span class="c4">:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">tc(ifE(boolE, plusE(numE, numE), numE), numT).</span></p><p class="c5"><span class="c4">→ true</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">and as a </span><span class="c7">calculator</span><span class="c4">:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">tc(ifE(boolE, plusE(numE, numE), numE), Y).</span></p><p class="c5"><span class="c4">→ </span></p><p class="c5"><span class="c117">Y</span><span class="c118"> = </span><span class="c119">numT</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">But we can do something much more intriguing: what if we leave variables in the </span><span class="c7">program</span><span class="c4">?</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">tc(ifE(boolE, plusE(numE, Y), numE), numT).</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">This is asking Prolog to </span><span class="c7">come up with programs</span><span class="c4"> that will make this program have numeric type. Prolog responds with:</span></p><p class="c3"><span class="c4"></span></p><p class="c120"><span class="c117">Y</span><span class="c124"> = </span><span class="c125">numE</span></p><p class="c123"><span class="c117">Y</span><span class="c124"> = </span><span class="c126">plusE</span><span class="c124">(</span><span class="c127">numE</span><span class="c124">, </span><span class="c127">numE</span><span class="c128">)</span></p><p class="c120"><span class="c117">Y</span><span class="c124"> = </span><span class="c126">plusE</span><span class="c124">(</span><span class="c127">numE</span><span class="c124">, </span><span class="c126">plusE</span><span class="c124">(</span><span class="c127">numE</span><span class="c124">, </span><span class="c127">numE</span><span class="c128">))</span></p><p class="c123"><span class="c117">Y</span><span class="c124"> = </span><span class="c126">plusE</span><span class="c124">(</span><span class="c127">numE</span><span class="c124">, </span><span class="c126">plusE</span><span class="c124">(</span><span class="c127">numE</span><span class="c124">, </span><span class="c126">plusE</span><span class="c124">(</span><span class="c127">numE</span><span class="c124">, </span><span class="c127">numE</span><span class="c124">)))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">(and many more; the structure of terms reveals something about how Prolog works). That is, Prolog is acting as a </span><span class="c7">program synthesizer</span><span class="c4">.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Now let’s see how to extend this to include the type environment. For that, we have to enlarge our typing rules to include an environment as well. Recall that the environment doesn’t matter for the axioms, while the other rules just pass the environment through:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">tc(numE, _, numT).</span></p><p class="c5"><span class="c41">tc(strE, _, strT).</span></p><p class="c5"><span class="c41">tc(boolE, _, boolT).</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">tc(plusE(L, R), Env, numT) :-</span></p><p class="c5"><span class="c41">    tc(L, Env, numT),</span></p><p class="c5"><span class="c41">    tc(R, Env, numT).</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">tc(catE(L, R), Env, strT) :-</span></p><p class="c5"><span class="c41">    tc(L, Env, strT),</span></p><p class="c5"><span class="c41">    tc(R, Env, strT).</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">tc(ifE(C, T, E), Env, Ty) :-</span></p><p class="c5"><span class="c41">    tc(C, Env, boolT),</span></p><p class="c5"><span class="c41">    tc(T, Env, Ty),</span></p><p class="c5"><span class="c41">    tc(E, Env, Ty).</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="calibre3">Now let’s add the three variable-oriented rules. We will use a list of </span><span class="c28">bind</span><span class="c4"> relations to capture the environment. To look up a variable, we pattern-match on whether the variable is the first binding; if it is we can respond with the relevant type, otherwise we must search in the remaining bindings:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">tc(varE(V), [bind(V, T) | _], T).</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">tc(varE(V), [bind(_, _) | RestTEnv], T) :-</span></p><p class="c5"><span class="c28">   tc(varE(V), RestTEnv, T).</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">The Prolog notation </span><span class="c28">[ … | … ]</span><span class="calibre3"> means to decompose a list into a first, or head, element to the left of the </span><span class="c28">|</span><span class="calibre3"> and the rest, or tail, to the right of the </span><span class="c28">|</span><span class="c4">.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">The other two rules look much more like the type rules we wrote earlier:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">tc(lamE(V, B), TEnv, funT(A, R)) :-</span></p><p class="c5"><span class="c41">    tc(B, [bind(V, A) | TEnv], R).</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Observe that in the above rule, we have done away with the type annotation! This rule looks more like what we would write with type </span><span class="c7">inference</span><span class="calibre3"> than with type </span><span class="c7">checking</span><span class="c4">. Finally:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">tc(appE(F, A), TEnv, U) :-</span></p><p class="c5"><span class="c41">    tc(F, TEnv, funT(T, U)),</span></p><p class="c5"><span class="c41">    tc(A, TEnv, T).</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">We can now use these definitions with the example we used for type </span><span class="c7">inference</span><span class="c4">. Let’s translate this program (we have only single-argument functions) from before:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(lambda (v)</span></p><p class="c5"><span class="c41">  (lambda (w)</span></p><p class="c5"><span class="c41">    (if v</span></p><p class="c5"><span class="c41">        (+ w 1)</span></p><p class="c5"><span class="c41">        (+ w 2))))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">We pass this to the </span><span class="c28">tc</span><span class="c4"> relation, encoded as follows, with the type environment and result type left variable:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">tc(lamE(v, </span></p><p class="c5"><span class="c41">     lamE(w, </span></p><p class="c5"><span class="c41">       ifE(varE(v), </span></p><p class="c5"><span class="c41">           plusE(varE(w), numE),</span></p><p class="c5"><span class="c41">           plusE(varE(w), numE)))), TEnv, T)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Prolog produces the following output:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c117">T</span><span class="c118"> = </span><span class="c129">funT</span><span class="c121">(</span><span class="c119">boolT</span><span class="c121">, </span><span class="c129">funT</span><span class="c121">(</span><span class="c119">numT</span><span class="c121">, </span><span class="c119">numT</span><span class="c121">))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">In other words, it has effectively inferred the type of the function: </span><span class="c28">v</span><span class="calibre3"> has Boolean type, </span><span class="c28">w</span><span class="c4"> has numeric type, and the result of the whole expression is a number.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">In other words, it has </span><span class="c7">inferred</span><span class="c4"> the types of the parameters. Now let’s consider some type-erroneous programs:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">tc(lamE(v, ifE(boolE, strE, numE)), _, _)</span></p><p class="c5"><span class="c4">→ false</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Here, Prolog tells us it can’t find any variable name that would satisfy this shape of program. But if instead we give it a program with holes to fill in for expressions:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">tc(lamE(w, ifE(A, strE, numE)), _, _)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Prolog tries to build bigger and bigger terms that might work, and goes into an infinite loop trying to find a program that is typeable! In general, this is a problem for synthesis systems: if the problem they are given has a solution they can often find one quickly, but if it does not have a solution, they have to spend a long time trying to find one—either very long, if it’s a large but finite space to search, or infinitely long, if the space is infinite. Often, synthesizers will use heuristics to truncate this search.</span></p><p class="c3"><span class="c4"></span></p><p class="c3"><span class="c4"></span></p></body></html>
