<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.bs96alxhw7on"><span class="c4">Dynamic Dispatch</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Finally, we should make sure our objects can handle a characteristic attribute of object systems, which is the ability to invoke a method without the caller having to know or decide which object will handle the invocation.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Suppose we have a binary tree data structure, where a tree consists of either empty nodes or leaves that hold a value. In traditional functions, we are forced to implement some form of conditional—such as a </span><span class="c28">type-case</span><span class="c4">—that exhaustively lists and selects between the different kinds of trees. If the definition of a tree grows to include new kinds of trees, each of these code fragments must be modified.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Dynamic dispatch solves this problem by making that conditional branch disappear from the user’s program and instead be handled by the method selection code built into the language. The key feature that this provides is an extensible conditional. This is one dimension of the extensibility that objects provide.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Let’s first define our two kinds of tree objects:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define (mt)</span></p><p class="c5"><span class="c41">  (let ([self 'dummy])</span></p><p class="c5"><span class="c41">    (begin</span></p><p class="c5"><span class="c41">      (set! self</span></p><p class="c5"><span class="c41">            (lambda (m)</span></p><p class="c5"><span class="c41">              (case m</span></p><p class="c5"><span class="c41">                [(sum) (lambda () 0)])))</span></p><p class="c5"><span class="c41">      self)))</span></p><p class="c5"><span class="c4"> </span></p><p class="c5"><span class="c41">(define (node v l r)</span></p><p class="c5"><span class="c41">  (let ([self 'dummy])</span></p><p class="c5"><span class="c41">    (begin</span></p><p class="c5"><span class="c41">      (set! self</span></p><p class="c5"><span class="c41">            (lambda (m)</span></p><p class="c5"><span class="c41">              (case m</span></p><p class="c5"><span class="c41">                [(sum) (lambda () (+ v</span></p><p class="c5"><span class="c41">                                     (msg l 'sum)</span></p><p class="c5"><span class="c41">                                     (msg r 'sum)))])))</span></p><p class="c5"><span class="c41">      self)))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">With these, we can make a concrete tree:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define a-tree</span></p><p class="c5"><span class="c41">  (node 10</span></p><p class="c5"><span class="c41">        (node 5 (mt) (mt))</span></p><p class="c5"><span class="c41">        (node 15 (node 6 (mt) (mt)) (mt))))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">And finally, test it:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(test (msg a-tree 'sum) (+ 10 5 15 6))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Observe that both in the test case and in the </span><span class="c28">sum</span><span class="calibre3"> method of </span><span class="c28">node</span><span class="calibre3">, there is a reference to </span><span class="c28">’sum</span><span class="calibre3"> without checking whether the recipient is a </span><span class="c28">mt</span><span class="calibre3"> or </span><span class="c28">node</span><span class="calibre3">. Instead, the </span><span class="c7">language’s run-time system</span><span class="calibre3"> extracts the recipient’s </span><span class="c28">sum</span><span class="c4"> method and invokes it. This conditional missing from the user’s program, and handled automatically by the language,  is the essence of dynamic dispatch.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">It’s worth noting that we didn’t have to change our pattern to add dynamic dispatch; </span><span class="c7">it simply followed as a result of the rest of the design</span><span class="c4">.</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Aside:</span><span class="calibre3"> This property—which appears to make systems more black-box extensible because one part of the system can grow without the other part needing to be modified to accommodate those changes—is often hailed as a key benefit of object-orientation. While this is indeed an advantage objects have over functions, there is a dual advantage that functions have over objects, and indeed many object programmers end up contorting their code—using the Visitor pattern—to make it look more like a function-based organization. Read </span><span class="c26"><a class="c11" href="https://www.google.com/url?q=http://www.cs.brown.edu/~sk/Publications/Papers/Published/kff-synth-fp-oo/&amp;sa=D&amp;source=editors&amp;ust=1695232021299288&amp;usg=AOvVaw3CC6NAYK9gN3UxWzQtILYg">Synthesizing Object-Oriented and Functional Design to Promote Re-Use</a></span><span class="calibre3"> for a running example that will lay out the problem in its full glory. Try to solve it in your favorite language, and see the </span><span class="c16"><a class="c11" href="https://www.google.com/url?q=http://www.cs.utah.edu/plt/publications/icfp98-ff/paper.shtml&amp;sa=D&amp;source=editors&amp;ust=1695232021299768&amp;usg=AOvVaw1BZuSy7k1EJ8XRqphKUm57">Racket solution</a></span><span class="c4">.</span></p><p class="c3"><span class="c4"></span></p></body></html>
