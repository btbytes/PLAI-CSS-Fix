<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.o6z8cl4dhyfk"><span class="c4">Soundness</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Running on an unsafe evaluator is, as the name suggests, dangerous. Therefore, we should only do it if we can be sure that nothing can go wrong. That means that our type system needs to come with a </span><span class="c7">guarantee</span><span class="c4">.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">The way this guarantee is usually formulated is as follows. Suppose we have</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">e : t</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">and suppose we evaluate it and find that</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">e -&gt; v</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">The latter—its value—is the ground truth. The type checker’s job is to make sure it matches what the evaluator produces. That is, we would ideally like that</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c28">e : t</span><span class="calibre3"> if and only if </span><span class="c28">e -&gt; v</span><span class="calibre3"> and </span><span class="c41">v : t</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">This says that the type checker's job is to perfectly mirror the evaluator: whatever type the program’s result value has is the same type the type-checker says it has.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Unfortunately, for a Turing-complete language, this full guarantee is impossible to obtain, because of </span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://en.wikipedia.org/wiki/Rice%2527s_theorem&amp;sa=D&amp;source=editors&amp;ust=1695232021427399&amp;usg=AOvVaw1_99VdJEVQ2qFHhOKxeYso">Rice’s Theorem</a></span><span class="c4">. Instead, we have to compromise and see if we can get at least one of the two directions. When we think about it, we realize that, in a typed language, we’re only really interested in programs that pass the type-checker (i.e., have a type). Therefore, we expect that</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">If </span><span class="c28">e : t</span><span class="c4"> then</span></p><p class="c5"><span class="calibre3">        if </span><span class="c28">e -&gt; v</span><span class="calibre3">, then </span><span class="c41">v : t</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">This says that whatever type the type-checker predicted is exactly the type that the program has. That means we can rely on the type-checker’s prediction. Which in turn means that we can be sure there are no type violations. Which tells us we can safely run the program atop an unsafe evaluator! This property is called </span><span class="c7">type soundness</span><span class="c4">.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Note that soundness is not a given: it’s a property that must be formally, mathematically </span><span class="c7">proven</span><span class="calibre3"> of a given type-checker and evaluator. The proof can be quite complex. This is because the “shape” of program evaluation and that of type-checking can be very different, as we have seen before for conditionals [</span><span class="c16"><a class="c11" href="PLAIVersion3.2.2_split_096.html#h.d70s6cjh8dnk">👉</a></span><span class="calibre3">] and functions [</span><span class="c16"><a class="c11" href="PLAIVersion3.2.2_split_098.html#h.1hrl1xnfptjg">👉</a></span><span class="c4">]. And failure to prove it correctly—i.e., claiming it holds when in fact it doesn’t—means we’ve allowed a vulnerability to slip through. This can manifest as uncaught exceptions, crashes, segmentation faults, etc. In addition, a clever attacker can construct a program that exploits the vulnerability, and our system can be subjected to a security or other attack. Thus, any soundness violations are emergencies and result in panic.</span></p></body></html>
