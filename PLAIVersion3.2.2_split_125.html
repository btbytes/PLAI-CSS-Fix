<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h1 class="c22" id="h.tg4ohkq8ngzt"><span class="c4">Union Types and Retrofitted Types</span></h1><p class="c5"><span class="calibre3">Typed Racket is an instance of a </span><span class="c7">retrofitted</span><span class="calibre3">¬†type system: adding a type system to a language that did not previously have types. The original language, which does not have a static type system, is usually called </span><span class="c7">dynamic</span><span class="c4">. There are now numerous retrofitted type systems: e.g., TypeScript for JavaScript and Static Python for Python. There are even multiple retrofitted type systems for some languages: e.g., both TypeScript and Flow add types to JavaScript.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">The goal of a retrofitted type system is to turn run-time errors into static type errors. Due to the Halting Problem, we cannot precisely turn every single run-time error into a static one, so the designer of the type system must make some decisions about which errors matter more than others. In addition, programmers have already written considerable code in many dynamic languages, so changes that require programmers to rewrite code significantly would not be adopted. Instead, as much as possible, type system designers need to accommodate </span><span class="c7">idiomatic type-safe programs</span><span class="c4">.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Algebraic datatypes present a good example. Typically, they have tended to not be found in dynamic languages. Instead, these languages have some kind of structure definition mechanism (such as classes, or lightweight variants thereof, like Python‚Äôs </span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://docs.python.org/3/library/dataclasses.html&amp;sa=D&amp;source=editors&amp;ust=1695232021455665&amp;usg=AOvVaw2l-qHVAvQWW6klXtg2zXhU">dataclasses</a></span><span class="c4">). Therefore, the elegant typing that goes with algebraic datatypes and their pattern-matching does not apply. Because it is not practical to force dynamic language programmers to wholesale change to this ‚Äúnew‚Äù (to that dynamic language) style of programming, type system designers must find the idioms they use (that happen to be type-safe) and try to bless them. We will look at some examples of this.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">A good working example of a retrofitted typed language is Typed Racket, which adds types to Racket while trying to preserve idiomatic Racket programs. (This is in contrast to plait, which is also a typed form of Racket but does </span><span class="c7">not</span><span class="calibre3">¬†try very hard to preserve Racket idioms. The accessors we saw earlier, for algebraic datatypes [</span><span class="c16"><a class="c11" href="PLAIVersion3.2.2_split_120.html#h.e43aokkp4uwk">üëâ</a></span><span class="c4">], are forgiving in what they accept, at the cost of static safety.)</span></p></body></html>
