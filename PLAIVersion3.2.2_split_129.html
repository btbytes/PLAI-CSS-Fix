<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.bq382as7rh4u"><span class="c4">Introducing Union Types</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">As we discussed when evaluating conditionals [</span><span class="c16"><a class="c11" href="PLAIVersion3.2.2_split_000.html#h.d1lwuw2pv936">👉</a></span><span class="c4">], union types can be useful to represent partial functions. There are several ways of handling them:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://dcic-world.org/2022-08-28/partial-domains.html&amp;sa=D&amp;source=editors&amp;ust=1695232021470794&amp;usg=AOvVaw0tfeqewvVEB-EA9H442jKE">https://dcic-world.org/2022-08-28/partial-domains.html</a></span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Using an option type avoids the need for ad-hoc type unions. If we have unions anyway, however, then we can give types to partial functions: e.g., </span><span class="c28">(V U Boolean)</span><span class="calibre3"> in Racket or </span><span class="c28">(V U None)</span><span class="calibre3"> in Python, respectively, where </span><span class="c28">V</span><span class="calibre3"> is the normal return type. Thus, Racket’s </span><span class="c28">string-&gt;number</span><span class="calibre3"> can be given the type </span><span class="c28">(Number U Boolean)</span><span class="c4">.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">What we’ve just seen is that with if-splitting, we can eliminate union types. That then raises the possibility that we can also introduce union types! One way is of course by giving union types to built-in functions, as above. But what about in user programs? Previously we had rejected such a solution: if we introduced a union, we had no way to deal with it. Now we can safely introduce them in languages that have solutions for deconstructing them.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">How do we introduce union types? Curiously, using the same construct that eliminates them! Observe that we no longer need both branches of a conditional to return the same type:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c97">Γ </span><span class="c28">|- C : Bool    </span><span class="c97">Γ </span><span class="c28">|- T : V    </span><span class="c97">Γ </span><span class="c41">|- E : W</span></p><p class="c5"><span class="c41">-----------------------------------------</span></p><p class="c5"><span class="c97">Γ </span><span class="c28">|- (if C T E) : (U V W)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">where our notation means “the union of the types represented by </span><span class="c28">V</span><span class="calibre3"> and </span><span class="c28">W</span><span class="c4">”.</span></p></body></html>
