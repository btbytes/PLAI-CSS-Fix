<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.9c5xeccscifs"><span class="c4">Updating the Evaluator</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Now suppose we try to use our existing code:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">[(plusE l r) (+ (calc l) (calc r))]</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">This has two problems. The first is we can’t return a number; we have to return a </span><span class="c28">numV</span><span class="c4">:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">[(plusE l r) (numV (+ (calc l) (calc r)))]</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">But now we run into a subtler problem. The type-checker is not happy with this program. Why?</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Because the result of </span><span class="c28">calc</span><span class="calibre3"> is a </span><span class="c28">Value</span><span class="calibre3">, and </span><span class="c28">+</span><span class="calibre3"> consumes only </span><span class="c28">Number</span><span class="calibre3">s. Indeed, the type checker is forcing us to </span><span class="c7">make a decision</span><span class="calibre3"> here: what happens if one of the sides of </span><span class="c28">+</span><span class="c4"> does not evaluate to a number?</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">First, let’s build an abstraction to handle this, so that we can keep the core of the interpreter relatively clean:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">[(plusE l r) (add (calc l) (calc r))]</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Now we can defer all the logic of evaluating </span><span class="c28">+</span><span class="calibre3"> to </span><span class="c28">add</span><span class="calibre3">. </span><span class="c7">Now we have to make a semantic decision</span><span class="c4">. Should we be allowed to “add” two Boolean values? What about adding a number to a Boolean or vice versa? Though there isn’t quite a SMoL decision here—some languages are very strict while others are very permissive—the least-non-standard policy is to require both branches to evaluate to numbers, which we would express as follows:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define (add v1 v2)</span></p><p class="c5"><span class="c41">  (type-case Value v1</span></p><p class="c5"><span class="c41">    [(numV n1)</span></p><p class="c5"><span class="c41">     (type-case Value v2</span></p><p class="c5"><span class="c41">       [(numV n2) (numV (+ n1 n2))]</span></p><p class="c5"><span class="c41">       [else (error '+ "expects RHS to be a number")])]</span></p><p class="c5"><span class="c41">    [else (error '+ "expects LHS to be a number")]))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Observe that these </span><span class="c28">else</span><span class="c4"> clauses can easily represent other decisions. We can embed an entire family of mystery languages in the different choices available!</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Exercise:</span><span class="calibre3"> Why did we write the numV constructor in </span><span class="c28">add</span><span class="calibre3"> rather than in </span><span class="c28">calc</span><span class="c4">?</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Pro Tip:</span><span class="c4"> You’ve just added a complex chunk of code. Now would be a very good time to test your evaluator. Here are two things to consider:</span></p><p class="c51"><span class="c4"></span></p><ol class="c62" start="1"><li class="pcalibre8 c63"><span class="calibre3">Right now the code for conditionals </span><span class="c7">also</span><span class="calibre3"> does not type-check. You may find it convenient to replace the entire RHS with something semantically incorrect but type-correct, like </span><span class="c28">(numV 0)</span><span class="c4">, so you restore your working evaluator.<br class="calibre"/></span></li><li class="pcalibre8 c63"><span class="calibre3">Don’t forget to test for the error cases! You would do so using </span><span class="c28">test/exn</span><span class="calibre3">. For instance:<br class="calibre"/><br class="calibre"/></span><span class="c41">(test/exn (calc (plusE (numE 4) (boolE #false))) "RHS")</span></li></ol><p class="c51"><span class="c4"></span></p><p class="c5"><span class="c4">Let’s now turn our attention to the conditional (with the constructor name updated):</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">[(cndE c t e) …]</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">The core logic must clearly be similar: check something about the condition, and based on it, evaluate only one of the other two clauses. Once again, we have to make decisions about how we handle the conditional: should we strictly require a Boolean value, or should we make a truthy/falsy decision? We can again defer that to a helper function:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">    [(cndE c t e) (if (boolean-decision (calc c))</span></p><p class="c5"><span class="c41">                      (calc t)</span></p><p class="c5"><span class="c41">                      (calc e))]))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Again, the least non-standard policy, and one that sets up later material, is to be strict about requiring a Boolean:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define (boolean-decision v)</span></p><p class="c5"><span class="c41">  (type-case Value v</span></p><p class="c5"><span class="c41">    [(boolV b) b]</span></p><p class="c5"><span class="c41">    [else (error 'if "expects conditional to evaluate to a boolean")]))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">But again, starting from a strict interpretation, we can see where we can give in to any urges we feel to design a more liberal semantics: by replacing the </span><span class="c28">else</span><span class="c4"> clause.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Observe, by the way, that we did something different with conditionals than we did for addition. With </span><span class="c28">add</span><span class="calibre3">, we evaluated both branches and gave it their corresponding </span><span class="c28">Value</span><span class="calibre3">s. It would be a terrible idea to do that with conditionals, because the entire point of a conditional is to </span><span class="c40">not</span><span class="calibre3"> evaluate one of the branches! We could have sent the ASTs for the branches to a helper function, but what we have done above also works well: it localizes the </span><span class="c7">variation</span><span class="c4"> in the semantics to the helper function, but keeps what is not expected to change (the fact that a conditional syntax leads to a conditional evaluation) in the core of the evaluator.</span></p></body></html>
