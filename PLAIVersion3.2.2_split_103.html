<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.4k3a0d9bmmp0"><span class="c4">More Divergence Between Types and Evaluation</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">It is interesting to contrast the above pair of typing rules with the corresponding evaluation rules. In the evaluator, we visit the body of the function on every </span><span class="c7">application</span><span class="calibre3">—which could be as many as an infinite number of times in a program. In contrast, we visit the body of the function on </span><span class="c7">definition</span><span class="c4">, which happens only once. Therefore, even if the program runs forever, the type-checker is guaranteed to terminate!</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Why can we get away with this? The evaluator has to run the body with the </span><span class="c7">specific</span><span class="c4"> value it was given. The type-checker, however, has abstracted the concrete values away. Therefore, it only needs to make one pass through the body with the “abstract value”, the type.</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Aside: </span><span class="calibre3">Earlier, when we proposed the type </span><span class="c28">Fun</span><span class="calibre3">, we said that it collapsed all functions in the world into one type. This was too coarse, and we had to refine the type of a function. However, we are </span><span class="c7">still</span><span class="calibre3"> collapsing an infinite number of functions into each of those function types—just as we collapse an infinite number of strings into </span><span class="c28">Str</span><span class="c4">, and so on. Both the strength and weakness of type-checking lies in this collapsing.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">For the same reason, observe that a function application rule only cares about the </span><span class="c7">type</span><span class="calibre3"> of the function, not </span><span class="c7">which</span><span class="calibre3"> specific function is being applied. Therefore, any function that has that type can be used. For that same reason, the type-checker </span><span class="c7">cannot</span><span class="c4"> traverse the function’s body at application time—it doesn’t even know which function might be used! All communication between the function body and application must happen entirely through the type boundary.</span></p></body></html>
