<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.dirpjggvkz7z"><span class="c4">The Representation of Numbers</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Examining the content of </span><span class="c28">MEMORY</span><span class="calibre3"> gives the impression that every single number we compute is stored afresh on the heap, and furthermore, if we compute a certain number (say </span><span class="c28">3</span><span class="c4">) twice, each instance will be stored and hence take up space. However, this is not the space consumption model of real implementations.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">On most modern architectures, values are stored at </span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://en.wikipedia.org/wiki/Data_structure_alignment&amp;sa=D&amp;source=editors&amp;ust=1695232021431461&amp;usg=AOvVaw1zfmzCHLp7ziOLweunTDXZ">“word” boundaries</a></span><span class="c4">: depending on the machine, starting at addresses that are multiples of 4 or 8. For the purposes of illustration, let’s say we have a 32-bit machine, with 4-byte alignment. (The reasons for this are due to details of computer architecture that are outside the scope of this book.) That means every legal memory address, when viewed in binary, ends in …00. However, there are four legal values for those two bits, only one of which is being used. This creates an opportunity.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">A common technique is to therefore use a pattern like …01 to be the tag for numbers. The actual number itself is stored in the remaining (say 30) bits of the “address”. That means, “addresses” that end in 01 are not true addresses, and must not be looked up; they are actually just numbers.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Thus, in principle, the first thing to do with a value (that is, an address) is to test its 0’th bit. If this is 1, then shift the value right by 2 places. This drops the 01 tag, </span><span class="c7">leaving the number in place</span><span class="c4">. Similarly, when a number is constructed, provided it fits in 30 bits, it is shifted left by two places, and the last bit is made 1 (resulting in the 01 tag).</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">As a consequence, every number has a tag; but every number is also stored in registers and on the stack, not on the heap. All numbers with the same value have the same bit-pattern representation (the 30-bit numeric value followed by 01). Thus, there will be </span><span class="c7">zero</span><span class="c4"> instances of them on the heap, and they can be accurately compared for equality in constant time.</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Aside:</span><span class="c4"> Notice that the above technique only works for numbers that can fit in 30 bits (or about 60 bits in a 64-bit machine). Larger numbers have to still be stored on the heap.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">As you might imagine, we have further room to play: we still have the patterns …10 and …11. Another good candidate for fitting entirely in the address is a Boolean, so the pattern …10 could be used for that. Very short strings might fit in a word. And so on. There are many architectural, instruction-set, and program considerations in designing these tags at the low level.</span></p></body></html>
