<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.bdskqll060u1"><span class="c4">Translating to SMoL</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">The following program is a rough simulation of the above Python program </span><span class="c7">if</span><span class="calibre3"> SMoL had a notion of </span><span class="c28">yield</span><span class="calibre3">, which it does not. To avoid unbound identifier errors, we will use the following simple definition of </span><span class="c28">yield</span><span class="c4">:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(deffun (yield n)</span></p><p class="c5"><span class="c41">  n)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">We can then translate the above code as follows:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(deffun (gen)</span></p><p class="c5"><span class="c41">  (defvar n 0)</span></p><p class="c5"><span class="c41">  (deffun (loop)</span></p><p class="c5"><span class="c41">    (yield n)</span></p><p class="c5"><span class="c41">    (set! n (+ n 1))</span></p><p class="c5"><span class="c41">    (loop))</span></p><p class="c5"><span class="c41">  (loop))</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">(+ (gen) (gen) (gen))</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="calibre3">For simplicity, we’re ignoring the step where we </span><span class="c7">instantiate</span><span class="c4"> the generator: i.e., we can have only one copy of the generator in this version, whereas the Python version lets us instantiate multiple. We will return to this later.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Observe that running the above program goes into an infinite loop, because </span><span class="c28">yield</span><span class="c4"> does not “yield”. However, because the Stacker shows us intermediate steps in the computation, it still provides something very useful.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Now that we have this program, let’s run it through the Stacker. We will see a few preliminary states, and then one that looks like this:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre25"><img alt="" src="image10.png" title="" class="calibre26"/></span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">At this point, the oldest frame represents the top-level expression, which is waiting for the first call to </span><span class="c28">gen</span><span class="calibre3"> to compute. Inside </span><span class="c28">gen</span><span class="calibre3">, we have initialized </span><span class="c28">n</span><span class="calibre3"> to </span><span class="c28">0</span><span class="c4">. Now we are about to start computing the (potentially) infinite loop.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">A little bit later, we see the following:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre27"><img alt="" src="image20.png" title="" class="calibre28"/></span></p><p class="c3"><span class="c4"></span></p><p class="c8"><span class="c7">This picture is the essence of generators. Understanding it is critical.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Here is what is happening here. The top-level computation is waiting for the call to </span><span class="c28">gen</span><span class="calibre3"> to finish and produce an answer. </span><span class="c7">Within</span><span class="calibre3"> the generator, the computation has initialized n and is about to yield its current value. What is critical is the </span><span class="c7">context</span><span class="c4"> of this operation:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(begin</span></p><p class="c5"><span class="c41">  •</span></p><p class="c5"><span class="c41">  (set! n (+ n 1))</span></p><p class="c5"><span class="c41">  (loop))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">in @1678, which has no bindings and hence defers to @1909. This binds </span><span class="c28">n</span><span class="calibre3"> to </span><span class="c28">0</span><span class="c4">.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Now, suppose we could break up this stack into two parts (with the environment and store shared as needed):</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(+ • (gen) (gen))</span></p><p class="c5"><span class="c4">in @1233</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(begin</span></p><p class="c5"><span class="c41">  •</span></p><p class="c5"><span class="c41">  (set! n (+ n 1))</span></p><p class="c5"><span class="c28">  (loop))</span></p><p class="c5"><span class="c4">in @1678</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Observe that each part looks like a full-fledged stack in its own right! The environment @1233 refers to names that the top-level uses (such as </span><span class="c28">gen</span><span class="calibre3">), while the environment @1678 (and hence @1909) refers to ones that the generator uses (such as </span><span class="c28">n</span><span class="c4">).</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Until now, however, we have acted as if a program has only one stack. The simplest conceptual model for a generator is:</span></p><p class="c3"><span class="c4"></span></p><p class="c8"><span class="c4">Each generator has its own local stack.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">That is, the generator’s stack does not know about the computation in the main program or in any other generators. It only knows about the computation that it is performing. A </span><span class="c28">yield</span><span class="c4"> does two things:</span></p><p class="c3"><span class="c4"></span></p><ol class="c130" start="1"><li class="pcalibre17 c131"><span class="calibre3">It transparently (i.e., without the programmer’s knowledge) stores the </span><span class="c7">local</span><span class="c4"> stack with the generator data structure.</span></li><li class="pcalibre17 c131"><span class="c4">It returns the yielded value to the stack that invoked the generator.</span></li></ol><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Everything else—variables, aliasing, closures, growth and decline of the stack with functions calls and returns, etc.—stays exactly the same. The only difference is that calling a generator causes computation to start, or resume the context, in a separate, disconnected stack.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Thus, in the above model, after the first </span><span class="c28">yield</span><span class="c4"> succeeds, the top-level stack frame would be</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(+ 0 • (gen))</span></p><p class="c5"><span class="c4">in @1233</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">invoking the generator. This would resume the previous stack, so </span><span class="c28">n</span><span class="c4"> would be set to 1, and the next iteration of the loop would run, which would</span></p><p class="c3"><span class="c4"></span></p><ol class="c132" start="1"><li class="pcalibre18 c133"><span class="calibre3">Store the generator’s stack (which, conceptually, is exactly the same—only the value of </span><span class="c28">n</span><span class="c4"> has changed, but that is in the environment), and</span></li><li class="pcalibre18 c133"><span class="calibre3">return the new value of </span><span class="c28">n</span><span class="calibre3"> (i.e., </span><span class="c28">1</span><span class="c4">) to the top-level stack.</span></li></ol><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">This would result in </span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(+ 0 1 •)</span></p><p class="c5"><span class="c4">in @1233</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">repeating the above process, and hence producing </span><span class="c28">3</span><span class="c4">.</span></p><p class="c3"><span class="c4"></span></p></body></html>
