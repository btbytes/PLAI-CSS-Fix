<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.hmq96sdr2bi"><span class="c4">You Get a Type! And You Get a Type! And You Get a Type!</span></h2><p class="c5"><span class="calibre3">Letâ€™s return [</span><span class="c16"><a class="c11" href="PLAIVersion3.2.2_split_120.html#h.e43aokkp4uwk">ðŸ‘‰</a></span><span class="c4">] to our non-statically-type-safe accessors in plait: e.g.,</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(node-v : (BT -&gt; Number))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">In a way, itâ€™s not fair to blame the accessor: the fault is really with the constructor, because</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(node : (Number BT BT -&gt; BT))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Once the </span><span class="c28">node</span><span class="calibre3">Â constructor creates a </span><span class="c28">BT</span><span class="calibre3">, the information about </span><span class="c28">node</span><span class="calibre3">-ness is lost, and thereâ€™s not much that the accessors can do. So perhaps the alternative is to </span><span class="c7">not</span><span class="calibre3">Â create a </span><span class="c28">BT</span><span class="calibre3">, but instead create a value of the </span><span class="c28">node</span><span class="c4">Â type.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">So letâ€™s start over. This time, weâ€™ll use a different typed language, Typed Racket:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">#lang typed/racket</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">In Typed Racket, we can create products, called structures, which define a new type:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(struct mt ())</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">This creates a constructor with the type weâ€™d expect:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">&gt; mt</span></p><p class="c5"><span class="c41">- : (-&gt; mt)</span></p><p class="c5"><span class="c41">#&lt;procedure:mt&gt;</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">It also creates a predicate, whose type is a bit different; previously we had a function that could only take a </span><span class="c28">BT</span><span class="calibre3">, because it didnâ€™t make sense to apply </span><span class="c28">mt?</span><span class="calibre3">Â to any other type. Now, however, there isnâ€™t even a concept of a </span><span class="c28">BT</span><span class="calibre3">Â (yet), so </span><span class="c28">mt?</span><span class="c4">Â will take values of any type:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">&gt; mt?</span></p><p class="c5"><span class="c41">- : (-&gt; Any Boolean : mt)</span></p><p class="c5"><span class="c41">#&lt;procedure:mt?&gt;</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">(The additional text, </span><span class="c28">: mt</span><span class="c4">, is telling us when the Boolean is true; ignore this for now.)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Now letâ€™s try to define nodes. Here we run into a problem:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c28">(struct node ([v : Number] [l : </span></p></body></html>
