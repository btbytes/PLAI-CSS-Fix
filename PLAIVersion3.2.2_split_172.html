<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.44w0t98wrgzg"><span class="c4">Reactivity</span></h2><p class="c5"><span class="calibre3">There is an alternative, called </span><span class="c7">functional-reactive programming</span><span class="calibre3"> (FRP). We will see one particular instantiation, which is baked into Racket with an interesting user interface. The language is called FrTime. For technical reasons, we will not use a </span><span class="c28">#lang</span><span class="c4"> but rather choose it from the Language menu (under Other Languages).</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Do Now! </span><span class="c4">Below are some expressions whose output is best experienced in DrRacket. Run them in DrRacket and see the output for yourself!</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">FrTime essentially provides a basic version of Racket, so basic computations work exactly as we would expect:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">&gt; 5</span></p><p class="c5"><span class="c41">5</span></p><p class="c5"><span class="c41">&gt; (+ 2 3)</span></p><p class="c5"><span class="c41">5</span></p><p class="c5"><span class="c41">&gt; (string-length "hello")</span></p><p class="c5"><span class="c41">5</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">We can also ask for values like the current system time:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">&gt; (current-seconds)</span></p><p class="c5"><span class="c41">1668363009</span></p><p class="c5"><span class="c41">&gt; (add1 (current-seconds))</span></p><p class="c5"><span class="c41">1668363010</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">You will likely see a different value than the one shown above, because you are not reading this at the same time as when I wrote it. But that is a problem: indeed, even I am seeing a </span><span class="c7">stale</span><span class="c4"> value, because time has passed since I ran the command.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">The typical solution is to use callbacks. We can imagine a timer that takes a callback, which is called every time the time changes. However, this would invert control, which is exactly what happens in our timer example.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">But FrTime, following the principles of FRP, provides a special kind of value. Try it:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">&gt; seconds</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">See what happens? </span><span class="c28">seconds</span><span class="calibre3"> is a </span><span class="c7">time-varying value</span><span class="c4">: i.e., it is (technically: evaluates to) a value, but what it evaluates to changes over time. (It changes, in fact, every second.)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Naturally, we should ask: if </span><span class="c28">seconds</span><span class="c4"> evaluates to a value, we can use it in expressions, so what happens if we write expressions like these?</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">&gt; (add1 seconds)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">&gt; (modulo seconds 10)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Notice that both </span><span class="c28">add1</span><span class="calibre3"> and </span><span class="c28">modulo</span><span class="calibre3"> demand that their first argument be numbers. </span><span class="c28">seconds</span><span class="c4"> is a time-varying value that at every point in time is a number. Therefore, these expressions are well-typed, producing no errors, and in fact produce the answer we might expect (but also perhaps be a bit surprised by).</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Nothing prevents us from writing even longer expressions. Consider the function </span><span class="c28">build-list</span><span class="c4">:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">&gt; (build-list 5 (lambda (n) n))</span></p><p class="c5"><span class="c41">'(0 1 2 3 4)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">What happens if we now use a time-varying value?</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">&gt; (build-list (modulo seconds 10) (lambda (n) n))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Or build an even deeper expression:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c28">&gt; (length (build-list (modulo seconds 10) (lambda (n) n)))</span></p></body></html>
