<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.2b5j3vv7uch0"><span class="c4">Back to Typing Function Definitions</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Now we’re in a position to fill in the holes. When we check the body of the function, we should do it in an </span><span class="c7">extended</span><span class="c4"> environment:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c97">Γ</span><span class="c99">[V &lt;- ???]</span><span class="c97"> </span><span class="c41">|- B : ???</span></p><p class="c5"><span class="c41">-----------------------</span></p><p class="c5"><span class="c97">Γ </span><span class="c28">|- (lambda V B) : ???</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">where </span><span class="c97">Γ[V &lt;- _] </span><span class="calibre3">is how we write “</span><span class="c97">Γ</span><span class="calibre3"> is extended with </span><span class="c28">V</span><span class="c4"> bound to _”: this is the same environment-extension function that we’ve written before, for type environments instead of value environments, but operationally the same.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Okay, but two questions: extend </span><span class="c7">which</span><span class="calibre3"> environment, and extend it with </span><span class="c7">what</span><span class="c4">?</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Which is easy: it’s the environment of the function definition (static scope!). The repetition of </span><span class="c97">Γ</span><span class="c4"> in both the consequent and antecedent accomplishes that.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">In terms of what:  We need to provide a type for the variable so that, when we try to look up its type, the environment can return something. But we don’t know what to extend it with! The type-checker needs the </span><span class="c7">programmer to tell it</span><span class="c4"> what type the function is expecting. This is one of the reasons why programming languages expect annotations in function and method definitions. (Another—equally good—reason is because it better documents the function for people who have to use it and maintain it.)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Therefore, we have to extend the syntax of functions to include a type annotation:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c28">(lambda V : T B)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">which says that </span><span class="c28">V</span><span class="calibre3"> is expecting to be bound to a value of type </span><span class="c28">T</span><span class="calibre3"> in body </span><span class="c28">B</span><span class="c4">. Once we accept this modification, we can make progress on the conditional rule:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c97">Γ[V &lt;- </span><span class="c99">T</span><span class="c97">] </span><span class="c41">|- B : ???</span></p><p class="c5"><span class="c41">---------------------------</span></p><p class="c5"><span class="c97">Γ </span><span class="c28">|- (lambda V : </span><span class="c64">T</span><span class="c28"> B) : ???</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">What type are we expecting for the function definition? Clearly it must be a function type:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c97">Γ[V &lt;- T] </span><span class="c41">|- B : ???</span></p><p class="c5"><span class="c41">------------------------------------</span></p><p class="c5"><span class="c97">Γ </span><span class="c28">|- (lambda V : T B) : </span><span class="c64">(??? -&gt; ???)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Furthermore, we know that the type expected by the function must be </span><span class="c28">T</span><span class="c4">:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c97">Γ[V &lt;- T] </span><span class="c41">|- B : ???</span></p><p class="c5"><span class="c41">----------------------------------</span></p><p class="c5"><span class="c97">Γ </span><span class="c28">|- (lambda V : T B) : (</span><span class="c64">T</span><span class="c28"> -&gt; ???)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Given a value of type </span><span class="c28">T</span><span class="c4">, the function will return whatever the body produces:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c97">Γ[V &lt;- T] </span><span class="c28">|- B : </span><span class="c65">U</span></p><p class="c5"><span class="c41">--------------------------------</span></p><p class="c5"><span class="c97">Γ </span><span class="c28">|- (lambda V : T B) : (T -&gt; </span><span class="c64">U</span><span class="c28">)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">And that gives us our final rule for function definitions.</span></p></body></html>
