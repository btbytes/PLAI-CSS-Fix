<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.3ltfdc90y0i5"><span class="c4">Client-Side Termination</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">On the client-side Web, in JavaScript, we see the same phenomenon, but for a completely different reason. Imagine we write a factorial computation in JavaScript:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">function fact(n) {</span></p><p class="c5"><span class="c41">  ans = 1;</span></p><p class="c5"><span class="c41">  while (n != 0) {</span></p><p class="c5"><span class="c41">    ans = ans * n;</span></p><p class="c5"><span class="c41">    n = n - 1;</span></p><p class="c5"><span class="c41">  }</span></p><p class="c5"><span class="c41">  return ans;</span></p><p class="c5"><span class="c41">}</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Notice that the loop checks for </span><span class="c28">n != 0</span><span class="calibre3"> and not </span><span class="c28">n &gt; 0</span><span class="c4">, so if we put this in a Web page and run it, the program will in principle run forever:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">&lt;script type="application/javascript"&gt;</span></p><p class="c5"><span class="c41">function fact(n) {</span></p><p class="c5"><span class="c41">  ans = 1;</span></p><p class="c5"><span class="c41">  while (n != 0) {</span></p><p class="c5"><span class="c41">    ans = ans * n;</span></p><p class="c5"><span class="c41">    n = n - 1;</span></p><p class="c5"><span class="c41">  }</span></p><p class="c5"><span class="c41">  return ans;</span></p><p class="c5"><span class="c41">}</span></p><p class="c5"><span class="c41">function show() {</span></p><p class="c5"><span class="c41">  window.alert('here');</span></p><p class="c5"><span class="c41">  ans = fact(-1);</span></p><p class="c5"><span class="c41">  window.alert(ans);</span></p><p class="c5"><span class="c41">  document.getElementById('answer').innerHTML = ans;</span></p><p class="c5"><span class="c41">  </span></p><p class="c5"><span class="c41">}</span></p><p class="c5"><span class="c41">&lt;/script&gt;</span></p><p class="c5"><span class="c41">&lt;/head&gt;</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">&lt;body&gt;</span></p><p class="c5"><span class="c41">&lt;button onclick="show()"&gt;Click me&lt;/button&gt;</span></p><p class="c5"><span class="c41">&lt;div id="answer"&gt;&lt;/div&gt;</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">However, this creates a problem: the JavaScript virtual machine runs only one computation at a time, and the same JavaScript virtual machine also manages the page and the browser’s components. Therefore, if the program inside a page goes into an infinite loop, the entire page stops being responsive. For this reason, after a little while, the browser will pop up a window offering to kill the computation.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">There is a solution to this in JavaScript, but it is hardly elegant. The programmer creates a closure—called a </span><span class="c7">callback</span><span class="c4">—that represents the rest of the computation. The programmer then calls</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">setTimeout(C, 0)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">or, in more modern programs,</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">requestAnimationFrame(C)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">(though the former version perhaps makes a bit clearer what is happening), where </span><span class="c28">C</span><span class="calibre3"> is the callback. This creates an event to run </span><span class="c28">C</span><span class="calibre3"> as soon as possible (after </span><span class="c28">0</span><span class="calibre3"> units of time). The programmer then—does this sound familiar?—</span><span class="c7">terminates the program</span><span class="calibre3">. This returns control to the JavaScript virtual machine. It runs any other pending events, then arrives at this event, which it runs immediately—i.e., it “calls back” into the computation using </span><span class="c28">C</span><span class="calibre3">. If </span><span class="c28">C</span><span class="c4"> was constructed correctly, then this properly resumes the computation, as if it had never halted. Phew!</span></p></body></html>
