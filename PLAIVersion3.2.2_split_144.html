<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.a3ij6ys6ziqq"><span class="c4">Typed Racket at Work</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">In what follows, it’s critical to pay attention to the exact details of error messages!</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">First, let’s write the following function in </span><span class="c28">#lang racket</span><span class="c4"> and test it out:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define (g s)</span></p><p class="c5"><span class="c41">  (+ 1 (or (string-&gt;number s) 0)))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">As we would expect,</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">&gt; (g "5")</span></p><p class="c5"><span class="c41">6</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">because the string represents a valid number,</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">&gt; (g "hi")</span></p><p class="c5"><span class="c41">1</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">because the string doesn’t represent a valid number, and</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">&gt; (g 5)</span></p><p class="c5"><span class="c73">string-&gt;number: contract violation</span></p><p class="c5"><span class="c73">  expected: string?</span></p><p class="c5"><span class="c73">  given: 5</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">because </span><span class="c28">5</span><span class="c4"> isn’t a string at all.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Now let’s define it in Typed Racket:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3"></span><span class="c41">#lang typed/racket</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">(define (f [s : String]) : Number</span></p><p class="c5"><span class="c41">  (+ 1 (or (string-&gt;number s) 0)))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">The type-checker confirms that this program is well-typed.</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Exercise:</span><span class="c4"> As a test, try</span></p><p class="c51"><span class="c4"></span></p><p class="c31"><span class="c41">(define (f [s : String]) : Number</span></p><p class="c31"><span class="c41">  (+ 1 (string-&gt;number s)))</span></p><p class="c51"><span class="c4"></span></p><p class="c31"><span class="c4">and see what happens.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Now suppose we export this function from Typed Racket:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(provide f)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">and import it into the Racket module:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(require "typed.rkt") ;; or whatever filename you’ve chosen</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Let’s try the same three tests. Predictably, two of them work the same:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">&gt; (f "5")</span></p><p class="c5"><span class="c41">6</span></p><p class="c5"><span class="c41">&gt; (f "hi")</span></p><p class="c5"><span class="c41">1</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">The third still produces an error, but a rather different kind of error:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">&gt; (f 5)</span></p><p class="c5"><span class="c73">f: contract violation</span></p><p class="c5"><span class="c73">  expected: string?</span></p><p class="c5"><span class="c73">  given: 5</span></p><p class="c5"><span class="c73">  in: the 1st argument of</span></p><p class="c5"><span class="c73">      (-&gt; string? any)</span></p><p class="c5"><span class="c73">  contract from: typed.rkt</span></p><p class="c5"><span class="c73">  blaming: untyped.rkt</span></p><p class="c5"><span class="c73">   (assuming the contract is correct)</span></p><p class="c5"><span class="c73">  at: typed.rkt:5:9</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Here’s what is happening. When we export f from Typed Racket, we don’t just export the function in its raw form. Rather, Typed Racket wraps the function in </span><span class="c7">contracts</span><span class="c4"> that “protect” it in a dynamic setting. Thus, it is as if the function that was exported was</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define (wrapped-f s)</span></p><p class="c5"><span class="c41">  (if (string? s)</span></p><p class="c5"><span class="c41">      (let ([b (+ 1 (or (string-&gt;number s) 0))])</span></p><p class="c5"><span class="c41">        (if (number? b)</span></p><p class="c5"><span class="c41">            b</span></p><p class="c5"><span class="c41">            (error 'contract "returned value was not a Number")))</span></p><p class="c5"><span class="c41">      (error 'contract "provided value was not a String")))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">(with suitably different error messages). Notice that </span><span class="c28">wrapped-f</span><span class="calibre3"> behaves exactly like our imported </span><span class="c28">f</span><span class="calibre3"> does: the error when given </span><span class="c28">5</span><span class="c4"> is from a contract check, rather than from an internal operation. Observe also that this wrapped version is quite easy to produce in a completely mechanical way, i.e., through desugaring:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c28">(define (f [</span><span class="c115">s</span><span class="c28"> : </span><span class="c116">String</span><span class="c28">]) : </span><span class="c101">Number</span></p><p class="c5"><span class="c28">  </span><span class="c115">(+ 1 (or (string-&gt;number s) 0))</span><span class="c41">)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">became</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c28">(define (wrapped-f </span><span class="c115">s</span><span class="c41">)</span></p><p class="c5"><span class="c28">  (if (</span><span class="c116">string?</span><span class="c28"> </span><span class="c115">s</span><span class="c41">)</span></p><p class="c5"><span class="c28">      (let ([b </span><span class="c115">(+ 1 (or (string-&gt;number s) 0))</span><span class="c41">])</span></p><p class="c5"><span class="c28">        (if (</span><span class="c103">number?</span><span class="c41"> b)</span></p><p class="c5"><span class="c41">            b</span></p><p class="c5"><span class="c28">            (error 'contract "returned value was not a </span><span class="c103">Number</span><span class="c41">")))</span></p><p class="c5"><span class="c28">      (error 'contract "provided value was not a </span><span class="c116">String</span><span class="c41">")))</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Exercise:</span><span class="calibre3"> Why do we bind </span><span class="c28">b</span><span class="c4"> to the result of the body? Why not use the body expression directly?</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">The point of this wrapping is to put the type annotations to work in a dynamic setting. Essentially, the programmer who has put the effort to add annotations and get the program through the type-checker gets assurance that their function will not be abused through checks that are early and more informative than an internal error (that may not even occur, depending on the inputs, leaving the error to lurk!).</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Here is a more interesting example. We define the following typed function:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define (h [i : (-&gt; String Number)]) : Number</span></p><p class="c5"><span class="c41">  (+ (i "5") 1))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Here is its Racket counterpart:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define (j i)</span></p><p class="c5"><span class="c41">  (+ (i "5") 1))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Now let’s assume we are trying to use both of these from Racket. We first define a function that produces strings from strings, i.e., one that does </span><span class="c7">not</span><span class="calibre3"> match the function expected by either </span><span class="c28">h</span><span class="calibre3"> or </span><span class="c28">j</span><span class="c4">:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define (str-dbl s) (string-append s s))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Now watch what happens when we run </span><span class="c28">(j str-dbl)</span><span class="calibre3"> and </span><span class="c28">(h str-dbl)</span><span class="calibre3">. Both produce a run-time error, but very different ones. The former (which is entirely in Racket) gives an error at </span><span class="c28">+</span><span class="calibre3">: the “doubled” string is produced and makes it as far as </span><span class="c28">+</span><span class="calibre3">, which reports a violation. In contrast, in the latter case, the doubled string is produced but, when it tries to return from </span><span class="c28">(i "5")</span><span class="calibre3">, the type </span><span class="c28">(-&gt; String Number)</span><span class="calibre3"> has been turned into a contract, which halts execution saying that there is a </span><span class="c7">contract</span><span class="c4"> violation!</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Aside:</span><span class="calibre3"> To get a sense of Racket’s contract system, see </span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://docs.racket-lang.org/guide/contracts.html&amp;sa=D&amp;source=editors&amp;ust=1695232021518320&amp;usg=AOvVaw3cHKDevH_K7R7ne4KDUsP7">Contracts</a></span><span class="c4"> in the Racket Guide.</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Exercise: </span><span class="calibre3">Another interesting static-dynamic language combination is Racket with plait. plait does not try very much to accommodate Racket idioms, though it does to some extent: recall the predicates and accessors in algebraic dataytypes [</span><span class="c16"><a class="c11" href="PLAIVersion3.2.2_split_120.html#h.e43aokkp4uwk">👉</a></span><span class="c4">], though at the cost of static type safety. Largely, however, plait is trying to implement the Standard ML type language. Nevertheless, because plait lives in the context of Racket, its values can be exported and used from Racket. Try the above examples in plait!</span></p></body></html>
