<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h1 class="c22" id="h.kus22glln4xa"><span class="c4">Generators</span></h1><h2 class="c23" id="h.lj5w51p6s1j8"><span class="c4">A Canonical Example</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Consider the following canonical Python program that uses generators:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">def nats():</span></p><p class="c5"><span class="c41">  n = 0</span></p><p class="c5"><span class="c41">  while True:</span></p><p class="c5"><span class="c41">    yield n</span></p><p class="c5"><span class="c41">    n += 1</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">g = nats()</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">next(g) + next(g) + next(g)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">produces </span><span class="c28">0 + 1 + 2</span><span class="calibre3"> = </span><span class="c28">3</span><span class="c4">. But how does it work?</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">At a textual level, we can understand it as follows. </span><span class="c28">nats</span><span class="calibre3"> looks like a function, but it has the keyword </span><span class="c28">yield</span><span class="calibre3"> in it. This makes it not a function but a </span><span class="c7">generator</span><span class="calibre3">. Its body initializes </span><span class="c28">n</span><span class="calibre3"> to </span><span class="c28">0</span><span class="calibre3">, then goes into an infinite loop. Each time through the loop, it </span><span class="c7">yields</span><span class="calibre3"> the current value of </span><span class="c28">n</span><span class="c4">, then increments it, before continuing the loop.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Outside the definition of </span><span class="c28">nats</span><span class="calibre3">, we define </span><span class="c28">g</span><span class="calibre3"> to be an </span><span class="c7">instance</span><span class="calibre3"> of the generator, and each call to </span><span class="c28">next</span><span class="calibre3"> gets the next yielded value. This explains the result. What we need to do is understand what is going on inside </span><span class="c28">nats</span><span class="c4">, and hence what happens with generators in general.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">It is clear that we </span><span class="c7">cannot</span><span class="calibre3"> think of </span><span class="c28">nats</span><span class="calibre3"> (or of the generator returned by it) as a function. If we do, then clearly it goes into an infinite loop. That means the very first </span><span class="c28">next</span><span class="calibre3"> call would run forever; it would never produce a value, which enables the next </span><span class="c28">next</span><span class="c4"> call, and then the third, producing the sum. To see this, imagine we had the following version instead:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">def natsr():</span></p><p class="c5"><span class="c41">  n = 0</span></p><p class="c5"><span class="c41">  while True:</span></p><p class="c5"><span class="c41">    return n</span></p><p class="c5"><span class="c41">    n += 1</span></p><p class="c3"><span class="c41"></span></p><p class="c5"><span class="c41">natsr() + natsr() + natsr()</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Here, even though natsr (“</span><span class="c28">nats</span><span class="calibre3"> with </span><span class="c28">return</span><span class="calibre3">”) has an infinite loop, every time Python runs the </span><span class="c28">return</span><span class="calibre3">, it halts the function and returns. Furthermore, on the next call, we start again from the beginning of </span><span class="c28">natsr</span><span class="calibre3">. As a result, each call produces </span><span class="c28">0</span><span class="calibre3"> so the sum is also </span><span class="c28">0</span><span class="c4">.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">In contrast, that is clearly not what is happening in (the generator created by) </span><span class="c28">nats</span><span class="calibre3">. Rather, it’s clear that—as the name </span><span class="c28">yield</span><span class="calibre3"> suggests—the computation is </span><span class="c7">halting</span><span class="calibre3"> when the </span><span class="c28">yield</span><span class="calibre3"> occurs. When we call </span><span class="c28">next</span><span class="calibre3">, computation does not start at the top of </span><span class="c28">nats</span><span class="calibre3">; if it did, </span><span class="c28">n</span><span class="calibre3"> would be </span><span class="c28">0</span><span class="calibre3">. Instead, it </span><span class="c7">resumes</span><span class="calibre3"> from where it left off, so that the value of </span><span class="c28">n</span><span class="calibre3"> is incremented and the next iteration of the </span><span class="c28">while</span><span class="c4"> loop occurs.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">If all of this sounds suspiciously like variables in a scope being held on to by a closure, you’re on the right track. To understand this more, though, we need to peer a bit more closely at the evaluation. While we could run this in the </span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://pythontutor.com/python-debugger.html%23mode%3Dedit&amp;sa=D&amp;source=editors&amp;ust=1695232021543587&amp;usg=AOvVaw1V3VjgOrP0CFbXmfhLsC-A">Python Tutor</a></span><span class="c4">, that tool does not really have the support necessary for us to understand what is happening in this program. Instead, we will turn to our Stacker.</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Aside: </span><span class="calibre3">In Python, generators are merely syntactic sugar over the more general notion of </span><span class="c7">iterators</span><span class="calibre3">. Iterators respond to the </span><span class="c28">next</span><span class="calibre3"> protocol. To learn how a generator desugars into an iterator, see </span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://stackoverflow.com/questions/2776829/difference-between-pythons-generators-and-iterators&amp;sa=D&amp;source=editors&amp;ust=1695232021544241&amp;usg=AOvVaw2tKB37Q1fKdFcreD_ejsF-">this StackOverflow post</a></span><span class="calibre3">. To understand Python generators in more depth, see sections 4.1 and 4.3 of </span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/pmmwplck-python-full-monty/&amp;sa=D&amp;source=editors&amp;ust=1695232021544525&amp;usg=AOvVaw1G24Y80eCAnFcayzoealQX">this paper</a></span><span class="c4">.</span></p></body></html>
