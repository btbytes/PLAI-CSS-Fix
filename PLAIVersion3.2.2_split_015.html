<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.nin2n4sergiw"><span class="c4">Simulating an Interpreter by Hand</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Since we have decided to write an interpreter, letâ€™s start by understanding </span><span class="c7">what</span><span class="calibre3">Â we are trying to get it to do, before we start to investigate </span><span class="c7">how</span><span class="c4">Â we will make it do it.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Letâ€™s consider the following program:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define (f x) (+ x 1))</span></p><p class="c5"><span class="c41">(f 2)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">What does it produce? We can all guess that it produces </span><span class="c28">3</span><span class="calibre3">. Now suppose weâ€™re asked, </span><span class="c7">why</span><span class="calibre3">Â does it produce </span><span class="c28">3</span><span class="c4">? What might you say?</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Thereâ€™s a good chance youâ€™ll say that itâ€™s because x gets replaced with 2 in the body of f, then we compute the body, and thatâ€™s the answer:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c42">â†’</span><span class="calibre3">Â </span><span class="c41">(f 2)</span></p><p class="c5"><span class="calibre3">â†’ </span><span class="c28">(+ x 1)</span><span class="calibre3">Â where </span><span class="c28">x</span><span class="calibre3">Â is replaced by </span><span class="c41">2</span></p><p class="c5"><span class="calibre3">â†’ </span><span class="c41">(+ 2 1)</span></p><p class="c5"><span class="calibre3">â†’ </span><span class="c41">3</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">These programs are written in Racket. You can put these programs into DrRacket in an early student language level (like Beginning Student) and watch them run, step-by-step, using the Step button in the menu bar: </span></p><p class="c3"><span class="c4"></span></p><p class="c8"><span class="calibre8"><img alt="" src="image21.png" title="" class="calibre9"/></span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Now letâ€™s look at an extended version of the program:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">;; f is the same as before</span></p><p class="c5"><span class="c41">(define (g z)</span></p><p class="c5"><span class="c41">Â  (f (+ z 4)))</span></p><p class="c5"><span class="c41">(g 5)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">We can use the same process:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c42">â†’</span><span class="calibre3">Â </span><span class="c41">(g 5)</span></p><p class="c5"><span class="calibre3">â†’ (</span><span class="c28">f (+ z 4))</span><span class="calibre3">Â where </span><span class="c28">z</span><span class="calibre3">Â is replaced by </span><span class="c41">5</span></p><p class="c5"><span class="calibre3">â†’ </span><span class="c41">(f (+ 5 4))</span></p><p class="c5"><span class="calibre3">â†’ </span><span class="c41">(f 9)</span></p><p class="c5"><span class="calibre3">â†’ </span><span class="c28">(+ x 1)</span><span class="calibre3">Â where </span><span class="c28">x</span><span class="calibre3">Â is replaced by </span><span class="c41">9</span></p><p class="c5"><span class="calibre3">â†’ </span><span class="c41">(+ 9 1)</span></p><p class="c5"><span class="calibre3">â†’ </span><span class="c41">10</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Terminology:</span><span class="calibre3">Â We call the variables in the function header the </span><span class="c7">formal parameters</span><span class="calibre3">Â and the expressions in the function call the </span><span class="c7">actual parameters</span><span class="calibre3">. So in </span><span class="c28">f</span><span class="calibre3">, </span><span class="c28">x</span><span class="calibre3">Â is the formal parameter, while </span><span class="c28">9</span><span class="calibre3">Â is an actual parameter. Some people also use </span><span class="c7">argument</span><span class="calibre3">Â in place of </span><span class="c7">parameter</span><span class="c4">, but thereâ€™s no real difference between these terms.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Observe that we had a choice: we could have gone either</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">â†’ </span><span class="c41">(f (+ 5 4))</span></p><p class="c5"><span class="calibre3">â†’ </span><span class="c41">(f 9)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">or</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">â†’ </span><span class="c41">(f (+ 5 4))</span></p><p class="c5"><span class="calibre3">â†’ </span><span class="c28">(+ x 1)</span><span class="calibre3">Â where </span><span class="c28">x</span><span class="calibre3">Â is replaced by </span><span class="c41">(+ 5 4)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">For now, both will produce the same </span><span class="c7">answer</span><span class="c4">, but this is actually a very consequential decision! It is in fact one of the most profound choices in programming language design.</span></p><p class="c3"><span class="c4"></span></p><p class="c31"><span class="c40">Terminology:</span><span class="calibre3">Â The former choice is called </span><span class="c7">eager</span><span class="calibre3">Â evaluation: think of it as â€œeagerlyâ€ reducing the actual parameter to a value before starting the function call. The latter choice is called </span><span class="c7">lazy</span><span class="c4">Â evaluation: think of it as not rushing to perform the evaluation.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c7">SMoL is eager</span><span class="calibre3">. There are good reasons for this, which we will explore later [</span><span class="c16"><a class="c11" href="PLAIVersion3.2.2_split_151.html#h.9cpi3w9pvb34">ğŸ‘‰</a></span><span class="c4">].</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Okay, so back to evaluation. Letâ€™s do one more step:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">;; f is the same as before</span></p><p class="c5"><span class="c41">;; g is the same as before</span></p><p class="c5"><span class="c41">(define (h z w)</span></p><p class="c5"><span class="c41">Â  (+ (g z) (g w)))</span></p><p class="c5"><span class="c41">(h 6 7)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Once again, we can look at the steps:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c42">â†’</span><span class="calibre3">Â </span><span class="c41">(h 6 7)</span></p><p class="c5"><span class="calibre3">â†’ (+ </span><span class="c28">(g z) (g w))</span><span class="calibre3">Â where </span><span class="c28">z</span><span class="calibre3">Â is replaced by </span><span class="c28">6</span><span class="calibre3">Â and </span><span class="c28">w</span><span class="calibre3">Â is replaced by </span><span class="c41">7</span></p><p class="c5"><span class="calibre3">â†’ </span><span class="c41">(+ (g 6) (g 7))</span></p><p class="c5"><span class="calibre3">â†’ </span><span class="c28">(+ (f (+ y 4)) (g 7))</span><span class="calibre3">Â where </span><span class="c28">y</span><span class="calibre3">Â is replaced by </span><span class="c41">6</span></p><p class="c5"><span class="calibre3">â†’ </span><span class="c41">(+ (f (+ 6 4)) (g 7))</span></p><p class="c5"><span class="calibre3">â†’ </span><span class="c41">(+ (f 10) (g 7))</span></p><p class="c5"><span class="calibre3">â†’ </span><span class="c28">(+ (+ x 1) (g 7))</span><span class="calibre3">Â where </span><span class="c28">x</span><span class="calibre3">Â is replaced by </span><span class="c41">10</span></p><p class="c5"><span class="calibre3">â†’ </span><span class="c41">(+ (+ 10 1) (g 7))</span></p><p class="c5"><span class="calibre3">â†’ </span><span class="c41">(+ 11 (g 7))</span></p><p class="c5"><span class="calibre3">â†’ </span><span class="c28">(+ 11 (f (+ y 4)))</span><span class="calibre3">Â where </span><span class="c28">y</span><span class="calibre3">Â is replaced by </span><span class="c41">7</span></p><p class="c5"><span class="calibre3">â†’ </span><span class="c41">(+ 11 (f (+ 7 4)))</span></p><p class="c5"><span class="calibre3">â†’ </span><span class="c41">(+ 11 (f 11))</span></p><p class="c5"><span class="calibre3">â†’ </span><span class="c28">(+ 11 (+ x 1))</span><span class="calibre3">Â where </span><span class="c28">x</span><span class="calibre3">Â is replaced by </span><span class="c41">11</span></p><p class="c5"><span class="calibre3">â†’ </span><span class="c41">(+ 11 (+ 11 1))</span></p><p class="c5"><span class="calibre3">â†’ </span><span class="c41">(+ 11 12)</span></p><p class="c5"><span class="calibre3">â†’ </span><span class="c41">23</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c4">Observe that we again had some choices:</span></p><ul class="c24"><li class="c25 pcalibre"><span class="c4">Do we replace both calls at once, or do one at a time?</span></li><li class="c25 pcalibre"><span class="c4">If the latter, do we do the left or the right one first?</span></li></ul><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Languages have to make decisions about these, too! Above, weâ€™ve again done what SMoL does: it finishes one call before starting the other, which makes SMoL </span><span class="c7">sequential</span><span class="calibre3">. Had we replaced both calls at once, weâ€™d be exploring a </span><span class="c7">parallel</span><span class="c4">Â language. Conventionally, most languages choose a left-to-right order, so thatâ€™s what we choose in SMoL.</span></p></body></html>
