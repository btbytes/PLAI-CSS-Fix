<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="c">
<h2 class="c27" id="h.2v900v8vasnc"><span class="c4">Using Truthy-Falsy Values</span></h2><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">Some languages use truthy-falsy values to handle partial functions. Instead of signaling an error, they return a falsy value when the argument cannot be handled. For instance, it is common to return </span><span class="c28">#false</span><span class="calibre3">Â in Racket or </span><span class="c28">None</span><span class="c4">Â in Python as an error code, and a proper value for normal execution. Consider this Racket example:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(define (g s)</span></p><p class="c5"><span class="c28">Â  (+ 1 (or (string-&gt;number s) 0)))</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">This function accepts a string that may or may not represent a number. If it does, it returns one bigger number; otherwise it returns </span><span class="c28">1</span><span class="c4">:</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="c41">(test (g "5") 6)</span></p><p class="c5"><span class="c41">(test (g "hello") 1)</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">This works because </span><span class="c28">string-&gt;number</span><span class="calibre3">Â returns a number or, if the string is not legal, </span><span class="c28">#false</span><span class="calibre3">. In Racket, all values other than </span><span class="c28">#false</span><span class="calibre3">Â are truthy. Thus, legitimate strings short-circuit evaluation of the </span><span class="c28">or</span><span class="calibre3">, while non-numeric strings result in </span><span class="c28">0</span><span class="c4">. These therefore serve as a rough-and-ready option types in languages that donâ€™t (or didnâ€™t) have proper datatype constructors.</span></p><p class="c3"><span class="c4"></span></p><p class="c5"><span class="calibre3">We will discuss this issue further later in the book [</span><span class="c16"><a class="c11" href="PLAIVersion3.2.2_split_125.html#h.tg4ohkq8ngzt">ðŸ‘‰</a></span><span class="c4">].</span></p></body></html>
